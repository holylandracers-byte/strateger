<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <!-- Google API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Strateger - Race Strategy Manager</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2322d3ee' width='100' height='100' rx='15'/><text x='50' y='70' text-anchor='middle' font-size='60' fill='black' font-weight='bold'>S</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
	<script src="https://bernardo-castilho.github.io/DragDropTouch/DragDropTouch.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
	<style>
		/* Fallback icons if Font Awesome blocked */
		.fa-server:before { content: "üñ•Ô∏è"; }
		.fa-mobile-screen:before { content: "üì±"; }
		.fa-cloud-rain:before { content: "üåßÔ∏è"; }
		.fa-cloud-showers-heavy:before { content: "üåßÔ∏è"; }
	</style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
	<script src="/js/racefacer-scraper.js"></script>
	<script src="/js/apex-scraper.js"></script>
	<script src="/js/live-timing-manager.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        navy: { 950: '#020617', 900: '#0f172a', 800: '#1e293b', 700: '#334155' },
                        ice: '#22d3ee',
                        neon: '#a3e635',
                        danger: '#ef4444',
                        fuel: '#f97316',
                        squadA: '#3b82f6',
                        squadB: '#06b6d4',
                        live: '#ef4444',
                        gold: '#fbbf24',
                        silver: '#9ca3af',
                        bronze: '#f97316'
                    },
                    animation: { 
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'flash': 'flash 0.5s ease-in-out'
                    }
                }
            }
        }
    </script>
    <style>
		/* ==================== BASE STYLES ==================== */
		:root {
			--safe-area-top: env(safe-area-inset-top);
			--safe-area-bottom: env(safe-area-inset-bottom);
			--navy-950: #020617;
			--navy-900: #0f172a;
			--navy-800: #1e293b;
			--navy-700: #334155;
			--ice: #22d3ee;
			--neon: #a3e635;
			--danger: #ef4444;
			--fuel: #f97316;
		}
		
		html, body {
			margin: 0;
			padding: 0;
			height: 100%;
			overflow: hidden;
			overscroll-behavior: none;
			-webkit-overflow-scrolling: touch;
		}
		
		body { 
			background: var(--navy-950); 
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
			padding-top: var(--safe-area-top);
			padding-bottom: var(--safe-area-bottom);
		}

		/* ==================== TAILWIND FALLBACKS ==================== */
		.hidden { display: none !important; }
		.flex { display: flex; }
		.flex-col { flex-direction: column; }
		.flex-1 { flex: 1 1 0%; }
		.items-center { align-items: center; }
		.justify-center { justify-content: center; }
		.gap-2 { gap: 0.5rem; }
		.gap-3 { gap: 0.75rem; }
		.p-2 { padding: 0.5rem; }
		.p-3 { padding: 0.75rem; }
		.p-4 { padding: 1rem; }
		.rounded { border-radius: 0.25rem; }
		.rounded-lg { border-radius: 0.5rem; }
		.text-white { color: white; }
		.text-center { text-align: center; }
		.font-bold { font-weight: 700; }
		.w-full { width: 100%; }
		.border { border-width: 1px; }
		.bg-navy-950 { background-color: var(--navy-950); }
		.bg-navy-900 { background-color: var(--navy-900); }
		.text-ice { color: var(--ice); }
		.text-neon { color: var(--neon); }
		.overflow-y-auto { overflow-y: auto !important; -webkit-overflow-scrolling: touch; }

		/* ==================== ANIMATIONS ==================== */
		@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
		@keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
		
		.sync-dot { 
			width: 8px; 
			height: 8px; 
			border-radius: 50%; 
			animation: pulse 2s infinite; 
		}
		.live-dot { 
			background: var(--danger); 
			box-shadow: 0 0 8px var(--danger); 
		}
		.flash-alert { animation: flash 0.3s ease-in-out 3; }

		/* ==================== BUTTONS ==================== */
		.btn-press { 
			transition: transform 0.1s, box-shadow 0.1s;
			-webkit-tap-highlight-color: transparent;
		}
		.btn-press:active { transform: scale(0.95); }
		
		.big-digit { 
			font-variant-numeric: tabular-nums; 
			letter-spacing: 0.05em; 
		}

		/* ==================== PROGRESS BAR ==================== */
		.zone-forbidden { 
			background: repeating-linear-gradient(45deg, #ef4444, #ef4444 5px, #991b1b 5px, #991b1b 10px); 
			opacity: 0.3; 
		}
		.zone-optimal { 
			background: linear-gradient(90deg, #22c55e, #a3e635); 
		}

		/* ==================== RTL SUPPORT ==================== */
		[dir="rtl"] .grid { direction: rtl; }

		/* ==================== LIVE TIMING ==================== */
		.position-up { color: #22c55e; }
		.position-down { color: #ef4444; }
		.position-same { color: #9ca3af; }
		.competitor-row { transition: background-color 0.3s; }
		.competitor-row.our-team { 
			background: rgba(34, 211, 238, 0.2); 
			border: 1px solid var(--ice); 
		}
		.competitor-row.danger-zone { 
			background: rgba(239, 68, 68, 0.15); 
		}

		/* ==================== FORM ELEMENTS ==================== */
		input[type="radio"]:checked + span { color: var(--ice); font-weight: bold; }
		.has-\[\:checked\]\:border-ice:has(:checked) { border-color: var(--ice); }
		.has-\[\:checked\]\:bg-ice\/20:has(:checked) { background-color: rgba(34, 211, 238, 0.2); }
		
		.starter-radio:focus,
		.starter-indicator:focus {
			outline: none;
			scroll-margin: 0;
			scroll-behavior: auto;
		}
		
		.starter-radio:checked + div {
			border-color: var(--ice) !important;
			background-color: rgba(34, 211, 238, 0.3);
			box-shadow: 0 0 8px rgba(34, 211, 238, 0.5);
		}
		
		#langSelect {
			width: auto !important;
			max-width: 50px;
		}

		/* ==================== SIMULATION PREVIEW ==================== */
		.simulation-preview {
			background: linear-gradient(135deg, var(--navy-800) 0%, var(--navy-900) 100%);
			border: 2px solid var(--ice);
			border-radius: 1rem;
			padding: 1rem;
		}

		.stint-timeline {
			position: relative;
			height: 60px;
			background: var(--navy-900);
			border-radius: 0.5rem;
			overflow: hidden;
		}

		.stint-block {
			position: absolute;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.75rem;
			font-weight: bold;
			border-right: 2px solid var(--navy-950);
			transition: all 0.3s;
		}

		.stint-block:hover {
			transform: scaleY(1.1);
			z-index: 10;
		}

		.pit-marker {
			position: absolute;
			width: 3px;
			height: 100%;
			background: var(--danger);
			box-shadow: 0 0 8px var(--danger);
		}

		.time-marker {
			position: absolute;
			bottom: -20px;
			font-size: 0.65rem;
			color: #9ca3af;
			transform: translateX(-50%);
		}

		/* ==================== VIEWER MODE ==================== */
		.viewer-mode button:not(.btn-view-only),
		.viewer-mode .editable,
		.viewer-mode input,
		.viewer-mode select:not(#langSelect),
		.viewer-mode .host-only {
			display: none !important;
		}

		.viewer-mode .btn-view-only {
			cursor: default !important;
			pointer-events: auto !important;
		}

		/* ==================== SCROLLABLE AREAS ==================== */
		#driversList {
			-webkit-overflow-scrolling: touch;
		}
		
		#setupScreen {
			overflow-y: auto !important;
			-webkit-overflow-scrolling: touch;
			height: 100%;
			max-height: 100vh;
			padding-bottom: env(safe-area-inset-bottom, 1rem);
		}

		#previewScreen {
			max-height: 100vh;
			overflow-y: auto;
			padding-bottom: env(safe-area-inset-bottom, 1rem);
		}

		#setupScreen > div,
		#previewScreen > div {
			padding-bottom: 2rem;
		}

		#startRaceBtn,
		#previewScreen .flex.gap-3:last-of-type {
			margin-bottom: 0;
		}

		/* ==================== DASHBOARD LAYOUT ==================== */
		#raceDashboard {
			max-width: 100%;
		}

		/* ==================== RESPONSIVE: MOBILE (< 480px) ==================== */
		@media (max-width: 480px) {
			header > div,
			header .flex {
				padding: 0.25rem 0.5rem;
				gap: 0.25rem !important;
			}
			
			#hostCodeDisplay {
				padding: 0.25rem 0.5rem !important;
			}
			
			#hostCodeDisplay code {
				font-size: 0.65rem !important;
			}
			
			#hostCodeDisplay .text-\[10px\],
			#hostCodeDisplay .text-\[9px\] {
				display: none;
			}
			
			#syncControls {
				padding: 0.25rem 0.5rem !important;
			}
			
			#syncControls .text-xs,
			#syncControls .text-\[10px\] {
				font-size: 0.6rem !important;
			}
			
			#langSelect {
				padding: 0.15rem 0.25rem !important;
				font-size: 0.6rem !important;
			}
		}

		/* ==================== RESPONSIVE: SMALL SCREENS (< 640px) ==================== */
		@media (max-width: 640px) {
			.simulation-preview {
				padding: 0.75rem;
			}
			
			.simulation-preview h2 {
				font-size: 1.25rem;
			}
			
			.simulation-preview h3 {
				font-size: 1rem;
			}
			
			#previewScreen .flex.gap-3:last-of-type {
				flex-direction: column;
			}
			
			#previewScreen .flex.gap-3:last-of-type button {
				width: 100%;
			}
			
			#strategySummary {
				grid-template-columns: 1fr !important;
			}
		}

		/* ==================== RESPONSIVE: TABLET (768px+) ==================== */
		@media (min-width: 768px) {
			#raceDashboard {
				border-left: 1px solid var(--navy-700);
				border-right: 1px solid var(--navy-700);
			}
			
			#setupScreen .max-w-md {
				max-width: 500px;
			}
		}

		/* ==================== RESPONSIVE: DESKTOP (1024px+) ==================== */
		@media (min-width: 1024px) {
			.text-4xl {
				font-size: 3rem;
			}
			
			.text-2xl {
				font-size: 1.75rem;
			}
		}

		/* ==================== GOOGLE INTEGRATION ==================== */
		.google-btn {
			background: white;
			color: #444;
			border: 1px solid #ddd;
			padding: 0.5rem 1rem;
			border-radius: 0.5rem;
			display: flex;
			align-items: center;
			gap: 0.5rem;
			font-weight: 500;
			cursor: pointer;
			transition: background 0.2s, box-shadow 0.2s;
		}
		
		.google-btn:hover {
			background: #f8f8f8;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}
		
		.google-btn img {
			width: 18px;
			height: 18px;
		}
		
		.user-avatar {
			width: 32px;
			height: 32px;
			border-radius: 50%;
			border: 2px solid var(--ice);
		}
	</style>
</head>
<body class="bg-navy-950 text-gray-200 min-h-screen flex flex-col">
    <!-- Header -->
	<header class="bg-navy-900 border-b border-gray-800 shrink-0">
		<div class="flex justify-between items-center px-2 py-1 gap-1">
			<!-- Language Select - LEFT -->
			<select id="langSelect" onchange="setLanguage(this.value)" 
					class="text-xs bg-navy-800 px-1 py-0.5 rounded border border-gray-700 text-white cursor-pointer w-12">
				<option value="en">EN</option>
				<option value="he">HE</option>
				<option value="fr">FR</option>
				<option value="pt">PT</option>
			</select>
			
			<!-- Sync Status - CENTER -->
			<div id="syncControls" class="hidden flex items-center gap-1 bg-navy-800 px-2 py-1 rounded border border-gray-700">
				<span id="syncDot" class="sync-dot bg-green-500"></span>
				<span id="syncText" class="text-[10px] text-gray-400" data-i18n="synced">Synced</span>
			</div>
			
			<div id="liveIndicator" class="hidden sync-dot live-dot"></div>
			
			<!-- Host Code - RIGHT -->
			<div class="flex justify-between items-center bg-navy-900 px-2 py-0 rounded-lg shadow-md">
				<button id="hostCodeDisplay" onclick="copyHostCode()" class="hidden flex items-center gap-2 bg-navy-800 hover:bg-navy-700 border border-navy-600 px-3 py-1 rounded-full transition group">
					<div class="flex flex-col items-end leading-none">
						<span class="text-[9px] text-gray-400 uppercase" data-i18n="code">Code</span>
						<code id="dashboardHostId" class="text-sm font-mono text-white font-bold group-hover:text-neon transition">---</code>
					</div>
					<i class="fas fa-copy text-gray-500 group-hover:text-white text-xs"></i>
				</button>
			</div>
		</div>
	</header>

    <!-- Setup Screen -->
    <div id="setupScreen" class="flex-1 overflow-y-auto p-4">
        <div class="max-w-md mx-auto">
            <div class="text-center mb-4">
				<h1 class="text-2xl font-bold text-white tracking-widest">STRAT<span class="text-ice">EGER</span></h1>
                <p class="text-[10px] text-gray-500 mt-1" data-i18n="subtitle">Endurance Race Strategy Manager</p>
            </div>

            <!-- Role Selection -->
            <div class="grid grid-cols-2 gap-3 mb-4">
                <button onclick="selectRole('host')" id="hostBtn" class="bg-navy-800 border-2 border-navy-700 rounded-lg p-4 text-center hover:border-ice transition group">
                    <i class="fa-solid fa-server text-3xl text-gray-400 group-hover:text-ice mb-2"></i>
                    <p class="text-sm font-bold" data-i18n="host">Host</p>
                    <p class="text-[10px] text-gray-500" data-i18n="hostDesc">Manage the race</p>
                </button>
                <button onclick="selectRole('client')" id="clientBtn" class="bg-navy-800 border-2 border-navy-700 rounded-lg p-4 text-center hover:border-neon transition group">
                    <i class="fa-solid fa-mobile-screen text-3xl text-gray-400 group-hover:text-neon mb-2"></i>
                    <p class="text-sm font-bold" data-i18n="viewer">Viewer</p>
                    <p class="text-[10px] text-gray-500" data-i18n="viewerDesc">Watch live</p>
                </button>
            </div>
			<button id="loadStrategyBtn" onclick="loadStrategyLibrary()" 
					class="hidden w-full bg-navy-800 text-gray-300 text-sm py-2 rounded-lg mb-3 border border-gray-700 hover:border-ice">
				üìö <span data-i18n="loadStrategy">Load Saved Strategy</span>
			</button>

			<!-- Google Integration Section -->
			<div id="googleSection" class="mt-4 mb-6 p-3 bg-navy-800 rounded-lg border border-gray-700">
				<div class="flex items-center justify-between mb-2">
					<span class="text-sm font-bold text-white flex items-center gap-2">
						<img src="https://www.google.com/favicon.ico" class="w-4 h-4">
						<span data-i18n="googleConnect">Google Connect</span>
					</span>
					<span id="googleStatus" class="text-[10px] text-gray-500">Not connected</span>
				</div>
				
				<!-- Sign In Button -->
				<div id="googleSignInContainer" class="flex justify-center">
					<button onclick="googleSignIn()" class="google-btn">
						<img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
						<span data-i18n="signInGoogle">Sign in with Google</span>
					</button>
				</div>
				
				<!-- Signed In View -->
				<div id="googleSignedIn" class="hidden">
					<div class="flex items-center gap-3 mb-3">
						<img id="googleAvatar" src="" class="user-avatar">
						<div>
							<p id="googleName" class="text-sm font-bold text-white">User</p>
							<p id="googleEmail" class="text-[10px] text-gray-400">email@example.com</p>
						</div>
						<button onclick="googleSignOut()" class="ml-auto text-xs text-red-400 hover:text-red-300">
							<i class="fas fa-sign-out-alt"></i>
						</button>
					</div>
					
					<!-- Google Features -->
					<div class="grid grid-cols-2 gap-2">
						<button onclick="showTeamEmailModal()" class="bg-navy-900 border border-gray-600 rounded p-2 text-center hover:border-ice transition">
							<i class="fas fa-envelope text-ice mb-1"></i>
							<p class="text-[10px] text-gray-300" data-i18n="emailTeam">Email Team</p>
						</button>
						<button onclick="showCalendarModal()" class="bg-navy-900 border border-gray-600 rounded p-2 text-center hover:border-neon transition">
							<i class="fas fa-calendar-plus text-neon mb-1"></i>
							<p class="text-[10px] text-gray-300" data-i18n="addCalendar">Add to Calendar</p>
						</button>
						<button onclick="shareStrategyEmail()" class="bg-navy-900 border border-gray-600 rounded p-2 text-center hover:border-gold transition">
							<i class="fas fa-share text-gold mb-1"></i>
							<p class="text-[10px] text-gray-300" data-i18n="shareStrategy">Share Strategy</p>
						</button>
						<button onclick="checkTeamAvailability()" class="bg-navy-900 border border-gray-600 rounded p-2 text-center hover:border-purple-400 transition">
							<i class="fas fa-users text-purple-400 mb-1"></i>
							<p class="text-[10px] text-gray-300" data-i18n="checkAvailability">Check Availability</p>
						</button>
					</div>
				</div>
			</div>

            <!-- Host Section -->
            <div id="hostSection" class="hidden">
                <div class="bg-gradient-to-r from-ice/20 to-navy-800 p-3 rounded-lg border border-ice/50 mb-4">
                    <p class="text-xs text-gray-400 mb-1" data-i18n="yourCode">Your Code:</p>
                    <div class="flex items-center gap-2">
                        <span id="myHostId" class="text-2xl font-mono font-bold text-ice tracking-widest">---</span>
                        <button onclick="copyCode('myHostId')" class="text-gray-400 hover:text-white">üìã</button>
                    </div>
                    <p id="netStatusText" class="text-[10px] text-gray-500 mt-2"></p>
                    <button id="retryBtn" class="hidden text-xs bg-red-900 text-red-300 px-3 py-1 rounded mt-2" onclick="initHostPeer()" data-i18n="retry">Retry</button>
                </div>
                
                <button onclick="toggleConfigPanel(event)" class="w-full bg-navy-800 text-gray-300 text-sm py-2 rounded-lg mb-3 border border-gray-700 flex items-center justify-center gap-2">
                    <span data-i18n="raceSettings">‚öôÔ∏è Race Settings</span>
                    <span id="configArrow">‚ñº</span>
                </button>
            </div>
            
            <!-- Config Panel -->
            <div id="configPanel" class="space-y-3 hidden transition-opacity duration-300">
				<div class="bg-gradient-to-r from-red-900/30 to-navy-800 p-3 rounded-lg border border-red-500/50">
					<div class="flex items-center gap-2 mb-2">
						<span class="sync-dot live-dot"></span>
						<span class="text-sm font-bold text-white" data-i18n="liveTiming">Live Timing (Optional)</span>
					</div>
					<div class="space-y-2">
						<div>
							<label class="text-[10px] text-gray-400" data-i18n="liveTimingUrl">Live Timing URL (APEX/RaceFacer)</label>
							<input type="url" id="liveTimingUrl" placeholder="https://live.racefacer.com/... or https://apex-timing.com/..." 
								class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
						</div>
						
						<div>
							<label class="text-[10px] text-gray-400 mb-1 block" data-i18n="searchBy">Search by:</label>
							<div class="grid grid-cols-3 gap-1 mb-2">
								<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
									<input type="radio" name="searchType" value="team" checked class="hidden">
									<span class="text-[10px] text-gray-300">üèéÔ∏è <span data-i18n="team">Team</span></span>
								</label>
								<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
									<input type="radio" name="searchType" value="kart" class="hidden">
									<span class="text-[10px] text-gray-300">üî¢ <span data-i18n="kart">Kart</span></span>
								</label>
								<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
									<input type="radio" name="searchType" value="driver" class="hidden">
									<span class="text-[10px] text-gray-300">üë§ <span data-i18n="driver">Driver</span></span>
								</label>
							</div>
							<input type="text" id="searchValue" placeholder="Enter team name..." class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
						</div>
						
						<div class="flex gap-2">
							<button onclick="testLiveTiming()" class="flex-1 bg-red-900/50 border border-red-500/50 text-red-300 text-xs py-2 rounded hover:bg-red-900">üî¥ <span data-i18n="testConnection">Test</span></button>
							<button onclick="startDemoMode()" class="flex-1 bg-neon/20 border border-neon/50 text-neon text-xs py-2 rounded hover:bg-neon/30">üéÆ <span data-i18n="demo">Demo</span></button>
							<button onclick="openManualInput()" class="flex-1 bg-fuel/20 border border-fuel/50 text-fuel text-xs py-2 rounded hover:bg-fuel/30">‚úèÔ∏è <span data-i18n="manual">Manual</span></button>
						</div>
						<div id="liveTimingStatus" class="text-[10px] text-gray-500 text-center"></div>
					</div>
				</div>

				<div id="simResult" class="bg-navy-950 p-2 rounded text-xs text-ice border border-navy-700 font-mono text-center whitespace-pre-line">...</div>

				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="duration">Duration (hours)</label>
						<input type="number" id="raceDuration" value="12" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="reqStops">Required Stops</label>
						<input type="number" id="reqPitStops" value="13" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-neon font-bold text-sm">
					</div>
				</div>

				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="minStint">Min Stint (min)</label>
						<input type="number" id="minStint" value="10" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="maxStint">Max Stint (min)</label>
						<input type="number" id="maxStint" value="60" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="pitClosedStart">üö´ Pit Closed Start (min)</label>
						<input type="number" id="pitClosedStart" min="0" max="120" value="0" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="pitClosedEnd">üö´ Pit Closed End (min)</label>
						<input type="number" id="pitClosedEnd" min="0" max="120" value="0" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
				</div>
				
				<div class="bg-navy-800 p-2 rounded border border-gray-700">
					<p class="text-[10px] text-gray-400 text-center mb-1 font-bold" data-i18n="driverLimits">Driver Limits (0 = no limit)</p>
					<div class="grid grid-cols-2 gap-3">
						<div>
							<label class="text-[10px] text-gray-400" data-i18n="minDrive">Min Drive</label>
							<input type="number" id="minDriverTime" placeholder="0" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
						</div>
						<div>
							<label class="text-[10px] text-gray-400" data-i18n="maxDrive">Max Drive</label>
							<input type="number" id="maxDriverTime" placeholder="0" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
						</div>
					</div>
				</div>

				<div class="bg-navy-800 p-2 rounded border border-gray-700 mt-2">
					<p class="text-[10px] text-gray-400 text-center mb-1 font-bold" data-i18n="advancedSettings">Advanced Settings</p>
					
					<div class="grid grid-cols-2 gap-3">
						<div>
							<label class="text-[10px] text-gray-400" data-i18n="pitTime">Pit Time (sec)</label>
							<input type="number" id="minPitTime" value="120" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
						</div>
						<div>
							<label class="text-[10px] text-gray-400" data-i18n="releaseBuffer">Release Buffer (sec)</label>
							<input type="number" id="releaseBuffer" value="0" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-fuel text-sm">
						</div>
					</div>
					
					<div class="grid grid-cols-3 gap-2 border-t border-gray-700 pt-2 mt-2">
						<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
							<input type="checkbox" id="allowDouble" onchange="runSim()" class="w-4 h-4 accent-ice">
							<span class="text-[10px] text-gray-300" data-i18n="doubleStint">Double</span>
						</label>
						
						<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
							<input type="checkbox" id="trackFuel" onchange="toggleFuelInput()" class="w-4 h-4 accent-fuel">
							<span class="text-[10px] text-gray-300" data-i18n="fuel">Fuel</span>
						</label>
						
						<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
							<input type="checkbox" id="useSquads" onchange="toggleSquadsInput(); runSim()" class="w-4 h-4 accent-squadB">
							<span class="text-[10px] text-gray-300" data-i18n="squads">Squads</span>
						</label>
					</div>
					
					<div id="fuelInputDiv" class="hidden mt-2">
						<label class="text-[10px] text-fuel" data-i18n="fuelTankTime">Fuel Tank Time (min)</label>
						<input type="number" id="maxFuelTime" value="60" class="w-full bg-navy-950 border border-fuel/50 rounded p-2 text-white text-sm">
					</div>
				</div>

				<div class="pt-2">
					<div class="flex justify-between items-center mb-1">
						<label class="text-xs text-gray-400 font-bold" data-i18n="driversSetup">Drivers (mark starter)</label>
						<div class="space-x-1">
							<button onclick="addDriverField()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600">+</button>
							<button onclick="removeDriverField()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600">-</button>
						</div>
					</div>
					<div id="driversList" class="space-y-2 transition-all duration-300"></div>
				</div>
				
				<button onclick="callAIStrategy()" class="w-full mt-4 bg-gradient-to-r from-indigo-600 to-blue-500 hover:from-blue-500 hover:to-indigo-600 text-white font-bold py-3 rounded-lg shadow-lg border border-indigo-400/30">
					‚ú® Ask AI to Optimize
				</button>

				<button onclick="generatePreview(false, true)" 
						class="w-full mt-2 bg-gradient-to-r from-purple-600 to-fuchsia-500 hover:from-fuchsia-500 hover:to-purple-600 text-white font-bold py-4 rounded-lg shadow-[0_0_20px_rgba(168,85,247,0.4)] transition-all">
					<i class="fas fa-chart-gantt mr-2"></i>
					<span data-i18n="previewStrategy">Preview Strategy</span>
				</button>
				<button id="startRaceBtn" onclick="initRace()" class="w-full bg-ice hover:bg-cyan-300 text-navy-950 font-bold py-3 rounded-lg text-lg mt-2 shadow-[0_0_15px_rgba(34,211,238,0.3)] transition btn-press" data-i18n="startRace">
					Start Race (Host)
				</button>
			</div>

            <!-- Client Section -->
            <div id="clientSection" class="hidden">
                <div class="bg-gradient-to-r from-neon/20 to-navy-800 p-3 rounded-lg border border-neon/50">
                    <label class="text-xs text-gray-400" data-i18n="enterCode">Enter Host Code:</label>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="remoteIdInput" placeholder="1234567" class="flex-1 bg-navy-950 border border-gray-600 rounded p-2 text-white text-center text-lg font-mono tracking-widest">
                        <button onclick="connectToHost()" class="bg-neon text-navy-950 font-bold px-4 rounded hover:bg-lime-400 transition" data-i18n="connect">Connect</button>
                    </div>
					<p id="clientConnMsg" class="text-xs text-gray-500 mt-2"></p>
					<button id="disconnectBtn" onclick="disconnectClient()" class="hidden text-xs text-red-400 mt-2" data-i18n="disconnect">Disconnect</button>
                </div>
            </div>
        </div>
		<script>
		// Hide preview when dashboard is active
		function hidePreviewWhenDashboardActive() {
			const dashboard = document.getElementById('raceDashboard');
			const preview = document.getElementById('previewScreen');
			if (dashboard && preview) {
				const observer = new MutationObserver(() => {
					if (!dashboard.classList.contains('hidden')) {
						preview.classList.add('hidden');
					}
				});
				observer.observe(dashboard, { attributes: true, attributeFilter: ['class'] });
			}
		}
		window.addEventListener('DOMContentLoaded', hidePreviewWhenDashboardActive);
		</script>
    </div>
	<!-- Pre-Race Simulation Preview -->
	<div id="previewScreen" class="hidden flex-1 overflow-y-auto p-4">
		<div class="max-w-4xl mx-auto">
			<div class="simulation-preview">
				<div class="flex items-center justify-between mb-4">
					<h2 class="text-2xl font-bold text-ice">
						<i class="fas fa-chart-gantt mr-2"></i>
						<span data-i18n="racePreview">Race Strategy Preview</span>
					</h2>
					<button onclick="closePreview()" class="text-gray-400 hover:text-white">
						<i class="fas fa-times text-xl"></i>
					</button>
				</div>
				
				<!-- AI Strategy Assistant (Moved from Setup) -->
			<div class="bg-navy-900 p-4 rounded-lg border border-purple-500/30 shadow-lg mb-4">
				<h3 class="text-sm font-bold text-purple-400 mb-3 flex items-center gap-2">
					<span>ü§ñ</span>
					<span data-i18n="aiAssistant">AI Strategy Assistant</span>
				</h3>

				<!-- Weather Conditions -->
				<div class="mb-3">
					<label class="text-[10px] text-gray-400 mb-1 block data-i18n="expectedConditions">Expected Conditions:</label>
					<div class="grid grid-cols-3 gap-1">
						<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-yellow-400 has-[:checked]:bg-yellow-400/20">
							<input type="radio" name="weatherCondition" value="dry" checked class="hidden">
							<span class="text-[10px]">‚òÄÔ∏è Dry</span>
						</label>
						<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-blue-400 has-[:checked]:bg-blue-400/20">
							<input type="radio" name="weatherCondition" value="wet" class="hidden">
							<span class="text-[10px]">‚òÅÔ∏è Wet</span>
						</label>
						<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-orange-400 has-[:checked]:bg-orange-400/20">
							<input type="radio" name="weatherCondition" value="mixed" class="hidden">
							<span class="text-[10px]"><span data-i18n="mixed">üå§Ô∏è Mixed</span></span>
						</label>
					</div>
				</div>
				
				<div class="mb-3">
					<label class="text-[10px] text-gray-400 mb-1 block data-i18n="strategyInstructions">Strategy Instructions:</label>
					<textarea id="strategyInstructions" 
							placeholder="e.g., 'Focus double stints during night shifts for Squad A', 'Keep driver X fresh for final stints', 'Minimize pit stops in first 3 hours'..."
							class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-xs h-20 resize-none"></textarea>
				</div>
				
				<button onclick="generateAIStrategy()" 
						class="w-full bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 rounded flex items-center justify-center gap-2 transition">
					<span data-i18n="generateAi">ü§ñ Generate AI Strategy</span>
				</button>
				
				<div id="aiStrategyStatus" class="text-[10px] text-center mt-2 hidden"></div>
			</div>
			
			<!-- Race Start Time Configuration -->
				<div class="bg-navy-900 rounded-lg p-4 mb-4">
					<label class="block text-sm text-gray-400 mb-2">
						<i class="fas fa-clock mr-2"></i>
						<span data-i18n="raceStartTime">Race Start Time</span>
					</label>
					<div class="flex justify-between text-xs text-gray-400 mt-6">
						<span>Start: <span id="timelineStart">--:--</span></span>
						<span>End: <span id="timelineEnd">--:--</span></span>
					</div>
					<input type="time" id="raceStartTime" 
						   class="w-full bg-navy-800 border border-gray-700 rounded px-3 py-2 text-white"
						   onchange="updatePreview()">
				</div>
	
				
				<!-- Driver Breakdown -->
				<div class="bg-navy-900 rounded-lg p-4 mb-4">
					<h3 class="text-lg font-bold text-neon mb-3">
						<i class="fas fa-users mr-2"></i>
						<span data-i18n="driverSchedule">Driver Schedule</span>
					</h3>
					<div id="driverScheduleList" class="space-y-3"></div>
				</div>
				
				<!-- Strategy Summary -->
				<div class="bg-navy-900 rounded-lg p-4 mb-4">
					<h3 class="text-lg font-bold text-neon mb-3">
						<i class="fas fa-list-check mr-2"></i>
						<span data-i18n="strategySummary">Strategy Summary</span>
					</h3>
					<div id="strategySummary" class="grid grid-cols-2 gap-3"></div>
				</div>
				
				<!-- Action Buttons -->
				<div class="flex flex-col sm:flex-row gap-3 mb-0">
					<button onclick="editStrategy()" 
							class="w-full sm:flex-1 bg-navy-800 hover:bg-navy-700 text-white font-bold py-3 rounded-lg border border-gray-700">
						<i class="fas fa-edit mr-2"></i>
						<span data-i18n="editStrategy">Edit Strategy</span>
					</button>
					<button onclick="saveStrategy()" 
							class="w-full sm:flex-1 bg-gold/20 hover:bg-gold/30 text-gold font-bold py-3 rounded-lg border border-gold/50">
						<i class="fas fa-save mr-2"></i>
						<span data-i18n="saveStrategy">Save Strategy</span>
					</button>
					<button onclick="initRace()" 
							class="w-full sm:flex-1 bg-gradient-to-r from-neon to-green-400 hover:from-green-400 hover:to-neon text-black font-bold py-3 rounded-lg shadow-lg">
						<i class="fas fa-flag-checkered mr-2"></i>
						<span data-i18n="startRace">Start Race</span>
					</button>
				</div>
			</div>
		</div>
	</div>

    <!-- Race Dashboard -->
    <div id="raceDashboard" class="hidden flex flex-col h-full overflow-y-auto">
		<!-- Top Bar -->
		<div class="bg-navy-900 border-b border-gray-800 shrink-0">
			<div class="p-2 flex items-center justify-between gap-2">
				<!-- Weather Button - LEFT -->
				<button id="btnRain" onclick="toggleRain()" class="btn-press bg-navy-800 border border-blue-500/50 rounded-lg px-3 py-2 hover:bg-navy-700 shrink-0">
					<span id="rainIcon" class="text-base">‚òÄÔ∏è</span>
					<span id="rainText" class="text-[10px] font-bold text-yellow-400 block" data-i18n="dry">Dry</span>
				</button>
				
				<!-- Pit Stops - CENTER -->
				<div class="flex flex-col items-center">
					<p class="text-[10px] text-gray-500" data-i18n="pitStops">Pit Stops</p>
					<p id="pitCountDisplay" class="text-base font-bold">
						<span class="text-neon">0</span>
						<span class="text-gray-500">/</span>
						<span>0</span>
					</p>
				</div>
				
				<!-- Race Time - RIGHT -->
				<div class="flex flex-col items-center">
					<p class="text-[10px] text-gray-500" data-i18n="raceTime">Race Time</p>
					<p id="raceTimerDisplay" class="text-lg font-mono font-bold text-white big-digit">00:00:00</p>
				</div>
			</div>
		</div>

        <!-- Live Timing Panel (collapsible) -->
        <div id="liveTimingPanel" class="hidden bg-navy-900/80 border-b border-red-500/50 overflow-hidden transition-all duration-300 shrink-0" style="max-height: 350px;">
            <div class="p-2">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <span class="sync-dot live-dot"></span>
                        <span class="text-sm font-bold text-white">LIVE</span>
                    </div>
					<div class="flex items-center gap-1">
						<button onclick="openManualInput()" class="text-xs bg-fuel/30 border border-fuel/50 text-fuel px-2 py-1 rounded hover:bg-fuel/50" title="Manual Input">‚úèÔ∏è</button>
						<button onclick="refreshLiveTiming()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600" title="Refresh">üîÑ</button>
						<button onclick="toggleLiveTimingEmbed()" class="text-xs bg-red-900/50 px-2 py-1 rounded hover:bg-red-900" title="Embed">üñ•Ô∏è</button>
						<button onclick="stopLiveTiming()" 
								class="btn-press bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-xs">
							<i class="fas fa-stop"></i> 
							<span data-i18n="stopLiveTiming">Stop</span>
						</button>
					</div>
                </div>
                
                <!-- Quick Stats -->
                <div class="grid grid-cols-3 gap-2 mb-2">
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Pos</p>
                        <p id="livePosition" class="text-xl font-bold text-ice">-</p>
                        <p id="livePositionChange" class="text-[10px] position-same">‚Äî</p>
                    </div>
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Last</p>
                        <p id="liveLastLap" class="text-lg font-mono text-white">--</p>
                    </div>
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Best</p>
                        <p id="liveBestLap" class="text-lg font-mono text-neon">--</p>
                    </div>
                </div>
                
                <!-- Competitors Table -->
                <div id="competitorsTable" class="bg-navy-950 rounded border border-gray-700 p-1 max-h-[180px] overflow-y-auto text-[11px]">
                    <div class="text-gray-500 text-center py-2" data-i18n="waitingData">Waiting for data...</div>
                </div>
				
				<!-- Proxy Debug Info -->
				<div id="proxyDebug" class="hidden mt-2 p-2 bg-navy-950 rounded border border-gray-700 text-[10px] text-gray-500 max-h-20 overflow-y-auto">
					<p class="font-bold text-gray-400" data-i18n="proxyData">Proxy Data:</p>
					<pre id="proxyDataPreview" class="whitespace-pre-wrap break-all"></pre>
				</div>
            </div>
        </div>
		
		<!-- Live Timing Embed (iframe) -->
		<div id="liveTimingEmbed" class="hidden bg-navy-900 border-b border-gray-700">
			<div class="flex items-center justify-between p-1 bg-navy-800">
				<span class="text-[10px] text-gray-400" data-i18n="liveView">Live View</span>
				<button onclick="closeLiveTimingEmbed()" class="text-red-400 text-xs">‚úï</button>
			</div>
			<iframe id="liveTimingIframe" class="w-full h-64 border-0" src="about:blank"></iframe>
		</div>

        <!-- Strategy Box -->
        <div id="strategyBox" class="p-3 text-center border-b-2 border-neon flex flex-col items-center justify-center rounded-lg shadow-lg shrink-0 bg-navy-900">
            <p class="text-gray-400 text-xs mb-1" data-i18n="targetStint">Target Stint</p>
            <div class="flex items-baseline gap-2">
                <span id="strategyTargetStint" class="text-2xl font-bold text-white big-digit">--:--</span>
                <span id="strategyDelta" class="text-lg font-bold text-gray-400">--</span>
            </div>
            <p id="strategyAdvice" class="text-xs text-gray-400 mt-1" data-i18n="buildTime">Build Time</p>
        </div>

        <!-- Stint Timer -->
        <div class="p-3 bg-navy-950 border-b border-gray-800 shrink-0">
			<div class="grid grid-cols-2 gap-3 mb-2">
				<div class="flex flex-col items-center">
					<p class="text-gray-500 text-xs mb-1" data-i18n="stintTime">Stint Time</p>
					<p id="stintTimerDisplay" class="text-3xl font-mono font-bold text-white big-digit">00:00</p>
				</div>
				<div class="flex flex-col items-center">
					<p class="text-gray-500 text-xs mb-1" data-i18n="currentDriver">Current Driver</p>
					<p id="currentDriverName" class="text-xl font-bold text-ice">---</p>
				</div>
			</div>
			<div class="relative h-4 bg-navy-800 rounded-full overflow-hidden">
                <div id="zoneForbidden" class="absolute top-0 left-0 h-full zone-forbidden"></div>
                <div id="stintProgressBar" class="absolute top-0 left-0 h-full zone-optimal transition-all duration-500" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Pit Indicator for Viewer Mode -->
        <div id="viewerPitIndicator" class="hidden bg-fuel/20 border-b border-fuel/50 p-2 text-center shrink-0">
            <div class="flex items-center justify-center gap-2">
                <span class="text-fuel text-sm font-bold">üèÅ IN PIT</span>
                <span id="viewerPitTimer" class="text-fuel font-mono font-bold text-lg">--</span>
            </div>
            <p class="text-[10px] text-gray-400 mt-1">
                <span data-i18n="nextDriverIn">Next Driver:</span> 
                <span id="viewerNextDriver" class="text-white font-bold">---</span>
            </p>
        </div>
        
        <!-- Squad & Night Display -->
        <div id="activeSquadDisplay" class="hidden bg-navy-800 border-b border-gray-600 p-2 text-center shrink-0">
			<span class="text-xs text-gray-400" data-i18n="activeSquad">Active Squad:</span>
			<span id="activeSquadText" class="text-lg font-bold text-squadA ml-2">A</span>
		</div>
        
        <div id="sleepWidget" class="hidden bg-navy-800 border-b border-gray-700 p-2 text-center shrink-0">
            <p class="text-[10px] text-gray-500" data-i18n="resting">Resting:</p>
            <p id="sleepersList" class="text-xs text-gray-400">---</p>
        </div>

        <!-- Control Buttons -->
        <div class="p-2 shrink-0">
			<div class="grid grid-cols-2 gap-2" id="controlButtonsGrid">
				<button id="btnPush" onclick="setMode('push')" data-viewer-disabled="true" class="btn-press bg-navy-800 border border-green-900/50 rounded-lg p-3 hover:bg-navy-700">
					<span class="text-base">üî• <span data-i18n="push">Push</span></span>
				</button>
				<button id="btnBad" onclick="setMode('bad')" data-viewer-disabled="true" class="btn-press bg-navy-800 border border-red-900/50 rounded-lg p-3 hover:bg-navy-700">
					<span class="text-base">üê¢ <span data-i18n="problem">Problem</span></span>
				</button>
			</div>
			<button id="btnNight" onclick="toggleNightMode()" data-viewer-disabled="true" class="hidden w-full btn-press bg-navy-800 border border-purple-500/50 rounded-lg p-2 mt-2 hover:bg-navy-700 text-purple-300">
				<span class="text-base">üåô <span data-i18n="night">Night</span></span>
			</button>
			<button id="btnResetMode" onclick="setMode('normal')" data-viewer-disabled="true" class="hidden w-full btn-press bg-navy-800 border border-gray-600 rounded-lg p-2 mt-2">
				<span class="text-sm text-gray-400" data-i18n="resetMode">‚Ü©Ô∏è Reset Mode</span>
			</button>
		</div>

        <!-- Driver Stats -->
        <div class="flex-1 overflow-y-auto bg-navy-950 p-2">
            <table class="w-full text-sm">
                <thead class="text-gray-500 text-xs sticky top-0 bg-navy-950">
                    <tr>
                        <th class="p-1 w-8"></th>
                        <th class="text-right p-1" data-i18n="driverHeader">Driver</th>
                        <th class="text-center p-1" data-i18n="stintsHeader">St.</th>
                        <th class="text-left p-1" data-i18n="totalHeader">Total</th>
                    </tr>
                </thead>
                <tbody id="statsTable"></tbody>
            </table>
        </div>

        <!-- Pit Button & Next Driver -->
        <div class="bg-navy-900 border-t border-gray-800 p-2 shrink-0 space-y-2">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-2">
					<div>
						<p class="text-[10px] text-gray-500" data-i18n="nextDriver">Next Driver</p>
						<p id="nextDriverName" class="text-lg font-bold text-neon cursor-pointer hover:text-white" onclick="cycleNextDriver()" data-viewer-disabled="true">---</p>
					</div>
					<button onclick="cycleNextDriver()" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600" title="Change next driver">üîÑ</button>
                </div>
                <div class="flex gap-2">
                    <button onclick="adjustStint(-60000)" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded">-1m</button>
					<button onclick="adjustStint(60000)" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded">+1m</button>
                </div>
            </div>
            <button id="pitEntryBtn" onclick="confirmPitEntry()" data-viewer-disabled="true" class="w-full bg-danger hover:bg-red-600 text-white font-bold py-4 rounded-lg text-xl shadow-[0_0_15px_rgba(239,68,68,0.3)] transition btn-press" data-i18n="enterPit">
                üèÅ Enter Pit
            </button>
        </div>
    </div>

    <!-- Pit Modal -->
    <div id="pitModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <h2 class="text-ice text-2xl font-bold mb-2 tracking-widest border-b border-ice pb-1" data-i18n="inPit">IN PIT</h2>
		<p class="text-gray-400 text-sm mb-4"><span data-i18n="nextDriverIn">Next Driver:</span> <span id="modalNextDriverName" class="text-white font-bold">---</span></p>

        <div id="pitPhase2" class="w-full max-w-sm flex flex-col items-center">
            <div id="fuelToggleContainer" class="hidden mb-4 bg-navy-800 p-3 rounded border border-fuel/50 w-full">
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm font-bold text-gray-300" data-i18n="refuel">Kart Change / Refuel?</span>
                    <input type="checkbox" id="isRefuelCheck" checked class="w-6 h-6 accent-fuel">
                </label>
            </div>
            
            <div class="relative w-48 h-48 flex items-center justify-center border-4 border-gray-700 rounded-full mb-4 bg-navy-900">
                <span id="pitTimerDisplay" class="text-5xl font-bold big-digit text-white font-mono">00</span>
            </div>
            
            <button id="notifyBtn" class="hidden w-full bg-fuel text-black font-bold py-3 rounded-lg text-lg mb-2">
                üì¢ <span data-i18n="notifyDriver">Notify Driver</span>
            </button>
            <div id="notifiedMsg" class="hidden text-fuel text-sm mb-2 font-bold">‚úì <span data-i18n="notified">Notified - Waiting for line cross</span></div>
            
            <button id="confirmExitBtn" disabled class="w-full bg-gray-800 text-gray-600 font-bold py-4 rounded-lg text-xl border border-gray-700 mb-4" data-i18n="wait">
                Wait...
            </button>
            
            <button onclick="cancelPitStop()" class="text-red-400 py-2 text-sm">‚ùå <span data-i18n="cancelPit">Cancel Pit Entry</span></button>
        </div>
    </div>

	<!-- Saved Race Modal -->
	<div id="savedRaceModal" class="hidden fixed inset-0 bg-navy-950/98 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-md">
		<div class="bg-gradient-to-br from-navy-900 to-navy-950 p-6 rounded-2xl border-2 border-ice shadow-[0_0_40px_rgba(34,211,238,0.3)] w-full max-w-md">
			<div class="text-center mb-6">
				<div class="w-16 h-16 bg-ice/20 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
					<i class="fas fa-flag-checkered text-3xl text-ice"></i>
				</div>
				<h2 class="text-2xl font-bold text-ice mb-2" data-i18n="activeRaceFound">Active Race Found!</h2>
				<p class="text-gray-400 text-sm" data-i18n="raceInProgress">A race is currently in progress</p>
			</div>
			
			<div class="bg-navy-950 rounded-lg p-4 mb-6 border border-gray-700">
				<div class="space-y-3">
					<div class="flex items-center justify-between">
						<span class="text-gray-400 text-sm flex items-center gap-2">
							<i class="fas fa-user text-ice"></i>
							<span data-i18n="currentDriver">Current Driver</span>
						</span>
						<span id="savedRaceDriver" class="text-white font-bold text-lg">---</span>
					</div>
					<div class="flex items-center justify-between">
						<span class="text-gray-400 text-sm flex items-center gap-2">
							<i class="fas fa-clock text-neon"></i>
							<span data-i18n="timeRemaining">Time Remaining</span>
						</span>
						<span id="savedRaceTime" class="text-neon font-bold text-lg font-mono">--:--:--</span>
					</div>
					<div class="flex items-center justify-between">
						<span class="text-gray-400 text-sm flex items-center gap-2">
							<i class="fas fa-stop text-fuel"></i>
							<span data-i18n="pitStops">Pit Stops</span>
						</span>
						<span id="savedRacePits" class="text-white font-bold">
							<span class="text-neon">0</span> / <span>0</span>
						</span>
					</div>
				</div>
			</div>
			
			<div class="space-y-3">
				<button onclick="continueRace()" 
						class="w-full bg-gradient-to-r from-ice to-cyan-400 hover:from-cyan-400 hover:to-ice text-navy-950 font-bold py-4 rounded-lg text-lg shadow-lg transition-all transform hover:scale-105">
					<i class="fas fa-play mr-2"></i>
					<span data-i18n="continueRace">Continue Race</span>
				</button>
				<button onclick="confirmDiscardRace()" 
						class="w-full bg-navy-800 hover:bg-navy-700 text-gray-300 font-bold py-3 rounded-lg border border-gray-600 transition-all">
					<i class="fas fa-times mr-2"></i>
					<span data-i18n="discardRace">Discard & Start New</span>
				</button>
			</div>
			
			<p class="text-xs text-gray-500 text-center mt-4">
				<i class="fas fa-exclamation-triangle text-yellow-500 mr-1"></i>
				<span data-i18n="raceWarning">Discarding will permanently delete this race data</span>
			</p>
		</div>
	</div>

	<!-- Confirm Discard Modal -->
	<div id="confirmDiscardModal" class="hidden fixed inset-0 bg-navy-950/98 z-[60] flex flex-col items-center justify-center p-4 backdrop-blur-md">
		<div class="bg-navy-900 p-6 rounded-xl border-2 border-red-500 shadow-[0_0_40px_rgba(239,68,68,0.3)] w-full max-w-sm">
			<div class="text-center mb-6">
				<div class="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
					<i class="fas fa-exclamation-triangle text-3xl text-red-500"></i>
				</div>
				<h3 class="text-xl font-bold text-white mb-2" data-i18n="confirmDiscard">Are You Sure?</h3>
				<p class="text-gray-400 text-sm" data-i18n="confirmDiscardMessage">This will permanently delete the active race. This action cannot be undone.</p>
			</div>
			<div class="space-y-3">
				<button onclick="finalDiscardRace()" 
						class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition-all">
					<i class="fas fa-trash mr-2"></i>
					<span data-i18n="yesDiscard">Yes, Discard Race</span>
				</button>
				<button onclick="cancelDiscard()" 
						class="w-full bg-navy-800 hover:bg-navy-700 text-gray-300 font-bold py-3 rounded-lg border border-gray-600 transition-all">
					<i class="fas fa-arrow-left mr-2"></i>
					<span data-i18n="noKeepRace">No, Keep Race</span>
				</button>
			</div>
		</div>
	</div>

	<div id="saveStrategyModal" class="hidden fixed inset-0 bg-black/90 backdrop-blur-sm z-[60] flex items-center justify-center p-4 animate-fade-in">
		<div class="bg-navy-900 border border-navy-600 rounded-xl shadow-2xl w-full max-w-md overflow-hidden transform transition-all scale-100">
			
			<div class="bg-navy-950 p-4 border-b border-navy-700 flex justify-between items-center">
				<h3 class="text-xl font-bold text-white flex items-center gap-2">
					<i class="fas fa-save text-neon"></i> ◊©◊û◊ô◊®◊™ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î
				</h3>
				<button onclick="closeSaveStrategyModal()" class="text-gray-400 hover:text-white transition">
					<i class="fas fa-times text-lg"></i>
				</button>
			</div>

			<div class="p-6 space-y-6">
				
				<div>
					<label class="block text-xs text-gray-400 uppercase font-bold mb-2">◊©◊ù ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î</label>
					<input type="text" id="saveStrategyName" class="w-full bg-navy-800 border border-navy-600 rounded-lg p-3 text-white placeholder-gray-500 focus:outline-none focus:border-neon focus:ring-1 focus:ring-neon transition" placeholder="◊ú◊ì◊ï◊í◊û◊î: ◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊û◊î◊ô◊®◊î ◊ú◊ß◊ô◊•...">
				</div>

				<div>
					<label class="block text-xs text-gray-400 uppercase font-bold mb-3">◊û◊ô ◊ô◊õ◊ï◊ú ◊ú◊®◊ê◊ï◊™ ◊ê◊™ ◊ñ◊î?</label>
					<div class="grid grid-cols-2 gap-3">
						<label class="cursor-pointer relative">
							<input type="radio" name="strategyVisibility" value="private" class="peer sr-only" checked>
							<div class="bg-navy-800 border border-navy-600 rounded-lg p-3 text-center hover:bg-navy-750 peer-checked:border-neon peer-checked:bg-navy-800/50 transition h-full flex flex-col justify-center items-center gap-2">
								<i class="fas fa-lock text-xl text-gray-400 peer-checked:text-neon"></i>
								<span class="text-sm font-bold text-gray-300 peer-checked:text-white">◊§◊®◊ò◊ô</span>
								<span class="text-[9px] text-gray-500">◊®◊ß ◊ë◊û◊õ◊©◊ô◊® ◊î◊ñ◊î</span>
							</div>
						</label>

						<label class="cursor-pointer relative">
							<input type="radio" name="strategyVisibility" value="public" class="peer sr-only">
							<div class="bg-navy-800 border border-navy-600 rounded-lg p-3 text-center hover:bg-navy-750 peer-checked:border-gold peer-checked:bg-navy-800/50 transition h-full flex flex-col justify-center items-center gap-2">
								<i class="fas fa-globe text-xl text-gray-400 peer-checked:text-gold"></i>
								<span class="text-sm font-bold text-gray-300 peer-checked:text-white">◊¶◊ô◊ë◊ï◊®◊ô</span>
								<span class="text-[9px] text-gray-500">◊õ◊ï◊ú◊ù ◊®◊ï◊ê◊ô◊ù</span>
							</div>
						</label>
					</div>
				</div>

			</div>

			<div class="bg-navy-950 p-4 border-t border-navy-700 flex gap-3">
				<button onclick="closeSaveStrategyModal()" class="flex-1 py-3 rounded-lg border border-navy-600 text-gray-400 hover:bg-navy-800 transition font-bold text-sm">◊ë◊ô◊ò◊ï◊ú</button>
				<button onclick="performStrategySave()" class="flex-1 py-3 rounded-lg bg-neon text-black font-bold hover:bg-cyan-400 transition shadow-[0_0_15px_rgba(34,211,238,0.3)] text-sm flex items-center justify-center gap-2">
					<i class="fas fa-check"></i> ◊©◊û◊ï◊® ◊õ◊¢◊™
				</button>
			</div>
		</div>
	</div>
	
	<!-- Manual Input Modal -->
	<div id="manualInputModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
		<div class="bg-navy-900 p-4 rounded-lg border border-gray-700 w-full max-w-sm">
			<h3 class="text-ice text-lg font-bold mb-4 text-center" data-i18n="manualInput">Manual Input</h3>
			
			<div class="space-y-3">
				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="position">Position</label>
						<input type="number" id="manualPosition" placeholder="1" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="laps">Laps</label>
						<input type="number" id="manualLaps" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
				</div>
				
				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="lastLap">Last Lap</label>
						<input type="text" id="manualLastLap" placeholder="1:02.345" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="bestLap">Best Lap</label>
						<input type="text" id="manualBestLap" placeholder="1:01.234" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
					</div>
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="gap">Gap to Leader</label>
					<input type="text" id="manualGap" placeholder="+1:23.456 or +2 laps" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
				</div>
				
				<div class="flex items-center gap-2 bg-navy-800 p-2 rounded">
					<input type="checkbox" id="manualInPit" class="w-4 h-4 accent-fuel">
					<label class="text-sm text-gray-300" data-i18n="inPitNow">Currently in Pit</label>
				</div>
			</div>
			
			<div class="flex gap-2 mt-4">
				<button onclick="applyManualInput()" class="flex-1 bg-ice text-navy-950 font-bold py-2 rounded-lg" data-i18n="apply">Apply</button>
				<button onclick="closeManualInput()" class="flex-1 bg-navy-700 text-gray-300 py-2 rounded-lg" data-i18n="cancel">Cancel</button>
			</div>
		</div>
	</div>
	<!-- Strategy Library Modal -->
	<div id="strategyModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
		<div class="bg-navy-900 rounded-lg border border-gray-700 w-full max-w-lg max-h-[80vh] flex flex-col">
			<div class="flex items-center justify-between p-4 border-b border-gray-700">
				<h3 class="text-ice text-lg font-bold">üìö Saved Strategies</h3>
				<button onclick="closeStrategyModal()" class="text-gray-400 hover:text-white text-xl">&times;</button>
			</div>
			<div id="strategyList" class="flex-1 overflow-y-auto p-4 space-y-2">
				<p class="text-gray-500 text-center">Loading...</p>
			</div>
		</div>
	</div>

    <script>
        // ==================== GLOBALS ====================
        let peer = null, conn = null, connections = [], myId = null, role = null;
        let config = {}; 
        let state = { 
            isRunning: false, 
            mode: 'normal', 
			trackCondition: 'dry',
            isRain: false, 
            currentDriverIdx: 0, 
            pitCount: 0, 
            startTime: 0, 
            stintStart: 0, 
            pitStart: 0, 
            isInPit: false, 
            fuelStart: 0, 
            stintOffset: 0, 
            activeSquad: 'A', 
            nextDriverIdx: 0, 
            targetStintMs: 0, 
            squadsActive: false,
            pendingPitEntry: false
        };
        let drivers = []; 
		let savedHostConfig = null;
		let savedConfigPanelState = null;
        let raceInterval, pitInterval, liveTimingInterval;
        let connectionRetries = 0;
        const MAX_RETRIES = 3;
		const RACE_STATE_KEY = 'strateger_race_state';
		let liveTimingManager = null;
		let proxyFetchInterval = null;
		let syncedTimes = null;
        
        // Live Timing State
        let liveTimingConfig = {
            url: '',
            teamName: '',
            enabled: false,
            demoMode: false
        };
		
		// Search configuration
		let searchConfig = {
			teamName: '',
			driverName: '',
			kartNumber: ''
		};
        
        let liveData = {
            position: null,
            previousPosition: null,
            lastLap: null,
            bestLap: null,
            laps: null,
            gapToLeader: null,
            competitors: []
        };
        
        // Demo mode state
        let demoState = {
            competitors: [],
            updateInterval: null
        };

		let aiStrategyConfig = {
			weatherCondition: 'dry',
			instructions: '',
			starterDriverIdx: 0,
			useAI: false
		};

		// Strategy preferences based on conditions
		const strategyPreferences = {
			dry: {
				stintPenalty: 0,
				description: 'Standard strategy - maximize stint length'
			},
			wet: {
				stintPenalty: 120000, // 2 minutes shorter stints in wet
				description: 'Wet conditions - shorter, safer stints'
			},
			mixed: {
				stintPenalty: 60000, // 1 minute shorter in mixed
				description: 'Mixed conditions - flexible strategy'
			}
		};
		
		// ==================== I18N ====================
		let currentLang = 'en';
		
		const translations = {
			en: {
				offline: 'Offline',
				subtitle: 'Endurance Race Strategy Manager',
				host: 'Host',
				hostDesc: 'Manage the race',
				viewer: 'Viewer',
				viewerDesc: 'Watch live',
				yourCode: 'Your Code:',
				retry: 'Retry',
				raceSettings: '‚öôÔ∏è Race Settings',
				liveTiming: 'Live Timing (Optional)',
				liveTimingUrl: 'Live Timing URL (APEX/RaceFacer)',
				searchBy: 'Search by:',
				team: 'Team',
				kart: 'Kart',
				driver: 'Driver',
				testConnection: 'Test',
				demo: 'Demo',
				manual: 'Manual',
				duration: 'Duration (hours)',
				reqStops: 'Required Stops',
				minStint: 'Min Stint (min)',
				maxStint: 'Max Stint (min)',
				driverLimits: 'Driver Limits (0 = no limit)',
				minDrive: 'Min Drive',
				maxDrive: 'Max Drive',
				pitTime: 'Pit Time (sec)',
				releaseBuffer: 'Release Buffer (sec)',
				doubleStint: 'Double',
				fuel: 'Fuel',
				squads: 'Squads',
				fuelTankTime: 'Fuel Tank Time (min)',
				driversSetup: 'Drivers (mark starter)',
				startRace: 'Start Race (Host)',
				enterCode: 'Enter Host Code:',
				connect: 'Connect',
				disconnect: 'Disconnect',
				code: 'Code:',
				synced: 'Synced',
				simResultPattern: "‚úÖ {stints} stints √ó ~{avg}min = {totalDrive}min drive\nüèÅ Pit stops: {stops} √ó {pitTime}s = {totalPit}min\n{note}",
				stdStrategy: "Standard strategy - maximize stint length",
				shortStrategy: "Short strategy - minimize stops",
				longStrategy: "Long strategy - save fuel/tires",
				aiStrategyPrefix: "ü§ñ AI Plan: ",
				raceTime: 'Race Time',
				pitStops: 'Pit Stops',
				dry: 'Dry',
				wet: 'Wet',
				drying: 'Drying',
				targetStint: 'Target Stint',
				buildTime: 'Build Time',
				stintTime: 'Stint Time',
				currentDriver: 'Current Driver',
				activeSquad: 'Active Squad:',
				resting: 'Resting:',
				push: 'Push',
				problem: 'Problem',
				night: 'Night',
				resetMode: '‚Ü©Ô∏è Reset Mode',
				driverHeader: 'Driver',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Next Driver',
				enterPit: 'üèÅ Enter Pit',
				inPit: 'IN PIT',
				nextDriverIn: 'Next Driver:',
				refuel: 'Kart Change / Refuel?',
				notifyDriver: 'Notify Driver',
				notified: 'Notified - Waiting for line cross',
				wait: 'Wait...',
				cancelPit: 'Cancel Pit Entry',
				manualInput: 'Manual Input',
				position: 'Position',
				laps: 'Laps',
				lastLap: 'Last Lap',
				bestLap: 'Best Lap',
				gap: 'Gap to Leader',
				inPitNow: 'Currently in Pit',
				apply: 'Apply',
				cancel: 'Cancel',
				waitingData: 'Waiting for data...',
				proxyData: 'Proxy Data:',
				liveView: 'Live View',
				connecting: 'Connecting...',
				connected: 'Connected',
				waitingRace: 'Connected! Waiting for race...',
				disconnected: 'Disconnected',
				enterUrl: '‚ùå Enter URL',
				enterValue: '‚ùå Enter',
				testing: 'üîÑ Testing...',
				found: '‚úÖ Found! Position:',
				notFound: '‚ö†Ô∏è Not found - check details or use iframe',
				error: '‚ùå Error:',
				confirmEarlyPit: 'Window closed! Enter anyway?',
				confirmExit: '‚úÖ Confirm Line Cross',
				timeExceeded: 'üö® Time Exceeded!',
				problemQuick: 'üê¢ Problem - Quick Entry!',
				pushExtend: 'üî• Extending! Build time',
				nearLimit: '‚ö†Ô∏è Near limit!',
				targetWindow: '‚úÖ Target Window',
				overExtend: 'üì• Over Extended',
				nightActive: 'üåô Night Active',
				pushActive: 'üî• Push Active',
				problemActive: 'üê¢ Problem Active',
				teamNotFound: 'Team not found',
				connectionIssues: 'Connection issues',
				usingIframe: 'Using iframe',
				connectionFailed: 'Connection failed',
				stopped: 'Stopped',
				racePreview: 'Race Strategy Preview',
				raceStartTime: 'Race Start Time',
				driverSchedule: 'Driver Schedule',
				strategySummary: 'Strategy Summary',
				editStrategy: 'Back to Setup',
				saveStrategy: 'Save Strategy',
				previewStrategy: 'Preview Strategy',
				stopLiveTiming: 'Stop',
				activeRaceFound: 'Active Race Found!',
				raceInProgress: 'A race is currently in progress',
				timeRemaining: 'Time Remaining',
				continueRace: 'Continue Race',
				discardRace: 'Discard & Start New',
				raceWarning: 'Discarding will permanently delete this race data',
				confirmDiscard: 'Are You Sure?',
				confirmDiscardMessage: 'This will permanently delete the active race. This action cannot be undone.',
				yesDiscard: 'Yes, Discard Race',
				noKeepRace: 'No, Keep Race',
				loadStrategy: 'Load Saved Strategy',
				savedStrategies: 'üìö Saved Strategies',
				noSavedStrategies: 'No saved strategies yet',
				strategyName: 'Strategy Name:',
				strategySaved: '‚úÖ Strategy saved:',
				aiAssistant: 'ü§ñ AI Strategy Assistant',
				expectedConditions: 'Expected Conditions:',
				mixed: 'Mixed',
				strategyInstructions: 'Strategy Instructions:',
				aiPlaceholder: "e.g., 'Focus double stints during night for Squad A', 'Keep driver X fresh for final stints'...",
				generateAi: 'ü§ñ Generate AI Strategy',
				analyzing: 'ü§ñ Analyzing strategy...',
				aiApplied: '‚úÖ AI strategy applied!',
				aiError: '‚ùå Error generating strategy',
				pitClosedStart: 'üö´ Pit Closed Start (min)',
				pitClosedEnd: 'üö´ Pit Closed End (min)',
				finish: 'Finish',
				raceFinished: 'üèÅ Race Finished!',
				savedToDb: '‚úÖ Strategy saved to database',
				safetyWarning: '‚ö†Ô∏è Safety Warning',
				googleConnect: 'Google Connect',
				signInGoogle: 'Sign in with Google',
				emailTeam: 'Email Team',
				addCalendar: 'Add to Calendar',
				shareStrategy: 'Share Strategy',
				checkAvailability: 'Check Availability',
				recipients: 'Recipients (comma separated)',
				emailSubject: 'Subject',
				message: 'Message',
				attachStrategy: 'Attach current strategy',
				sendEmail: 'Send Email',
				addToCalendar: 'Add to Google Calendar',
				eventTitle: 'Event Title',
				startDate: 'Start Date',
				startTime: 'Start Time',
				location: 'Location',
				inviteDrivers: 'Invite Drivers (emails)',
				addReminder: 'Add reminder (1 day before)',
				createEvent: 'Create Event',
			},
			he: {
				offline: '◊ú◊ê ◊û◊ó◊ï◊ë◊®',
				subtitle: '◊û◊†◊î◊ú ◊ê◊°◊ò◊®◊ò◊í◊ô◊ô◊™ ◊û◊ô◊®◊ï◊¶◊ô ◊°◊ô◊ë◊ï◊ú◊™',
				host: '◊û◊ê◊®◊ó',
				hostDesc: '◊†◊î◊ú ◊ê◊™ ◊î◊û◊ô◊®◊ï◊•',
				viewer: '◊¶◊ï◊§◊î',
				viewerDesc: '◊¶◊§◊î ◊ë◊©◊ô◊ì◊ï◊® ◊ó◊ô',
				yourCode: '◊î◊ß◊ï◊ì ◊©◊ú◊ö:',
				retry: '◊†◊°◊î ◊©◊ï◊ë',
				raceSettings: '‚öôÔ∏è ◊î◊í◊ì◊®◊ï◊™ ◊û◊ô◊®◊ï◊•',
				liveTiming: 'Live Timing (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô)',
				liveTimingUrl: '◊ß◊ô◊©◊ï◊® Live Timing (APEX/RaceFacer)',
				searchBy: '◊ó◊§◊© ◊ú◊§◊ô:',
				team: '◊ß◊ë◊ï◊¶◊î',
				kart: '◊ß◊ê◊®◊ò',
				driver: '◊†◊î◊í',
				testConnection: '◊ë◊ì◊ï◊ß',
				demo: '◊ì◊û◊ï',
				manual: '◊ô◊ì◊†◊ô',
				duration: '◊û◊©◊ö (◊©◊¢◊ï◊™)',
				reqStops: '◊¢◊¶◊ô◊®◊ï◊™ ◊ó◊ï◊ë◊î',
				minStint: '◊û◊ô◊†\' ◊°◊ò◊ô◊†◊ò (◊ì◊ß\')',
				maxStint: '◊û◊ß◊°\' ◊°◊ò◊ô◊†◊ò (◊ì◊ß\')',
				driverLimits: '◊í◊ë◊ï◊ú◊ï◊™ ◊†◊î◊í (0 = ◊ú◊ú◊ê ◊î◊í◊ë◊ú◊î)',
				minDrive: '◊û◊ô◊†◊ô◊û◊ï◊ù ◊†◊î◊ô◊í◊î',
				maxDrive: '◊û◊ß◊°◊ô◊û◊ï◊ù ◊†◊î◊ô◊í◊î',
				pitTime: '◊ñ◊û◊ü ◊§◊ô◊ò◊° (◊©◊†◊ô◊ï◊™)',
				releaseBuffer: '◊î◊ß◊ì◊û◊™ ◊î◊™◊®◊ê◊î (◊©◊†\')',
				doubleStint: '◊ì◊ê◊ë◊ú',
				fuel: '◊ì◊ú◊ß',
				squads: '◊ó◊ï◊ú◊ô◊ï◊™',
				fuelTankTime: '◊ñ◊û◊ü ◊û◊ô◊õ◊ú ◊ì◊ú◊ß (◊ì◊ß\')',
				driversSetup: '◊î◊í◊ì◊®◊™ ◊†◊î◊í◊ô◊ù (◊°◊û◊ü ◊û◊ñ◊†◊ß)',
				startRace: '◊î◊™◊ó◊ú ◊û◊®◊ï◊• (◊û◊†◊î◊ú)',
				enterCode: '◊î◊õ◊†◊° ◊ß◊ï◊ì ◊û◊ê◊®◊ó:',
				connect: '◊î◊™◊ó◊ë◊®',
				disconnect: '◊î◊™◊†◊™◊ß',
				code: '◊ß◊ï◊ì:',
				synced: '◊û◊°◊ï◊†◊õ◊®◊ü',
				simResultPattern: "‚úÖ {stints} ◊°◊ò◊ô◊†◊ò◊ô◊ù √ó ~{avg} ◊ì◊ß' = {totalDrive} ◊ì◊ß' ◊†◊î◊ô◊í◊î\nüèÅ ◊¢◊¶◊ô◊®◊ï◊™ ◊§◊ô◊ò: {stops} √ó {pitTime} ◊©◊†◊ô◊ï◊™ = {totalPit} ◊ì◊ß'\n{note}",
				stdStrategy: "◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊°◊ò◊†◊ì◊®◊ò◊ô◊™ - ◊û◊ß◊°◊ï◊ù ◊ê◊ï◊®◊ö ◊°◊ò◊ô◊†◊ò",
				shortStrategy: "◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊ß◊¶◊®◊î - ◊û◊ô◊†◊ô◊û◊ï◊ù ◊¢◊¶◊ô◊®◊ï◊™",
				longStrategy: "◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊ê◊®◊ï◊õ◊î - ◊ó◊ô◊°◊õ◊ï◊ü ◊ë◊ì◊ú◊ß/◊¶◊û◊ô◊í◊ô◊ù",
				aiStrategyPrefix: "ü§ñ ◊™◊ï◊õ◊†◊ô◊™ AI: ",
				raceTime: '◊ñ◊û◊ü ◊û◊ô◊®◊ï◊•',
				pitStops: '◊¢◊¶◊ô◊®◊ï◊™ ◊§◊ô◊ò◊°',
				dry: '◊ô◊ë◊©',
				wet: '◊í◊©◊ù',
				drying: '◊û◊™◊ô◊ô◊ë◊©',
				targetStint: '◊ô◊¢◊ì ◊°◊ò◊ô◊†◊ò ◊†◊ï◊õ◊ó◊ô',
				buildTime: '◊¶◊ë◊ï◊® ◊ñ◊û◊ü',
				stintTime: '◊ñ◊û◊ü ◊°◊ò◊ô◊†◊ò',
				currentDriver: '◊†◊î◊í ◊†◊ï◊õ◊ó◊ô',
				activeSquad: '◊ó◊ï◊ú◊ô◊î ◊§◊¢◊ô◊ú◊î:',
				resting: '◊†◊ó◊ô◊ù:',
				push: '◊ß◊¶◊ë',
				problem: '◊™◊ß◊ú◊î',
				night: '◊ú◊ô◊ú◊î',
				resetMode: '‚Ü©Ô∏è ◊ê◊ô◊§◊ï◊° ◊û◊¶◊ë',
				driverHeader: '◊†◊î◊í',
				stintsHeader: '◊°◊ò\'',
				totalHeader: '◊°◊î"◊õ',
				nextDriver: '◊†◊î◊í ◊î◊ë◊ê',
				enterPit: 'üèÅ ◊õ◊†◊ô◊°◊î ◊ú◊§◊ô◊ò◊°',
				inPit: '◊ë◊§◊ô◊ò◊°',
				nextDriverIn: '◊†◊î◊í ◊†◊õ◊†◊°:',
				refuel: '◊î◊ï◊ó◊ú◊£ ◊ß◊ê◊®◊ò / ◊™◊ì◊ú◊ï◊ß?',
				notifyDriver: '◊î◊ï◊ì◊¢ ◊ú◊†◊î◊í ◊ú◊î◊™◊õ◊ï◊†◊ü',
				notified: '◊î◊ï◊ì◊¢◊î ◊†◊©◊ú◊ó◊î - ◊û◊û◊™◊ô◊ü ◊ú◊ó◊¶◊ô◊ô◊™ ◊ß◊ï',
				wait: '◊î◊û◊™◊ü...',
				cancelPit: '◊ë◊ò◊ú ◊õ◊†◊ô◊°◊î ◊ú◊§◊ô◊ò◊°',
				manualInput: '◊î◊ñ◊†◊î ◊ô◊ì◊†◊ô◊™',
				position: '◊û◊ô◊ß◊ï◊ù',
				laps: '◊î◊ß◊§◊ï◊™',
				lastLap: '◊î◊ß◊§◊î ◊ê◊ó◊®◊ï◊†◊î',
				bestLap: '◊î◊ß◊§◊î ◊î◊ò◊ï◊ë◊î',
				gap: '◊§◊¢◊® ◊û◊û◊ï◊ë◊ô◊ú',
				inPitNow: '◊õ◊®◊í◊¢ ◊ë◊§◊ô◊ò◊°',
				apply: '◊î◊ó◊ú',
				cancel: '◊ë◊ô◊ò◊ï◊ú',
				waitingData: '◊û◊û◊™◊ô◊ü ◊ú◊†◊™◊ï◊†◊ô◊ù...',
				proxyData: '◊†◊™◊ï◊†◊ô ◊§◊®◊ï◊ß◊°◊ô:',
				liveView: '◊™◊¶◊ï◊í◊î ◊ó◊ô◊î',
				connecting: '◊û◊™◊ó◊ë◊®...',
				connected: '◊û◊ó◊ï◊ë◊®',
				waitingRace: '◊û◊ó◊ï◊ë◊®! ◊û◊û◊™◊ô◊ü ◊ú◊™◊ó◊ô◊ú◊™ ◊û◊®◊ï◊•...',
				disconnected: '◊†◊ï◊™◊ß ◊û◊î◊û◊ê◊®◊ó',
				enterUrl: '‚ùå ◊î◊õ◊†◊° ◊ß◊ô◊©◊ï◊®',
				enterValue: '‚ùå ◊î◊õ◊†◊°',
				testing: 'üîÑ ◊ë◊ï◊ì◊ß...',
				found: '‚úÖ ◊†◊û◊¶◊ê! ◊û◊ô◊ß◊ï◊ù:',
				notFound: '‚ö†Ô∏è ◊ú◊ê ◊†◊û◊¶◊ê - ◊ë◊ì◊ï◊ß ◊ê◊™ ◊î◊§◊®◊ò◊ô◊ù ◊ê◊ï ◊î◊©◊™◊û◊© ◊ë-iframe',
				error: '‚ùå ◊©◊í◊ô◊ê◊î:',
				confirmEarlyPit: '◊ó◊ú◊ï◊ü ◊°◊í◊ï◊®! ◊ú◊î◊ô◊õ◊†◊°?',
				confirmExit: '‚úÖ ◊ê◊©◊® ◊ó◊¶◊ô◊ô◊™ ◊ß◊ï',
				timeExceeded: 'üö® ◊ó◊®◊ô◊í◊™ ◊ñ◊û◊ü!',
				problemQuick: 'üê¢ ◊™◊ß◊ú◊î - ◊õ◊†◊ô◊°◊î ◊û◊î◊ô◊®◊î!',
				pushExtend: 'üî• ◊û◊ê◊®◊ô◊õ◊ô◊ù! ◊¶◊ë◊ï◊® ◊ñ◊û◊ü',
				nearLimit: '‚ö†Ô∏è ◊ß◊®◊ï◊ë ◊ú◊í◊ë◊ï◊ú!',
				targetWindow: '‚úÖ ◊ó◊ú◊ï◊ü ◊ô◊¢◊ì',
				overExtend: 'üì• ◊î◊ê◊®◊õ◊™ ◊ô◊™◊®',
				nightActive: 'üåô ◊ú◊ô◊ú◊î ◊§◊¢◊ô◊ú',
				pushActive: 'üî• ◊ß◊¶◊ë ◊§◊¢◊ô◊ú',
				problemActive: 'üê¢ ◊™◊ß◊ú◊î ◊§◊¢◊ô◊ú',
				teamNotFound: '◊ß◊ë◊ï◊¶◊î ◊ú◊ê ◊†◊û◊¶◊ê◊î',
				connectionIssues: '◊ë◊¢◊ô◊ï◊™ ◊ó◊ô◊ë◊ï◊®',
				usingIframe: '◊û◊©◊™◊û◊© ◊ë-iframe',
				connectionFailed: '◊î◊ó◊ô◊ë◊ï◊® ◊†◊õ◊©◊ú',
				stopped: '◊†◊¢◊¶◊®',
				racePreview: '◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î ◊©◊ú ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				raceStartTime: '◊©◊¢◊™ ◊î◊™◊ó◊ú◊™ ◊î◊û◊ô◊®◊ï◊•',
				driverSchedule: '◊ú◊ï◊ó ◊ñ◊û◊†◊ô◊ù ◊†◊î◊í◊ô◊ù',
				strategySummary: '◊°◊ô◊õ◊ï◊ù ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				editStrategy: '◊ó◊ñ◊®◊î ◊ú◊û◊°◊ö ◊®◊ê◊©◊ô',
				saveStrategy: '◊©◊û◊ï◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				previewStrategy: '◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î',
				stopLiveTiming: '◊¢◊¶◊ï◊®',
				activeRaceFound: '◊†◊û◊¶◊ê ◊û◊ô◊®◊ï◊• ◊§◊¢◊ô◊ú!',
				raceInProgress: '◊û◊ô◊®◊ï◊• ◊û◊™◊ß◊ô◊ô◊ù ◊õ◊¢◊™',
				timeRemaining: '◊ñ◊û◊ü ◊†◊ï◊™◊®',
				continueRace: '◊î◊û◊©◊ö ◊û◊ô◊®◊ï◊•',
				discardRace: '◊û◊ó◊ß ◊ï◊î◊™◊ó◊ú ◊ó◊ì◊©',
				raceWarning: '◊û◊ó◊ô◊ß◊î ◊™◊û◊ó◊ß ◊ú◊¶◊û◊ô◊™◊ï◊™ ◊ê◊™ ◊†◊™◊ï◊†◊ô ◊î◊û◊ô◊®◊ï◊•',
				confirmDiscard: '◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó?',
				confirmDiscardMessage: '◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊™◊û◊ó◊ß ◊ú◊¶◊û◊ô◊™◊ï◊™ ◊ê◊™ ◊î◊û◊ô◊®◊ï◊• ◊î◊§◊¢◊ô◊ú. ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ë◊ò◊ú ◊§◊¢◊ï◊ú◊î ◊ñ◊ï.',
				yesDiscard: '◊õ◊ü, ◊û◊ó◊ß ◊û◊ô◊®◊ï◊•',
				noKeepRace: '◊ú◊ê, ◊©◊û◊ï◊® ◊û◊ô◊®◊ï◊•',
				loadStrategy: '◊ò◊¢◊ü ◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊©◊û◊ï◊®◊î',
				savedStrategies: 'üìö ◊ê◊°◊ò◊®◊ò◊í◊ô◊ï◊™ ◊©◊û◊ï◊®◊ï◊™',
				noSavedStrategies: '◊ê◊ô◊ü ◊ê◊°◊ò◊®◊ò◊í◊ô◊ï◊™ ◊©◊û◊ï◊®◊ï◊™ ◊¢◊ì◊ô◊ô◊ü',
				strategyName: '◊©◊ù ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î:',
				strategySaved: '‚úÖ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊†◊©◊û◊®◊î:',
				aiAssistant: 'ü§ñ ◊¢◊ï◊ñ◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊î (AI)',
				expectedConditions: '◊™◊†◊ê◊ô◊ù ◊¶◊§◊ï◊ô◊ô◊ù:',
				mixed: '◊û◊¢◊ï◊®◊ë',
				strategyInstructions: '◊î◊ï◊®◊ê◊ï◊™ ◊ú◊ê◊ú◊í◊ï◊®◊ô◊™◊ù:',
				aiPlaceholder: "◊ú◊ì◊ï◊í◊û◊î: '◊™◊ü ◊ì◊ê◊ë◊ú ◊°◊ò◊ô◊†◊ò◊ô◊ù ◊ë◊ú◊ô◊ú◊î ◊ú◊ó◊ï◊ú◊ô◊î ◊ê', '◊©◊û◊ï◊® ◊ê◊™ ◊†◊î◊í X ◊ú◊°◊ï◊£'...",
				generateAi: 'ü§ñ ◊¶◊ï◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				analyzing: 'ü§ñ ◊û◊†◊™◊ó ◊ê◊°◊ò◊®◊ò◊í◊ô◊î...',
				aiApplied: '‚úÖ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊î◊ï◊ó◊ú◊î!',
				aiError: '‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊ô◊¶◊ô◊®◊™ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				pitClosedStart: 'üö´ ◊§◊ô◊ò◊° ◊°◊í◊ï◊® ◊ë◊î◊™◊ó◊ú◊î (◊ì◊ß\')',
				pitClosedEnd: 'üö´ ◊§◊ô◊ò◊° ◊°◊í◊ï◊® ◊ë◊°◊ï◊£ (◊ì◊ß\')',
				finish: '◊°◊ô◊ï◊ù',
				raceFinished: 'üèÅ ◊î◊û◊ô◊®◊ï◊• ◊î◊°◊™◊ô◊ô◊ù!',
				savedToDb: '‚úÖ ◊†◊©◊û◊® ◊ú◊û◊°◊ì ◊î◊†◊™◊ï◊†◊ô◊ù',
				safetyWarning: '‚ö†Ô∏è ◊ê◊ñ◊î◊®◊™ ◊ë◊ò◊ô◊ó◊ï◊™',
				googleConnect: '◊î◊™◊ó◊ë◊®◊ï◊™ Google',
				signInGoogle: '◊î◊™◊ó◊ë◊® ◊¢◊ù Google',
				emailTeam: '◊©◊ú◊ó ◊û◊ô◊ô◊ú ◊ú◊¶◊ï◊ï◊™',
				addCalendar: '◊î◊ï◊°◊£ ◊ú◊ô◊ï◊û◊ü',
				shareStrategy: '◊©◊™◊£ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				checkAvailability: '◊ë◊ì◊ï◊ß ◊ñ◊û◊ô◊†◊ï◊™',
				recipients: '◊†◊û◊¢◊†◊ô◊ù (◊û◊ï◊§◊®◊ì◊ô◊ù ◊ë◊§◊°◊ô◊ß)',
				emailSubject: '◊†◊ï◊©◊ê',
				message: '◊î◊ï◊ì◊¢◊î',
				attachStrategy: '◊¶◊®◊£ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊†◊ï◊õ◊ó◊ô◊™',
				sendEmail: '◊©◊ú◊ó ◊û◊ô◊ô◊ú',
				addToCalendar: '◊î◊ï◊°◊£ ◊ú◊ô◊ï◊û◊ü Google',
				eventTitle: '◊õ◊ï◊™◊®◊™ ◊ê◊ô◊®◊ï◊¢',
				startDate: '◊™◊ê◊®◊ô◊ö ◊î◊™◊ó◊ú◊î',
				startTime: '◊©◊¢◊™ ◊î◊™◊ó◊ú◊î',
				location: '◊û◊ô◊ß◊ï◊ù',
				inviteDrivers: '◊î◊ñ◊û◊ü ◊†◊î◊í◊ô◊ù (◊ê◊ô◊û◊ô◊ô◊ú◊ô◊ù)',
				addReminder: '◊î◊ï◊°◊£ ◊™◊ñ◊õ◊ï◊®◊™ (◊ô◊ï◊ù ◊ú◊§◊†◊ô)',
				createEvent: '◊¶◊ï◊® ◊ê◊ô◊®◊ï◊¢',
			},
			fr: {
				offline: 'Hors ligne',
				subtitle: 'Gestionnaire de Strat√©gie de Course d\'Endurance',
				host: 'H√¥te',
				hostDesc: 'G√©rer la course',
				viewer: 'Spectateur',
				viewerDesc: 'Regarder en direct',
				yourCode: 'Votre Code:',
				retry: 'R√©essayer',
				raceSettings: '‚öôÔ∏è Param√®tres de Course',
				liveTiming: 'Chronom√©trage en Direct (Optionnel)',
				liveTimingUrl: 'URL Chronom√©trage (APEX/RaceFacer)',
				searchBy: 'Rechercher par:',
				team: '√âquipe',
				kart: 'Kart',
				driver: 'Pilote',
				testConnection: 'Tester',
				demo: 'D√©mo',
				manual: 'Manuel',
				duration: 'Dur√©e (heures)',
				reqStops: 'Arr√™ts Requis',
				minStint: 'Stint Min (min)',
				maxStint: 'Stint Max (min)',
				driverLimits: 'Limites Pilote (0 = illimit√©)',
				minDrive: 'Min Conduite',
				maxDrive: 'Max Conduite',
				pitTime: 'Temps Pit (sec)',
				releaseBuffer: 'Alerte Avance (sec)',
				doubleStint: 'Double',
				fuel: 'Carburant',
				squads: '√âquipes',
				fuelTankTime: 'Autonomie R√©servoir (min)',
				driversSetup: 'Pilotes (marquer le d√©part)',
				startRace: 'D√©marrer Course (H√¥te)',
				enterCode: 'Entrer Code H√¥te:',
				connect: 'Connecter',
				disconnect: 'D√©connecter',
				code: 'Code:',
				synced: 'Synchronis√©',
				simResultPattern: "‚úÖ {stints} relais √ó ~{avg}min = {totalDrive}min conduite\nüèÅ Arr√™ts: {stops} √ó {pitTime}s = {totalPit}min\n{note}",
				stdStrategy: "Strat√©gie standard - maximiser les relais",
				shortStrategy: "Strat√©gie courte - minimiser les arr√™ts",
				longStrategy: "Strat√©gie longue - √©conomiser carburant/pneus",
				raceTime: 'Temps Course',
				pitStops: 'Arr√™ts Pit',
				dry: 'Sec',
				wet: 'Mouill√©',
				drying: 'S√©chage',
				targetStint: 'Stint Cible',
				buildTime: 'Accumuler Temps',
				stintTime: 'Temps Stint',
				currentDriver: 'Pilote Actuel',
				activeSquad: '√âquipe Active:',
				resting: 'Au Repos:',
				push: 'Pousser',
				problem: 'Probl√®me',
				night: 'Nuit',
				resetMode: '‚Ü©Ô∏è R√©initialiser',
				driverHeader: 'Pilote',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Prochain Pilote',
				enterPit: 'üèÅ Entrer Pit',
				inPit: 'AU PIT',
				nextDriverIn: 'Prochain Pilote:',
				refuel: 'Changement Kart / Ravitaillement?',
				notifyDriver: 'Alerter Pilote',
				notified: 'Alert√© - Attente passage ligne',
				wait: 'Attendre...',
				cancelPit: 'Annuler Entr√©e Pit',
				manualInput: 'Saisie Manuelle',
				position: 'Position',
				laps: 'Tours',
				lastLap: 'Dernier Tour',
				bestLap: 'Meilleur Tour',
				gap: '√âcart au Leader',
				inPitNow: 'Actuellement au Pit',
				apply: 'Appliquer',
				cancel: 'Annuler',
				waitingData: 'En attente de donn√©es...',
				proxyData: 'Donn√©es Proxy:',
				liveView: 'Vue en Direct',
				connecting: 'Connexion...',
				connected: 'Connect√©',
				waitingRace: 'Connect√©! En attente de la course...',
				disconnected: 'D√©connect√©',
				enterUrl: '‚ùå Entrer URL',
				enterValue: '‚ùå Entrer',
				testing: 'üîÑ Test...',
				found: '‚úÖ Trouv√©! Position:',
				notFound: '‚ö†Ô∏è Non trouv√© - v√©rifier ou utiliser iframe',
				error: '‚ùå Erreur:',
				confirmEarlyPit: 'Fen√™tre ferm√©e! Entrer quand m√™me?',
				confirmExit: '‚úÖ Confirmer Passage Ligne',
				timeExceeded: 'üö® Temps D√©pass√©!',
				problemQuick: 'üê¢ Probl√®me - Entr√©e Rapide!',
				pushExtend: 'üî• On prolonge! Accumuler temps',
				nearLimit: '‚ö†Ô∏è Proche limite!',
				targetWindow: '‚úÖ Fen√™tre Cible',
				overExtend: 'üì• Prolongation Excessive',
				nightActive: 'üåô Nuit Active',
				pushActive: 'üî• Pousser Actif',
				problemActive: 'üê¢ Probl√®me Actif',
				teamNotFound: '√âquipe non trouv√©e',
				connectionIssues: 'Probl√®mes de connexion',
				usingIframe: 'Utilisation de l\'iframe',
				connectionFailed: '√âchec de connexion',
				stopped: 'Arr√™t√©',
				racePreview: 'Aper√ßu de la Strat√©gie',
				raceStartTime: 'Heure de D√©part',
				driverSchedule: 'Horaire des Pilotes',
				strategySummary: 'R√©sum√© de la Strat√©gie',
				editStrategy: 'Retour √† l\'√©cran principal',
				saveStrategy: 'Enregistrer la Strat√©gie',
				previewStrategy: 'Aper√ßu de la Strat√©gie',
				stopLiveTiming: 'Arr√™ter',
				activeRaceFound: 'Course Active Trouv√©e!',
				raceInProgress: 'Une course est actuellement en cours',
				timeRemaining: 'Temps Restant',
				continueRace: 'Continuer la Course',
				discardRace: 'Supprimer et Recommencer',
				raceWarning: 'La suppression effacera d√©finitivement les donn√©es de course',
				confirmDiscard: '√ätes-vous S√ªr?',
				confirmDiscardMessage: 'Cela supprimera d√©finitivement la course active. Cette action ne peut pas √™tre annul√©e.',
				yesDiscard: 'Oui, Supprimer la Course',
				noKeepRace: 'Non, Garder la Course',
				loadStrategy: 'Charger une Strat√©gie',
				savedStrategies: 'üìö Strat√©gies Enregistr√©es',
				noSavedStrategies: 'Aucune strat√©gie enregistr√©e',
				strategyName: 'Nom de la strat√©gie:',
				strategySaved: '‚úÖ Strat√©gie enregistr√©e:',
				aiAssistant: 'ü§ñ Assistant Strat√©gie IA',
				expectedConditions: 'Conditions Pr√©vues:',
				mixed: 'Mixte',
				strategyInstructions: 'Instructions:',
				aiPlaceholder: "ex: 'Double relais la nuit pour l'√©quipe A', 'Garder pilote X pour la fin'...",
				generateAi: 'ü§ñ G√©n√©rer Strat√©gie',
				analyzing: 'ü§ñ Analyse en cours...',
				aiApplied: '‚úÖ Strat√©gie appliqu√©e!',
				aiError: '‚ùå Erreur de g√©n√©ration',
				pitClosedStart: 'üö´ Pit Ferm√© D√©but (min)',
				pitClosedEnd: 'üö´ Pit Ferm√© Fin (min)',
				finish: 'Fin',
				raceFinished: 'üèÅ Course Termin√©e!',
				savedToDb: '‚úÖ Enregistr√© dans la BDD',
				safetyWarning: '‚ö†Ô∏è Avertissement de S√©curit√©',
				googleConnect: 'Connexion Google',
				signInGoogle: 'Se connecter avec Google',
				emailTeam: 'Envoyer email √† l\'√©quipe',
				addCalendar: 'Ajouter au calendrier',
				shareStrategy: 'Partager la strat√©gie',
				checkAvailability: 'V√©rifier disponibilit√©',
				recipients: 'Destinataires (s√©par√©s par virgule)',
				emailSubject: 'Sujet',
				message: 'Message',
				attachStrategy: 'Joindre la strat√©gie actuelle',
				sendEmail: 'Envoyer Email',
				addToCalendar: 'Ajouter √† Google Agenda',
				eventTitle: 'Titre de l\'√©v√©nement',
				startDate: 'Date de d√©but',
				startTime: 'Heure de d√©but',
				location: 'Lieu',
				inviteDrivers: 'Inviter pilotes (emails)',
				addReminder: 'Ajouter rappel (1 jour avant)',
				createEvent: 'Cr√©er l\'√©v√©nement',
			},
			pt: {
				offline: 'Offline',
				subtitle: 'Gestor de Estrat√©gia de Corrida de Endurance',
				host: 'Anfitri√£o',
				hostDesc: 'Gerir a corrida',
				viewer: 'Espectador',
				viewerDesc: 'Ver ao vivo',
				yourCode: 'Seu C√≥digo:',
				retry: 'Tentar Novamente',
				raceSettings: '‚öôÔ∏è Configura√ß√µes da Corrida',
				liveTiming: 'Cronometragem ao Vivo (Opcional)',
				liveTimingUrl: 'URL Cronometragem (APEX/RaceFacer)',
				searchBy: 'Pesquisar por:',
				team: 'Equipa',
				kart: 'Kart',
				driver: 'Piloto',
				testConnection: 'Testar',
				demo: 'Demo',
				manual: 'Manual',
				duration: 'Dura√ß√£o (horas)',
				reqStops: 'Paragens Obrigat√≥rias',
				minStint: 'Stint M√≠n (min)',
				maxStint: 'Stint M√°x (min)',
				driverLimits: 'Limites Piloto (0 = ilimitado)',
				minDrive: 'M√≠n Condu√ß√£o',
				maxDrive: 'M√°x Condu√ß√£o',
				pitTime: 'Tempo Pit (seg)',
				releaseBuffer: 'Alerta Antecipado (seg)',
				doubleStint: 'Duplo',
				fuel: 'Combust√≠vel',
				squads: 'Equipas',
				fuelTankTime: 'Autonomia Tanque (min)',
				driversSetup: 'Pilotos (marcar partida)',
				startRace: 'Iniciar Corrida (Anfitri√£o)',
				enterCode: 'Inserir C√≥digo Anfitri√£o:',
				connect: 'Conectar',
				disconnect: 'Desconectar',
				code: 'C√≥digo:',
				synced: 'Sincronizado',
				simResultPattern: "‚úÖ {stints} turnos √ó ~{avg}min = {totalDrive}min condu√ß√£o\nüèÅ Paradas: {stops} √ó {pitTime}s = {totalPit}min\n{note}",
				stdStrategy: "Estrat√©gia padr√£o - maximizar turnos",
				shortStrategy: "Estrat√©gia curta - minimizar paradas",
				longStrategy: "Estrat√©gia longa - economizar combust√≠vel/pneus",
				raceTime: 'Tempo Corrida',
				pitStops: 'Paragens Pit',
				dry: 'Seco',
				wet: 'Molhado',
				drying: 'Secando',
				targetStint: 'Stint Alvo',
				buildTime: 'Acumular Tempo',
				stintTime: 'Tempo Stint',
				currentDriver: 'Piloto Atual',
				activeSquad: 'Equipa Ativa:',
				resting: 'Descansando:',
				push: 'Atacar',
				problem: 'Problema',
				night: 'Noite',
				resetMode: '‚Ü©Ô∏è Reiniciar',
				driverHeader: 'Piloto',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Pr√≥ximo Piloto',
				enterPit: 'üèÅ Entrar Pit',
				inPit: 'NO PIT',
				nextDriverIn: 'Pr√≥ximo Piloto:',
				refuel: 'Troca Kart / Reabastecimento?',
				notifyDriver: 'Alertar Piloto',
				notified: 'Alertado - Aguardando passagem linha',
				wait: 'Aguardar...',
				cancelPit: 'Cancelar Entrada Pit',
				manualInput: 'Entrada Manual',
				position: 'Posi√ß√£o',
				laps: 'Voltas',
				lastLap: '√öltima Volta',
				bestLap: 'Melhor Volta',
				gap: 'Diferen√ßa ao L√≠der',
				inPitNow: 'Atualmente no Pit',
				apply: 'Aplicar',
				cancel: 'Cancelar',
				waitingData: 'Aguardando dados...',
				proxyData: 'Dados Proxy:',
				liveView: 'Vista ao Vivo',
				connecting: 'Conectando...',
				connected: 'Conectado',
				waitingRace: 'Conectado! Aguardando corrida...',
				disconnected: 'Desconectado',
				enterUrl: '‚ùå Inserir URL',
				enterValue: '‚ùå Inserir',
				testing: 'üîÑ Testando...',
				found: '‚úÖ Encontrado! Posi√ß√£o:',
				notFound: '‚ö†Ô∏è N√£o encontrado - verificar ou usar iframe',
				error: '‚ùå Erro:',
				confirmEarlyPit: 'Janela fechada! Entrar mesmo assim?',
				confirmExit: '‚úÖ Confirmar Passagem Linha',
				timeExceeded: 'üö® Tempo Excedido!',
				problemQuick: 'üê¢ Problema - Entrada R√°pida!',
				pushExtend: 'üî• Prolongando! Acumular tempo',
				nearLimit: '‚ö†Ô∏è Perto do limite!',
				targetWindow: '‚úÖ Janela Alvo',
				overExtend: 'üì• Prolongamento Excessivo',
				nightActive: 'üåô Noite Ativa',
				pushActive: 'üî• Atacar Ativo',
				problemActive: 'üê¢ Problema Ativo',
				teamNotFound: 'Equipa n√£o encontrada',
				connectionIssues: 'Problemas de conex√£o',
				usingIframe: 'Usando iframe',
				connectionFailed: 'Conex√£o falhou',
				stopped: 'Parado',
				racePreview: 'Visualiza√ß√£o da Estrat√©gia de Corrida',
				raceStartTime: 'Hora de In√≠cio da Corrida',
				driverSchedule: 'Hor√°rio dos Pilotos',
				strategySummary: 'Resumo da Estrat√©gia',
				editStrategy: 'Voltar para tela principal',
				saveStrategy: 'Salvar Estrat√©gia',
				previewStrategy: 'Visualizar Estrat√©gia',
				stopLiveTiming: 'Parar',
				activeRaceFound: 'Corrida Ativa Encontrada!',
				raceInProgress: 'Uma corrida est√° atualmente em andamento',
				timeRemaining: 'Tempo Restante',
				continueRace: 'Continuar Corrida',
				discardRace: 'Descartar e Come√ßar Novo',
				raceWarning: 'Descartar ir√° excluir permanentemente os dados da corrida',
				confirmDiscard: 'Tem Certeza?',
				confirmDiscardMessage: 'Isso excluir√° permanentemente a corrida ativa. Esta a√ß√£o n√£o pode ser desfeita.',
				yesDiscard: 'Sim, Descartar Corrida',
				noKeepRace: 'N√£o, Manter Corrida',
				loadStrategy: 'Carregar Estrat√©gia',
				savedStrategies: 'üìö Estrat√©gias Salvas',
				noSavedStrategies: 'Nenhuma estrat√©gia salva',
				strategyName: 'Nome da Estrat√©gia:',
				strategySaved: '‚úÖ Estrat√©gia salva:',
				aiAssistant: 'ü§ñ Assistente de Estrat√©gia IA',
				expectedConditions: 'Condi√ß√µes Esperadas:',
				mixed: 'Misto',
				strategyInstructions: 'Instru√ß√µes:',
				aiPlaceholder: "ex: 'Duplo stint √† noite para Equipa A', 'Guardar piloto X para o fim'...",
				generateAi: 'ü§ñ Gerar Estrat√©gia',
				analyzing: 'ü§ñ Analisando estrat√©gia...',
				aiApplied: '‚úÖ Estrat√©gia aplicada!',
				aiError: '‚ùå Erro ao gerar',
				pitClosedStart: 'üö´ Pit Fechado In√≠cio (min)',
				pitClosedEnd: 'üö´ Pit Fechado Fim (min)',
				finish: 'Fim',
				raceFinished: 'üèÅ Corrida Terminada!',
				savedToDb: '‚úÖ Salvo no banco de dados',
				safetyWarning: '‚ö†Ô∏è Aviso de Seguran√ßa',
				googleConnect: 'Conex√£o Google',
				signInGoogle: 'Entrar com Google',
				emailTeam: 'Enviar e-mail para equipe',
				addCalendar: 'Adicionar √† Agenda',
				shareStrategy: 'Compartilhar Estrat√©gia',
				checkAvailability: 'Verificar Disponibilidade',
				recipients: 'Destinat√°rios (separados por v√≠rgula)',
				emailSubject: 'Assunto',
				message: 'Mensagem',
				attachStrategy: 'Anexar estrat√©gia atual',
				sendEmail: 'Enviar E-mail',
				addToCalendar: 'Adicionar ao Google Agenda',
				eventTitle: 'T√≠tulo do Evento',
				startDate: 'Data de In√≠cio',
				startTime: 'Hora de In√≠cio',
				location: 'Local',
				inviteDrivers: 'Convidar Pilotos (e-mails)',
				addReminder: 'Adicionar lembrete (1 dia antes)',
				createEvent: 'Criar Evento',
			}
		};
		
		function t(key) {
			return translations[currentLang][key] || translations['en'][key] || key;
		}

		function tFormat(key, replacements) {
			let text = t(key);
			for (const [placeholder, value] of Object.entries(replacements)) {
				// ◊û◊ó◊ú◊ô◊£ ◊ê◊™ {placeholder} ◊ë◊¢◊®◊ö ◊î◊ê◊û◊ô◊™◊ô
				text = text.replace(`{${placeholder}}`, value);
			}
			return text;
		}
		
		function setLanguage(lang) {
			if (!['en', 'he', 'fr', 'pt'].includes(lang)) return;
			
			currentLang = lang;
			document.documentElement.lang = currentLang;
			document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
			
			document.getElementById('langSelect').value = currentLang;
			
			applyTranslations();
			localStorage.setItem('strateger_lang', currentLang);
		}

		function applyTranslations() {
			document.querySelectorAll('[data-i18n]').forEach(el => {
				const key = el.getAttribute('data-i18n');
				if (translations[currentLang][key]) {
					el.innerText = translations[currentLang][key];
				}
			});
			updateSearchPlaceholder();
			const aiInput = document.getElementById('strategyInstructions');
			if (aiInput) {
				aiInput.placeholder = t('aiPlaceholder');
			}
		}
		
		function updateSearchPlaceholder() {
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			const input = document.getElementById('searchValue');
			if (!input) return;
			
			const placeholders = {
				en: {
					team: 'Enter team name (e.g. RACING TEAM)',
					kart: 'Enter kart number (e.g. 07)',
					driver: 'Enter driver name (e.g. John)'
				},
				he: {
					team: '◊î◊õ◊†◊° ◊©◊ù ◊ß◊ë◊ï◊¶◊î (◊ú◊û◊©◊ú: RACING)',
					kart: '◊î◊õ◊†◊° ◊û◊°◊§◊® ◊ß◊ê◊®◊ò (◊ú◊û◊©◊ú: 07)',
					driver: '◊î◊õ◊†◊° ◊©◊ù ◊†◊î◊í (◊ú◊û◊©◊ú: ◊ô◊†◊ô◊ë)'
				},
				fr: {
					team: 'Nom d\'√©quipe (ex: RACING TEAM)',
					kart: 'Num√©ro de kart (ex: 07)',
					driver: 'Nom du pilote (ex: Jean)'
				},
				pt: {
					team: 'Nome da equipa (ex: RACING TEAM)',
					kart: 'N√∫mero do kart (ex: 07)',
					driver: 'Nome do piloto (ex: Jo√£o)'
				}
			};
			
			input.placeholder = placeholders[currentLang]?.[searchType] || placeholders.en[searchType];
		}
		
		// ==================== INIT ====================
		document.addEventListener('DOMContentLoaded', () => {
			// Load saved language
			const savedLang = localStorage.getItem('strateger_lang');
			if (savedLang && ['en', 'he', 'fr', 'pt'].includes(savedLang)) {
				currentLang = savedLang;
				document.documentElement.lang = currentLang;
				document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
			}
			document.getElementById('langSelect').value = currentLang;
			applyTranslations();
			
			// Setup search type change handler
			document.querySelectorAll('input[name="searchType"]').forEach(radio => {
				radio.addEventListener('change', updateSearchPlaceholder);
			});
			
			generateDrivers();
			runSim();
            restoreHostState();
            console.log("Strateger loaded");
            
            // Check for saved race after a short delay
            setTimeout(checkForSavedRace, 500);
		});

        // PeerJS configuration
        const peerConfig = {
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ]
            }
        };

        // ==================== ROLE SELECTION ====================
        function selectRole(r) {
			// Destroy existing peer if switching roles
			if (peer) {
				peer.destroy();
				peer = null;
			}
			conn = null;
			connections = [];
			
			// Hide load strategy button when switching roles
			const loadBtn = document.getElementById('loadStrategyBtn');
			if (loadBtn) loadBtn.classList.add('hidden');
			
            role = r;
            document.getElementById('hostBtn').classList.toggle('border-ice', r === 'host');
            document.getElementById('clientBtn').classList.toggle('border-neon', r === 'client');
            document.getElementById('hostSection').classList.toggle('hidden', r !== 'host');
            document.getElementById('clientSection').classList.toggle('hidden', r !== 'client');
            document.getElementById('configPanel').classList.add('hidden');

            if (r === 'host') {
                initHostPeer();
            } else {
                initClientPeer();
            }
        }

		function applyViewerMode() {
			const dashboard = document.getElementById('raceDashboard');
			
			if (role === 'client') {
				dashboard.classList.add('viewer-mode');
				
				// ‚úÖ ◊î◊°◊™◊® ◊õ◊§◊™◊ï◊®◊ô◊ù (◊ú◊ê disable)
				const hideInViewer = [
					'btnPush',
					'btnBad', 
					'btnNight',
					'btnResetMode',
					'pitEntryBtn'
				];
				
				hideInViewer.forEach(id => {
					const el = document.getElementById(id);
					if (el) {
						el.classList.add('hidden');
					}
				});
				
				// ◊í◊ù ◊î◊°◊™◊® ◊õ◊§◊™◊ï◊®◊ô ◊î◊™◊ê◊û◊î
				document.querySelectorAll('[data-viewer-disabled="true"]').forEach(el => {
					if (el.tagName === 'BUTTON' || el.onclick) {
						el.classList.add('hidden');
					}
				});
				
				const headerText = document.getElementById('headerModeText');
				if (headerText) {
					headerText.textContent = 'VIEWER MODE';
					headerText.classList.remove('text-gray-500');
					headerText.classList.add('text-neon');
				}
				
				console.log('‚úÖ Viewer mode - Buttons hidden');
				
			} else if (role === 'host') {
				dashboard.classList.remove('viewer-mode');
				
				const showInHost = ['btnPush', 'btnBad', 'btnResetMode', 'pitEntryBtn'];
				showInHost.forEach(id => {
					const el = document.getElementById(id);
					if (el && id !== 'btnResetMode') {  // resetMode ◊û◊ï◊¶◊í ◊®◊ß ◊õ◊©◊ô◊© mode
						el.classList.remove('hidden');
					}
				});
				
				// btnNight ◊™◊ú◊ï◊ô ◊ë-squads
				const btnNight = document.getElementById('btnNight');
				if (btnNight && config.useSquads) {
					btnNight.classList.remove('hidden');
				}
				
				document.querySelectorAll('[data-viewer-disabled="true"]').forEach(el => {
					el.classList.remove('hidden');
				});
				
				const headerText = document.getElementById('headerModeText');
				if (headerText) {
					headerText.textContent = 'LIVE';
					headerText.classList.add('text-gray-500');
					headerText.classList.remove('text-neon');
				}
				
				console.log('‚úÖ Host mode - Full control');
			}
		}

        // ==================== SIMULATION ====================
        function runSim() {
			// ◊î◊®◊¶◊î ◊©◊ß◊ò◊î: ◊ó◊ô◊©◊ï◊ë ◊†◊™◊ï◊†◊ô◊ù ◊ë◊ú◊ë◊ì, ◊ú◊ú◊ê ◊¶◊ô◊ï◊®, ◊ú◊ú◊ê ◊î◊™◊®◊ê◊ï◊™ ◊ß◊ï◊§◊¶◊ï◊™
			const success = generatePreview(true, false);

			const resEl = document.getElementById('simResult');
			if (!resEl) return;

			if (!success || !previewData || !previewData.timeline) {
				resEl.innerText = "Calculating...";
				return;
			}

			// ◊†◊ô◊™◊ï◊ó ◊î◊†◊™◊ï◊†◊ô◊ù ◊©◊ó◊ï◊©◊ë◊ï
			const actualStints = previewData.timeline.filter(t => t.type === 'stint');
			const actualStops = previewData.timeline.filter(t => t.type === 'pit').length;
			
			const totalDriveMs = actualStints.reduce((sum, s) => sum + s.duration, 0);
			const avgStintMs = actualStints.length > 0 ? totalDriveMs / actualStints.length : 0;
			
			// ◊î◊û◊®◊î ◊ú◊™◊¶◊ï◊í◊î (◊ì◊ß◊ï◊™)
			const avgMins = (avgStintMs / 60000).toFixed(1);
			const totalDriveMins = (totalDriveMs / 60000).toFixed(0);
			const pitTimeSec = parseInt(document.getElementById('minPitTime').value) || 0;
			const totalPitMins = ((actualStops * pitTimeSec) / 60).toFixed(1);

			// ◊ë◊†◊ô◊ô◊™ ◊î◊ò◊ß◊°◊ò ◊ë◊ê◊†◊í◊ú◊ô◊™ (◊ô◊™◊ï◊®◊í◊ù ◊ê◊ù ◊ô◊© ◊û◊¢◊®◊õ◊™ ◊™◊®◊í◊ï◊ù, ◊ê◊ë◊ú ◊î◊ò◊ß◊°◊ò ◊î◊ë◊°◊ô◊°◊ô ◊î◊ï◊ê ◊ñ◊î)
			let text = `Strategy: Greedy (Max First)\n`;
			text += `Stints: ${actualStints.length} | Avg: ${avgMins}m\n`;
			text += `Drive: ${totalDriveMins}m | Stops: ${actualStops} (${totalPitMins}m)`;

			// ◊ë◊ì◊ô◊ß◊™ ◊î◊™◊ê◊û◊î ◊ú◊ñ◊û◊ü ◊î◊û◊ô◊®◊ï◊• (Sanity Check)
			const raceInputMs = (parseFloat(document.getElementById('raceDuration').value) || 0) * 60 * 60000;
			const calculatedTotalMs = totalDriveMs + (actualStops * pitTimeSec * 1000);
			const deltaMins = Math.round((calculatedTotalMs - raceInputMs) / 60000);

			// ◊ó◊ô◊ï◊ï◊ô ◊ï◊ô◊ñ◊ï◊ê◊ú◊ô ◊ê◊ù ◊î◊ó◊ô◊©◊ï◊ë ◊™◊ß◊ô◊ü
			if (Math.abs(deltaMins) > 2) {
				resEl.style.color = '#ef4444'; // ◊ê◊ì◊ï◊ù - ◊©◊í◊ô◊ê◊î ◊ë◊ñ◊û◊†◊ô◊ù
				text += `\n‚ö†Ô∏è Time Mismatch: ${deltaMins > 0 ? '+' : ''}${deltaMins}m`;
			} else {
				resEl.style.color = '#a3e635'; // ◊ô◊®◊ï◊ß - ◊™◊ß◊ô◊ü
				text += `\n‚úÖ Valid Strategy`;
			}

			resEl.innerText = text;
			resEl.classList.remove('hidden');
		}

		function checkGoogleSession() {
			const savedUser = localStorage.getItem('strateger_google_user');
			if (savedUser) {
				// If we have a user in storage but no access token in memory (page refresh),
				// we should either try to silent refresh or just clear to be safe/force login.
				if (!googleAccessToken) {
					console.log('Session state check: User present but no token. Clearing for security.');
					// Optional: You could try to auto-login here if you implemented persistent tokens,
					// but for this simple version, we log out to force fresh auth.
					googleSignOut();
				}
			}
		}
		// Add listener once
		window.addEventListener('load', checkGoogleSession);

		// ==================== AI STRATEGY CLIENT ====================

		async function callAIStrategy() {
			updateDriversFromUI(); // ◊ï◊ï◊ì◊ê ◊©◊ô◊© ◊ú◊†◊ï ◊ê◊™ ◊î◊†◊î◊í◊ô◊ù ◊î◊¢◊ì◊õ◊†◊ô◊ô◊ù

			// 1. ◊ê◊ô◊°◊ï◊£ ◊î◊†◊™◊ï◊†◊ô◊ù ◊ú◊©◊ú◊ô◊ó◊î
			const config = {
				raceDuration: document.getElementById('raceDuration').value,
				reqPitStops: document.getElementById('reqPitStops').value,
				minStint: document.getElementById('minStint').value,
				maxStint: document.getElementById('maxStint').value,
				pitTime: document.getElementById('minPitTime').value,
				drivers: drivers.map(d => d.name)
			};

			const btn = document.querySelector('button[onclick="callAIStrategy()"]');
			const originalText = btn.innerHTML;
			btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Thinking...';
			btn.disabled = true;

			try {
				// 2. ◊ë◊†◊ô◊ô◊™ ◊î◊§◊®◊ï◊û◊§◊ò
				const prompt = `
					Act as a race strategist. 
					Race Duration: ${config.raceDuration} hours.
					Required Stops: ${config.reqPitStops}.
					Drivers: ${config.drivers.join(', ')}.
					Min Stint: ${config.minStint} min, Max Stint: ${config.maxStint} min.
					Pit Stop Time: ${config.pitTime} seconds.
					
					Analyze the best way to distribute the stints among these drivers.
					Consider fatigue and optimal rotation.
					Return a short summary and a recommendation in JSON format describing the schedule concept.
				`;

				// 3. ◊ß◊®◊ô◊ê◊î ◊ú-Netlify Function (◊ï◊ú◊ê ◊ú-Gemini ◊ô◊©◊ô◊®◊ï◊™)
				const response = await fetch('/.netlify/functions/ai-strategy', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ prompt: prompt })
				});

				const data = await response.json();

				if (!data.success) {
					throw new Error(data.error || 'Failed to generate strategy');
				}

				// 4. ◊î◊¶◊í◊™ ◊î◊™◊©◊ï◊ë◊î (◊î◊ó◊ú◊ß ◊î◊ñ◊î ◊™◊ú◊ï◊ô ◊ê◊ô◊ö ◊î-Server ◊û◊ó◊ñ◊ô◊® ◊ê◊™ ◊î◊û◊ô◊ì◊¢)
				// ◊ë◊î◊†◊ó◊î ◊©◊î◊©◊®◊™ ◊û◊ó◊ñ◊ô◊® { success: true, content: [{ text: "..." }] }
				const aiText = data.content[0].text;
				alert("ü§ñ AI Recommendation:\n" + aiText);

			} catch (error) {
				console.error("AI Error:", error);
				alert("‚ö†Ô∏è AI Error: " + error.message);
			} finally {
				btn.innerHTML = originalText;
				btn.disabled = false;
			}
		}

		async function generateAIStrategy() {
			const statusEl = document.getElementById('aiStrategyStatus');
			statusEl.classList.remove('hidden');
			statusEl.innerText = t('analyzing');
			statusEl.className = 'text-[10px] text-yellow-500 text-center mt-2';
			
			const instructions = document.getElementById('strategyInstructions').value;
			
			// ◊ê◊ô◊°◊ï◊£ ◊†◊™◊ï◊†◊ô◊ù ◊û◊î◊û◊û◊©◊ß
			const raceDur = parseFloat(document.getElementById('raceDuration').value);
			const reqStops = parseInt(document.getElementById('reqPitStops').value);
			const minStint = parseFloat(document.getElementById('minStint').value);
			const maxStint = parseFloat(document.getElementById('maxStint').value);
			const pitTime = parseInt(document.getElementById('minPitTime').value);
			const allowDouble = document.getElementById('allowDouble').checked;
			const useSquads = document.getElementById('useSquads').checked;
			const weatherCondition = document.querySelector('input[name="weatherCondition"]:checked')?.value || 'dry';
			
			// ◊î◊õ◊†◊™ ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊ê◊ô◊ú◊ï◊¶◊ô◊ù ◊†◊ß◊ô ◊ú-Gemini
			const constraints = {
				raceDuration: raceDur * 60, // ◊ì◊ß◊ï◊™
				totalStints: reqStops + 1,
				pitStops: reqStops,
				minStint: minStint,
				maxStint: maxStint,
				pitTime: pitTime,
				useSquads: useSquads,
				allowDouble: allowDouble,
				minDrive: parseInt(document.getElementById('minDriverTime').value) || 0,
				maxDrive: parseInt(document.getElementById('maxDriverTime').value) || 0
			};

			const prompt = `
			User Instructions: ${instructions || "Optimize for speed."}
			Drivers Available: ${drivers.map(d => d.name + " (Squad " + d.squad + ")").join(', ')}
			Weather: ${weatherCondition}
			`;

			try {
				// ◊ß◊®◊ô◊ê◊î ◊ú◊§◊ï◊†◊ß◊¶◊ô◊î ◊î◊ó◊ì◊©◊î ◊ë-Netlify
				const response = await fetch('/.netlify/functions/ai-strategy', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ prompt, constraints }) // ◊©◊ï◊ú◊ó◊ô◊ù ◊í◊ù constraints
				});
				
				const data = await response.json();
				
				if (!data.success) throw new Error(data.error || 'AI request failed');
				
				// Gemini ◊û◊ó◊ñ◊ô◊® ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊™◊ï◊õ◊ü ◊ë◊™◊ï◊ö content
				const result = data.content; 
				
				// ◊î◊ó◊ú◊™ ◊î◊î◊û◊ú◊¶◊ï◊™
				if (result.stints && Array.isArray(result.stints)) {
					applyAIStrategyToTimeline(result.stints);
					statusEl.innerText = '‚úÖ AI strategy applied!';
					statusEl.className = 'text-[10px] text-green-400 text-center mt-2';
					
					// ◊î◊¶◊í◊™ ◊î◊°◊ë◊®
					document.getElementById('simResult').innerText = "ü§ñ AI Plan: " + (result.explanation || "Optimized strategy generated.");
				} else {
					throw new Error("Invalid AI response format");
				}

			} catch (error) {
				console.error('AI Strategy Error:', error);
				statusEl.innerText = `‚ùå ${error.message}`;
				statusEl.className = 'text-[10px] text-red-400 text-center mt-2';
			}
			
			setTimeout(() => statusEl.classList.add('hidden'), 5000);
		}

		// ◊§◊ï◊†◊ß◊¶◊ô◊ô◊™ ◊¢◊ñ◊® ◊ó◊ì◊©◊î ◊©◊û◊û◊ô◊®◊î ◊ê◊™ ◊™◊©◊ï◊ë◊™ ◊î-AI ◊ú◊ò◊ô◊ô◊ù-◊ú◊ô◊ô◊ü ◊©◊ú ◊î◊û◊¢◊®◊õ◊™
		function applyAIStrategyToTimeline(aiStints) {
			// ◊¢◊ì◊õ◊ï◊ü ◊î◊†◊™◊ï◊†◊ô◊ù ◊î◊ú◊ï◊ß◊ê◊ú◊ô◊ô◊ù
			if (!previewData) generatePreview(); // ◊ô◊¶◊ô◊®◊™ ◊ë◊°◊ô◊° ◊ê◊ù ◊ê◊ô◊ü
			
			// ◊û◊ô◊§◊ï◊ô ◊î◊†◊î◊í◊ô◊ù ◊û◊î-AI ◊ú◊†◊î◊í◊ô◊ù ◊©◊ú◊†◊ï (◊ú◊§◊ô ◊©◊ù)
			const newTimeline = [];
			let currentTime = 0;
			const startTime = previewData.startTime || new Date();

			aiStints.forEach((stint, idx) => {
				// ◊û◊¶◊ô◊ê◊™ ◊î◊†◊î◊í ◊î◊û◊™◊ê◊ô◊ù
				const driverIdx = drivers.findIndex(d => d.name.toLowerCase() === stint.driver.toLowerCase());
				const safeDriverIdx = driverIdx >= 0 ? driverIdx : 0; // Fallback
				
				const durationMs = stint.durationMin * 60000;
				
				// ◊ô◊¶◊ô◊®◊™ ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊°◊ò◊ô◊†◊ò
				newTimeline.push({
					type: 'stint',
					stintNumber: idx + 1,
					driverIdx: safeDriverIdx,
					driverName: drivers[safeDriverIdx].name,
					color: drivers[safeDriverIdx].color || `hsl(${(safeDriverIdx * 360 / drivers.length)}, 70%, 50%)`,
					start: currentTime,
					duration: durationMs,
					startTime: new Date(startTime.getTime() + currentTime),
					endTime: new Date(startTime.getTime() + currentTime + durationMs),
					note: stint.notes // ◊î◊¢◊®◊ï◊™ ◊û◊î-AI
				});
				
				currentTime += durationMs;

				// ◊î◊ï◊°◊§◊™ ◊¢◊¶◊ô◊®◊î (◊ê◊ù ◊ñ◊î ◊ú◊ê ◊î◊°◊ò◊ô◊†◊ò ◊î◊ê◊ó◊®◊ï◊ü)
				if (idx < aiStints.length - 1) {
					const pitMs = config.minPitSec * 1000;
					newTimeline.push({
						type: 'pit',
						pitNumber: idx + 1,
						start: currentTime,
						duration: pitMs,
						startTime: new Date(startTime.getTime() + currentTime)
					});
					currentTime += pitMs;
				}
			});

			previewData.timeline = newTimeline;
			
			// ◊ó◊ô◊©◊ï◊ë ◊û◊ó◊ì◊© ◊©◊ú ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊†◊î◊í◊ô◊ù
			recalculateDriverStatsFromTimeline();
			
			renderPreview();
		}

        function toggleConfigPanel(event) {
			// ◊ê◊ù ◊ñ◊î ◊ú◊ó◊ô◊¶◊î ◊¢◊ú ◊†◊î◊í, ◊î◊™◊¢◊ú◊ù
			if (event && event.target.closest('.starter-indicator, .starter-radio, .driver-input')) {
				console.log('üõ°Ô∏è Blocked toggle from driver interaction');
				return;
			}
			
			const panel = document.getElementById('configPanel');
			const arrow = document.getElementById('configArrow');
			panel.classList.toggle('hidden');
			arrow.innerText = panel.classList.contains('hidden') ? '‚ñº' : '‚ñ≤';
		}
		
		// ==================== LIVE TIMING ====================
		function updateSearchConfig() {
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			const searchValue = document.getElementById('searchValue')?.value || '';
			
			searchConfig.teamName = '';
			searchConfig.driverName = '';
			searchConfig.kartNumber = '';
			
			if (searchType === 'team') {
				searchConfig.teamName = searchValue;
			} else if (searchType === 'kart') {
				searchConfig.kartNumber = searchValue;
			} else if (searchType === 'driver') {
				searchConfig.driverName = searchValue;
			}
		}
		
		function testLiveTiming() {
			const url = document.getElementById('liveTimingUrl').value;
			const searchValue = document.getElementById('searchValue')?.value || '';
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			
			const statusEl = document.getElementById('liveTimingStatus');
			
			if (!url) {
				statusEl.innerText = t('enterUrl');
				statusEl.className = "text-[10px] text-red-500 text-center";
				return;
			}
			
			if (!searchValue) {
				const typeNames = { team: t('team'), kart: t('kart'), driver: t('driver') };
				statusEl.innerText = `${t('enterValue')} ${typeNames[searchType]}`;
				statusEl.className = "text-[10px] text-red-500 text-center";
				return;
			}
			
			liveTimingConfig.url = url;
			liveTimingConfig.enabled = true;
			updateSearchConfig();
			
			statusEl.innerText = t('testing');
			statusEl.className = "text-[10px] text-yellow-500 text-center";
			
			fetchLiveTimingFromProxy().then(() => {
				if (liveData.position) {
					statusEl.innerText = `${t('found')} ${liveData.position}`;
					statusEl.className = "text-[10px] text-green-500 text-center font-bold";
				} else {
					statusEl.innerText = t('notFound');
					statusEl.className = "text-[10px] text-yellow-500 text-center";
				}
			}).catch(e => {
				statusEl.innerText = `${t('error')} ${e.message}`;
				statusEl.className = "text-[10px] text-red-500 text-center";
			});
		}
		
		async function fetchLiveTimingFromProxy() {
			if (!liveTimingConfig.url) return;
			
			updateSearchConfig();
			updateProxyStatus("üîÑ " + t('connecting'));
			
			// ◊ô◊¶◊ô◊®◊™ ◊û◊†◊î◊ú ◊ê◊ù ◊ú◊ê ◊ß◊ô◊ô◊ù
			if (!liveTimingManager) {
				// ◊õ◊ê◊ü ◊ê◊†◊ó◊†◊ï ◊û◊°◊™◊û◊õ◊ô◊ù ◊¢◊ú ◊î◊ß◊ï◊ë◊• live-timing-manager.js ◊©◊†◊ò◊¢◊ü
				// ◊î◊ï◊ê ◊ô◊ó◊ú◊ô◊ò ◊ê◊ù ◊ú◊î◊©◊™◊û◊© ◊ë-Apex Scraper ◊î◊ó◊ì◊© ◊ê◊ï ◊î◊ô◊©◊ü
				liveTimingManager = new LiveTimingManager();
			}
			
			const url = liveTimingConfig.url;
			// ◊ê◊ô◊ó◊ï◊ì ◊§◊®◊û◊ò◊®◊ô◊ù ◊ú◊ó◊ô◊§◊ï◊© ◊ó◊õ◊ù
			const searchTerm = searchConfig.driverName || searchConfig.teamName || searchConfig.kartNumber || '';

			// ◊î◊™◊ó◊ú◊™ ◊î◊°◊ß◊®◊ô◊ô◊§◊® ◊ì◊®◊ö ◊î◊û◊†◊î◊ú
			liveTimingManager.start(url, searchTerm, {
				updateInterval: 2000, // ◊û◊î◊ô◊® ◊ô◊ï◊™◊® ◊ë◊©◊ë◊ô◊ú WebSocket
				
				onUpdate: (data) => {
					// ◊î◊ò◊ô◊§◊ï◊ú ◊ë◊†◊™◊ï◊†◊ô◊ù ◊†◊©◊ê◊® ◊ñ◊î◊î ◊ú◊û◊î ◊©◊ô◊© ◊ú◊ö ◊õ◊ë◊®
					if (data.ourTeam) {
						liveData.previousPosition = liveData.position;
						liveData.position = data.ourTeam.position;
						liveData.lastLap = data.ourTeam.lastLap;
						liveData.bestLap = data.ourTeam.bestLap;
						liveData.laps = data.ourTeam.totalLaps;
						liveData.gapToLeader = data.ourTeam.gap;
					}
					liveData.competitors = data.competitors;
					updateLiveTimingUI();
					
					// ◊¢◊ì◊õ◊ï◊ü ◊°◊ò◊ò◊ï◊° ◊©◊û◊®◊ê◊î ◊ë◊ê◊ô◊ñ◊î ◊§◊®◊ï◊ò◊ï◊ß◊ï◊ú ◊ê◊†◊ó◊†◊ï ◊û◊©◊™◊û◊©◊ô◊ù
					const method = data.provider || 'http';
					updateProxyStatus(`‚úÖ Connected (${method})`);
				},
				
				onError: (err, count) => {
					console.error("Scraper Error:", err);
					updateProxyStatus(`‚ö†Ô∏è Error ${count}: ${err.message}`);
				}
			});
		}
		
		function parseTimeToMs(timeStr) {
			if (!timeStr) return null;
			if (typeof timeStr === 'number') return timeStr;
			
			const match = String(timeStr).match(/(?:(\d{1,2}):)?(\d{1,2}):?(\d{2})\.(\d{2,3})/);
			if (match) {
				const hours = match[1] ? parseInt(match[1]) : 0;
				const mins = parseInt(match[2]) || 0;
				const secs = parseInt(match[3]) || 0;
				let ms = parseInt(match[4]) || 0;
				if (match[4].length === 2) ms *= 10;
				return (hours * 3600 + mins * 60 + secs) * 1000 + ms;
			}
			
			const secMatch = String(timeStr).match(/(\d+)\.(\d{2,3})/);
			if (secMatch) {
				let ms = parseInt(secMatch[2]);
				if (secMatch[2].length === 2) ms *= 10;
				return parseInt(secMatch[1]) * 1000 + ms;
			}
			
			return null;
		}
		
		function updateProxyStatus(msg) {
			const el = document.getElementById('liveTimingStatus');
			if (el) el.innerText = msg;
		}
		
		function startProxyLiveTiming() {
			if (proxyFetchInterval) clearInterval(proxyFetchInterval);
			
			fetchLiveTimingFromProxy();
			proxyFetchInterval = setInterval(fetchLiveTimingFromProxy, 5000);
		}
		
		function stopProxyLiveTiming() {
			if (proxyFetchInterval) {
				clearInterval(proxyFetchInterval);
				proxyFetchInterval = null;
			}
		}
		
		// ==================== MANUAL INPUT ====================
		function openManualInput() {
			document.getElementById('manualInputModal').classList.remove('hidden');
			
			// Pre-fill with current values
			if (liveData.position) document.getElementById('manualPosition').value = liveData.position;
			if (liveData.laps) document.getElementById('manualLaps').value = liveData.laps;
			if (liveData.lastLap) document.getElementById('manualLastLap').value = formatLapTime(liveData.lastLap);
			if (liveData.bestLap) document.getElementById('manualBestLap').value = formatLapTime(liveData.bestLap);
		}
		
		function closeManualInput() {
			document.getElementById('manualInputModal').classList.add('hidden');
		}
		
		function applyManualInput() {
			const pos = parseInt(document.getElementById('manualPosition').value);
			const laps = parseInt(document.getElementById('manualLaps').value);
			const lastLap = parseTimeToMs(document.getElementById('manualLastLap').value);
			const bestLap = parseTimeToMs(document.getElementById('manualBestLap').value);
			const gap = document.getElementById('manualGap').value;
			const inPit = document.getElementById('manualInPit').checked;
			
			if (pos) {
				liveData.previousPosition = liveData.position;
				liveData.position = pos;
			}
			if (laps) liveData.laps = laps;
			if (lastLap) liveData.lastLap = lastLap;
			if (bestLap) liveData.bestLap = bestLap;
			if (gap) liveData.gapToLeader = parseTimeToMs(gap);
			
			// Enable live timing display
			liveTimingConfig.enabled = true;
			document.getElementById('liveTimingPanel').classList.remove('hidden');
			document.getElementById('liveIndicator').classList.remove('hidden');
			
			updateLiveTimingUI();
			closeManualInput();
			broadcast();
		}
		
		// ==================== LIVE TIMING EMBED ====================
		function openLiveTimingEmbed() {
			const url = liveTimingConfig.url;
			if (!url) return;
			
			document.getElementById('liveTimingEmbed').classList.remove('hidden');
			document.getElementById('liveTimingIframe').src = url;
		}
		
		function closeLiveTimingEmbed() {
			document.getElementById('liveTimingEmbed').classList.add('hidden');
			document.getElementById('liveTimingIframe').src = 'about:blank';
		}
		
		function toggleLiveTimingEmbed() {
			const embed = document.getElementById('liveTimingEmbed');
			if (embed.classList.contains('hidden')) {
				openLiveTimingEmbed();
			} else {
				closeLiveTimingEmbed();
			}
		}
		
		function refreshLiveTiming() {
			fetchLiveTimingFromProxy();
		}
		
		// ==================== PRE-RACE SIMULATION ====================
		let previewData = null;

		/**
		 * ◊û◊ô◊ô◊¶◊® ◊ê◊™ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î.
		 * @param {boolean} silentMode - ◊ê◊ù true, ◊ú◊ê ◊û◊ß◊§◊ô◊• ◊î◊ï◊ì◊¢◊ï◊™ ◊©◊í◊ô◊ê◊î (◊ú◊©◊ô◊û◊ï◊© ◊ë◊ñ◊û◊ü ◊î◊ß◊ú◊ì◊î).
		 * @param {boolean} shouldRender - ◊ê◊ù true, ◊û◊¶◊ô◊ô◊® ◊ê◊™ ◊î◊í◊®◊£. ◊ê◊ù false, ◊®◊ß ◊û◊ó◊©◊ë ◊†◊™◊ï◊†◊ô◊ù.
		 */
		/**
		 * ◊û◊ô◊ô◊¶◊® ◊ê◊™ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊õ◊ï◊ú◊ú ◊ó◊ú◊ï◊ß◊î ◊ú◊ó◊ï◊ú◊ô◊ï◊™ ◊ë◊û◊ô◊®◊ï◊¶◊ô◊ù ◊ê◊®◊ï◊õ◊ô◊ù
		 */
		function generatePreview(silentMode = false, shouldRender = true) {
			updateDriversFromUI();

			if (!drivers || drivers.length === 0) {
				if (!silentMode) alert("‚ö†Ô∏è Warning: No drivers defined.");
				return false;
			}
			
			// ◊ß◊®◊ô◊ê◊™ ◊†◊™◊ï◊†◊ô◊ù
			const raceHours = parseFloat(document.getElementById('raceDuration').value) || 0;
			const raceMs = raceHours * 60 * 60000;
			
			const reqStops = parseInt(document.getElementById('reqPitStops').value) || 0;
			const pitSec = parseInt(document.getElementById('minPitTime').value) || 0;
			const pitTimeMs = pitSec * 1000;
			
			const minStintMs = Math.max(60000, (parseFloat(document.getElementById('minStint').value) || 1) * 60000);
			const maxStintInput = parseFloat(document.getElementById('maxStint').value) || 0;
			const maxStintMs = (maxStintInput > 0) ? (maxStintInput * 60000) - 60000 : raceMs; // ◊ë◊ê◊§◊® ◊ì◊ß◊î

			// ◊î◊í◊ì◊®◊ï◊™ ◊û◊™◊ß◊ì◊û◊ï◊™
			const allowDouble = document.getElementById('allowDouble')?.checked || false;
			const useSquads = document.getElementById('useSquads')?.checked || false;
			
			// ◊ó◊ú◊ï◊†◊ï◊™ ◊§◊ô◊ò◊°
			const pitClosedStartMs = (parseFloat(document.getElementById('pitClosedStart')?.value) || 0) * 60000;
			const pitClosedEndMs = (parseFloat(document.getElementById('pitClosedEnd')?.value) || 0) * 60000;

			// ◊ó◊ô◊©◊ï◊ë ◊ñ◊û◊ü ◊†◊ò◊ï
			const totalPitMs = reqStops * pitTimeMs;
			let driveTimeLeft = raceMs - totalPitMs;
			
			if (driveTimeLeft <= 0) {
				if (!silentMode) alert("‚ùå Error: Pit stops take longer than the race!");
				return false;
			}

			const totalStints = reqStops + 1;
			
			// ◊ñ◊û◊ü ◊î◊™◊ó◊ú◊î
			let startTimeObj = new Date();
			if (window.raceStartTime && !isNaN(new Date(window.raceStartTime).getTime())) {
				startTimeObj = new Date(window.raceStartTime);
			}

			let currentTime = new Date(startTimeObj);
			const timeline = [];
			const driverStats = drivers.map(d => ({ ...d, totalTime: 0, stints: 0 })); 
			
			// ◊†◊î◊í ◊§◊ï◊™◊ó
			let lastDriverIdx = drivers.findIndex(d => d.isStarter);
			if (lastDriverIdx === -1) lastDriverIdx = 0;
			lastDriverIdx = (lastDriverIdx - 1 + drivers.length) % drivers.length;

			// === ◊î◊í◊ì◊®◊™ ◊û◊©◊ö ◊°◊ë◊ë ◊ó◊ï◊ú◊ô◊î (Squad Rotation) ===
			// ◊ê◊ù ◊î◊û◊ô◊®◊ï◊• ◊ê◊®◊ï◊ö ◊û-15 ◊©◊¢◊ï◊™, ◊†◊ó◊ú◊ô◊£ ◊ó◊ï◊ú◊ô◊ï◊™ ◊õ◊ú 6 ◊©◊¢◊ï◊™ (360 ◊ì◊ß◊ï◊™) ◊õ◊ì◊ô ◊ú◊ê◊§◊©◊® ◊©◊ô◊†◊î
			// ◊ë◊û◊ô◊®◊ï◊• ◊ß◊¶◊®, ◊§◊©◊ï◊ò ◊†◊ó◊ú◊ô◊£ ◊õ◊ú ◊°◊ò◊ô◊†◊ò ◊ê◊ï ◊ú◊§◊ô ◊î◊¶◊ï◊®◊ö
			const isLongRace = raceHours >= 15;
			const squadRotationMs = 6 * 60 * 60000; // 6 ◊©◊¢◊ï◊™ ◊ë◊û◊ô◊ú◊ô◊©◊†◊ô◊ï◊™

			// === ◊ú◊ï◊ú◊ê◊™ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î ===
			for (let i = 0; i < totalStints; i++) {
				const isFirstStint = (i === 0);
				const isLastStint = (i === totalStints - 1);
				
				// 1. ◊ó◊ô◊©◊ï◊ë ◊ñ◊û◊ü ◊ó◊û◊ì◊ü (Greedy)
				const stintsRemainingAfter = totalStints - 1 - i;
				let timeToReserve = stintsRemainingAfter * minStintMs;

				if (!isLastStint && pitClosedEndMs > 0 && i === totalStints - 2) {
					timeToReserve = Math.max(timeToReserve, pitClosedEndMs + 60000);
				}

				let currentStintDuration = driveTimeLeft - timeToReserve;

				if (currentStintDuration > maxStintMs) currentStintDuration = maxStintMs;

				if (isFirstStint && pitClosedStartMs > 0) {
					if (currentStintDuration < pitClosedStartMs + 60000) {
						currentStintDuration = Math.min(driveTimeLeft, pitClosedStartMs + 60000);
					}
				}

				if (currentStintDuration < minStintMs && !isLastStint) currentStintDuration = minStintMs;
				if (isLastStint) currentStintDuration = Math.max(0, driveTimeLeft);

				// 2. ◊ë◊ó◊ô◊®◊™ ◊†◊î◊í - ◊ú◊ï◊í◊ô◊ß◊™ ◊ó◊ï◊ú◊ô◊ï◊™ (Squads Logic)
				let selectedDriverIdx = -1;
				
				// ◊ß◊ë◊ô◊¢◊™ ◊î◊ó◊ï◊ú◊ô◊î ◊î◊§◊¢◊ô◊ú◊î ◊î◊†◊ï◊õ◊ó◊ô◊™
				let targetSquad = null;
				if (useSquads) {
					if (isLongRace) {
						// ◊ë◊û◊ô◊®◊ï◊• ◊ê◊®◊ï◊ö: ◊ú◊§◊ô ◊ñ◊û◊ü ◊©◊ó◊ú◊£ ◊û◊™◊ó◊ô◊ú◊™ ◊î◊û◊ô◊®◊ï◊•
						const elapsedTime = currentTime - startTimeObj;
						// ◊ó◊ú◊ï◊ß◊î ◊ú◊ë◊ú◊ï◊ß◊ô◊ù ◊©◊ú 6 ◊©◊¢◊ï◊™: ◊ñ◊ï◊í◊ô = A, ◊ê◊ô ◊ñ◊ï◊í◊ô = B
						const blockIndex = Math.floor(elapsedTime / squadRotationMs);
						targetSquad = (blockIndex % 2 === 0) ? 'A' : 'B';
					} else {
						// ◊ë◊û◊ô◊®◊ï◊• ◊ß◊¶◊®: ◊†◊©◊ê◊®◊ô◊ù ◊¢◊ù ◊ú◊ï◊í◊ô◊ß◊î ◊§◊©◊ï◊ò◊î ◊ô◊ï◊™◊® ◊ê◊ï ◊ú◊§◊ô ◊ë◊ó◊ô◊®◊î ◊ô◊ì◊†◊ô◊™
						// ◊õ◊ê◊ü ◊†◊†◊ô◊ó ◊©◊®◊ï◊¶◊ô◊ù ◊®◊ï◊ò◊¶◊ô◊î ◊§◊©◊ï◊ò◊î ◊ô◊ï◊™◊®, ◊ê◊ë◊ú ◊†◊©◊ê◊ô◊® ◊ñ◊ê◊™ ◊í◊û◊ô◊©
						targetSquad = null; // ◊û◊ê◊§◊©◊® ◊¢◊®◊ë◊ï◊ë
					}
				}

				for (let attempt = 0; attempt < drivers.length; attempt++) {
					const checkIdx = (lastDriverIdx + 1 + attempt) % drivers.length;
					const driverData = drivers[checkIdx];

					// ◊ë◊ì◊ô◊ß◊™ ◊ó◊ï◊ú◊ô◊î (◊ê◊ù ◊û◊ï◊§◊¢◊ú◊™)
					if (targetSquad && driverData.squad !== targetSquad) continue;

					// ◊ë◊ì◊ô◊ß◊™ ◊ì◊ê◊ë◊ú ◊°◊ò◊ô◊†◊ò
					if (!allowDouble && checkIdx === lastDriverIdx && drivers.length > 1) continue;
					
					selectedDriverIdx = checkIdx;
					break;
				}
				
				// Fallback: ◊ê◊ù ◊ú◊ê ◊†◊û◊¶◊ê ◊†◊î◊í ◊ë◊ó◊ï◊ú◊ô◊î (◊ê◊ï ◊õ◊ï◊ú◊ù ◊¢◊ô◊ô◊§◊ô◊ù), ◊ú◊ï◊ß◊ó◊ô◊ù ◊ê◊™ ◊î◊ë◊ê ◊ë◊™◊ï◊®
				if (selectedDriverIdx === -1) {
					selectedDriverIdx = (lastDriverIdx + 1) % drivers.length;
				}

				// ◊¢◊ì◊õ◊ï◊ü ◊†◊™◊ï◊†◊ô◊ù
				const driver = drivers[selectedDriverIdx];
				driverStats[selectedDriverIdx].totalTime += currentStintDuration;
				driverStats[selectedDriverIdx].stints += 1;
				lastDriverIdx = selectedDriverIdx;

				const stintStart = new Date(currentTime);
				const stintEnd = new Date(currentTime.getTime() + currentStintDuration);
				
				timeline.push({
					type: 'stint',
					stintNumber: i + 1,
					driverName: driver.name,
					driverIdx: selectedDriverIdx, 
					color: driver.color,
					squad: driver.squad, // ◊©◊ï◊û◊®◊ô◊ù ◊ê◊™ ◊î◊ó◊ï◊ú◊ô◊î ◊ë◊†◊™◊ï◊†◊ô◊ù
					startTime: stintStart,
					endTime: stintEnd,
					duration: currentStintDuration
				});

				driveTimeLeft -= currentStintDuration;
				currentTime = stintEnd;

				if (!isLastStint) {
					const pitStart = new Date(currentTime);
					const pitEnd = new Date(currentTime.getTime() + pitTimeMs);
					timeline.push({
						type: 'pit',
						pitNumber: i + 1,
						duration: pitTimeMs,
						startTime: pitStart,
						endTime: pitEnd
					});
					currentTime = pitEnd;
				}
			}

			cachedStrategyData = {
				timeline: timeline,
				driverSchedule: driverStats,
				startTime: startTimeObj,
				generatedAt: new Date()
			};
			
			previewData = cachedStrategyData; 

			if (shouldRender) {
				if (typeof renderPreview === 'function') {
					try {
						renderPreview(); 
						document.getElementById('previewScreen')?.classList.remove('hidden');
						document.getElementById('setupScreen')?.classList.add('hidden');
					} catch (e) { console.error("Render failed", e); }
				}
			}
			
			return true;
		}

		function showStrategyModal(strategies) {
			const list = document.getElementById('strategyList');
			
			if (!strategies || strategies.length === 0) {
				list.innerHTML = '<p class="text-gray-500 text-center py-8">No saved strategies yet</p>';
			} else {
				list.innerHTML = strategies.map(s => `
					<div class="bg-navy-800 p-3 rounded-lg border border-gray-700 hover:border-ice cursor-pointer transition"
						onclick="loadStrategy(${s.id})">
						<div class="flex justify-between items-start mb-2">
							<span class="font-bold text-white">${s.name}</span>
							<span class="text-xs text-gray-500">${new Date(s.createdAt).toLocaleDateString()}</span>
						</div>
						<div class="flex gap-4 text-xs text-gray-400">
							<span>‚è±Ô∏è ${formatTime(s.raceDuration)}</span>
							<span>üîß ${s.requiredStops} stops</span>
							<span>üë• ${s.drivers?.length || '?'} drivers</span>
						</div>
						<div class="mt-2 text-xs text-gray-500">
							${s.drivers?.map(d => d.name).join(', ') || ''}
						</div>
					</div>
				`).join('');
			}
			
			document.getElementById('strategyModal').classList.remove('hidden');
		}

		function closeStrategyModal() {
			document.getElementById('strategyModal').classList.add('hidden');
		}

		function updatePreview() {
			const startTimeInput = document.getElementById('raceStartTime').value;
			if (!startTimeInput) return;
			
			const [hours, minutes] = startTimeInput.split(':').map(Number);
			const startDate = new Date();
			startDate.setHours(hours, minutes, 0, 0);
			
			previewData.startTime = startDate;
			
			// 1. Calculate the TOTAL "Budget" for driving
			const totalRaceMs = config.raceMs;
			const pitTimeMs = config.minPitSec * 1000;
			const stopsRequired = config.reqStops;
			const stintsRequired = stopsRequired + 1;
			
			// Pit stops happen between stints, so Total Pits = Stints - 1
			// Note: If stopsRequired is strictly enforced, ensure logic aligns. 
			// Usually N stops means N+1 stints.
			const totalPitTime = stopsRequired * pitTimeMs; 
			const totalDrivingBudget = totalRaceMs - totalPitTime;
			
			if (totalDrivingBudget <= 0) {
				alert('Error: Pit time exceeds race duration!');
				return;
			}

			// Constraints
			const safeMaxStintMs = config.maxStintMs - 60000; // Max - 1 min
			const minStintMs = config.minStintMs;
			const pitClosedStartMs = config.pitClosedStartMs || 0;
			const pitClosedEndMs = config.pitClosedEndMs || 0;

			// 2. Initialize all stints with EQUAL duration (Average)
			// This guarantees mathematically that Sum(Stints) + Sum(Pits) = RaceDuration
			let durations = new Array(stintsRequired).fill(Math.floor(totalDrivingBudget / stintsRequired));
			
			// Distribute remainder ms to make it exact
			let remainder = totalDrivingBudget % stintsRequired;
			for(let i=0; i<remainder; i++) durations[i]++;

			// 3. APPLY LOGIC: Front-Load early stints, shorten later ones
			// We try to push early stints to SafeMax, taking time from later stints
			
			const frontLoadCount = Math.ceil(stintsRequired * 0.4); // Push first 40% of stints
			
			for (let i = 0; i < stintsRequired; i++) {
				// Don't touch the very last stint yet (it has special constraints)
				if (i === stintsRequired - 1) continue;

				let targetDur = durations[i];
				
				// If it's an early stint, aim for SafeMax
				if (i < frontLoadCount) {
					targetDur = safeMaxStintMs;
				}
				
				// Handle Pit Closed Start constraint for first stint
				if (i === 0) {
					targetDur = Math.max(targetDur, pitClosedStartMs);
				}
				
				// How much do we want to add?
				let wantedToAdd = targetDur - durations[i];
				
				if (wantedToAdd > 0) {
					// Try to "steal" this time from future stints (starting from the end backwards)
					// We leave the last stint alone for now unless necessary, to keep it flexible for PitClosedEnd
					let stolenAmount = 0;
					
					// Iterate backwards from second-to-last down to i+1
					for (let j = stintsRequired - 2; j > i; j--) {
						if (wantedToAdd <= 0) break;
						
						let available = durations[j] - minStintMs;
						if (available > 0) {
							let take = Math.min(available, wantedToAdd);
							durations[j] -= take;
							stolenAmount += take;
							wantedToAdd -= take;
						}
					}
					
					// Add what we managed to steal to the current stint
					durations[i] += stolenAmount;
				}
			}

			// 4. Validate Last Stint (Pit Closed End)
			// The last stint MUST be >= PitClosedEnd
			const lastIdx = stintsRequired - 1;
			if (durations[lastIdx] < pitClosedEndMs) {
				const deficit = pitClosedEndMs - durations[lastIdx];
				
				// We need to find 'deficit' time from previous stints (starting from the beginning this time)
				// to give to the last stint
				let collected = 0;
				for (let i = 0; i < lastIdx; i++) {
					if (deficit <= 0) break;
					
					// If first stint, respect PitClosedStart
					let limit = (i === 0) ? Math.max(minStintMs, pitClosedStartMs) : minStintMs;
					
					let available = durations[i] - limit;
					if (available > 0) {
						let take = Math.min(available, deficit);
						durations[i] -= take;
						collected += take;
						deficit -= take;
					}
				}
				durations[lastIdx] += collected;
			}

			// 5. Final check for AI overrides (optional, applies mostly to driver selection, not timing in this fix)
			// If you want AI to override durations, apply it here, but verify total sum matches budget.

			// ========== RENDER DATA ==========
			const driversCount = drivers.length;
			let driverSchedule = drivers.map((d, idx) => ({
				name: d.name,
				color: d.color || `hsl(${(idx * 360 / driversCount)}, 70%, 50%)`,
				stints: [],
				totalTime: 0
			}));

			const timeline = [];
			let currentTime = 0;
			
			// Get starter driver index
			const starterRadio = document.querySelector('.starter-radio:checked');
			const allRadios = document.querySelectorAll('.starter-radio');
			window.previewStarterIdx = starterRadio ? Array.from(allRadios).indexOf(starterRadio) : 0;
			
			for (let s = 0; s < stintsRequired; s++) {
				const driverIdx = (window.previewStarterIdx + s) % driversCount;
				const isLastStint = s === stintsRequired - 1;
				let stintDuration = durations[s];
				
				// Add stint to timeline
				timeline.push({
					type: 'stint',
					stintNumber: s + 1,
					driverIdx,
					driverName: drivers[driverIdx].name,
					color: driverSchedule[driverIdx].color,
					start: currentTime,
					duration: stintDuration,
					startTime: new Date(startDate.getTime() + currentTime),
					endTime: new Date(startDate.getTime() + currentTime + stintDuration)
				});
				
				// Update driver stats
				driverSchedule[driverIdx].stints.push({
					number: driverSchedule[driverIdx].stints.length + 1,
					globalNumber: s + 1,
					start: currentTime,
					duration: stintDuration,
					startTime: new Date(startDate.getTime() + currentTime),
					endTime: new Date(startDate.getTime() + currentTime + stintDuration)
				});
				driverSchedule[driverIdx].totalTime += stintDuration;
				
				currentTime += stintDuration;
				
				// Add pit stop (except after last stint)
				if (!isLastStint) {
					timeline.push({
						type: 'pit',
						pitNumber: s + 1,
						start: currentTime,
						duration: pitTimeMs,
						startTime: new Date(startDate.getTime() + currentTime)
					});
					currentTime += pitTimeMs;
				}
			}
			
			previewData.timeline = timeline;
			previewData.driverSchedule = driverSchedule;
			
			renderPreview();
		}

		function renderPreview() {
			// ◊ë◊ì◊ô◊ß◊™ ◊™◊ß◊ô◊†◊ï◊™ ◊®◊ê◊©◊ï◊†◊ô◊™ - ◊ê◊ù ◊ê◊ô◊ü ◊†◊™◊ï◊†◊ô◊ù, ◊ú◊ê ◊¢◊ï◊©◊ô◊ù ◊õ◊ú◊ï◊ù
			if (!previewData || !previewData.timeline) return;

			const timeline = previewData.timeline;
			
			// ◊ß◊®◊ô◊ê◊™ ◊ê◊ï◊®◊ö ◊î◊û◊ô◊®◊ï◊• ◊û◊î◊î◊í◊ì◊®◊ï◊™ (◊ë◊©◊ë◊ô◊ú ◊ó◊ô◊©◊ï◊ë ◊î"◊ë◊†◊ß")
			const raceInput = document.getElementById('raceDuration');
			const raceMs = raceInput ? parseFloat(raceInput.value) * 60000 : config.raceMs;
			
			// ◊ó◊ô◊©◊ï◊ë ◊î◊ñ◊û◊ü ◊î◊û◊™◊ï◊õ◊†◊ü ◊ë◊§◊ï◊¢◊ú (◊°◊õ◊ï◊ù ◊õ◊ú ◊î◊°◊ò◊ô◊†◊ò◊ô◊ù ◊ï◊î◊¢◊¶◊ô◊®◊ï◊™ ◊ë◊ò◊ô◊ô◊û◊ú◊ô◊ô◊ü)
			const plannedTotalMs = timeline.reduce((sum, t) => sum + t.duration, 0);
			
			// ◊ó◊ô◊©◊ï◊ë ◊î◊î◊§◊®◊© ("◊ë◊†◊ß ◊ì◊ß◊ï◊™")
			const timeDiffMs = raceMs - plannedTotalMs; 
			const diffMin = Math.round(timeDiffMs / 60000);

			// ◊°◊ô◊†◊ï◊ü ◊°◊ò◊ô◊†◊ò◊ô◊ù ◊ë◊ú◊ë◊ì (◊ë◊ú◊ô ◊¢◊¶◊ô◊®◊ï◊™) ◊ú◊¶◊ï◊®◊ö ◊î◊™◊¶◊ï◊í◊î ◊ï◊î◊ó◊ô◊©◊ï◊ë◊ô◊ù
			const actualStints = timeline.filter(t => t.type === 'stint');
			const actualStops = timeline.filter(t => t.type === 'pit').length;
			const actualDrivingTime = actualStints.reduce((sum, s) => sum + s.duration, 0);
			const actualAvgStint = actualStints.length > 0 ? actualDrivingTime / actualStints.length : 0;

			// ◊ß◊ë◊ú◊™ ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊û◊î-DOM
			const scheduleEl = document.getElementById('driverScheduleList');
			const summaryEl = document.getElementById('strategySummary');
			const timeStartEl = document.getElementById('timelineStart');
			const timeEndEl = document.getElementById('timelineEnd');
			
			// ◊ê◊ù ◊ê◊ó◊ì ◊î◊ê◊ú◊û◊†◊ò◊ô◊ù ◊ó◊°◊® ◊ë◊ì◊£, ◊¢◊ï◊¶◊®◊ô◊ù ◊õ◊ì◊ô ◊ú◊û◊†◊ï◊¢ ◊©◊í◊ô◊ê◊ï◊™
			if (!scheduleEl || !summaryEl || !timeStartEl || !timeEndEl) return;

			// ◊¢◊ì◊õ◊ï◊ü ◊™◊¶◊ï◊í◊™ ◊ñ◊û◊†◊ô ◊î◊™◊ó◊ú◊î ◊ï◊°◊ô◊ï◊ù
			const startTime = previewData.startTime instanceof Date 
				? previewData.startTime 
				: new Date(previewData.startTime);
			const endTime = new Date(startTime.getTime() + plannedTotalMs);
			
			timeStartEl.innerText = formatTimeOfDay(startTime);
			timeEndEl.innerText = formatTimeOfDay(endTime);

			// ◊ú◊ï◊í◊ô◊ß◊î ◊ú◊õ◊ô◊ï◊ï◊ü ◊î◊ó◊• (◊™◊û◊ô◊õ◊î ◊ë◊¢◊ë◊®◊ô◊™/RTL)
			const isRTL = document.documentElement.dir === 'rtl';
			const arrowIcon = isRTL ? '‚Üê' : '‚Üí'; 

			// ◊ß◊®◊ô◊ê◊™ ◊î◊í◊ì◊®◊ï◊™ ◊ú◊¶◊ï◊®◊ö ◊ê◊ô◊û◊ï◊™ (Validation)
			const allowDouble = document.getElementById('allowDoubleStints')?.checked || false;
			const minStintInput = document.getElementById('minStint');
			const maxStintInput = document.getElementById('maxStint');
			const minStintMs = minStintInput ? parseFloat(minStintInput.value) * 60000 : 0;
			const maxStintMs = maxStintInput ? parseFloat(maxStintInput.value) * 60000 : Infinity;

			// --- 1. ◊ô◊¶◊ô◊®◊™ ◊î◊™◊®◊ê◊™ "◊ë◊†◊ß ◊ì◊ß◊ï◊™" ---
			let bankHtml = '';
			if (Math.abs(diffMin) > 1) { // ◊û◊¶◊ô◊í ◊î◊™◊®◊ê◊î ◊®◊ß ◊ê◊ù ◊î◊°◊ò◊ô◊ô◊î ◊í◊ì◊ï◊ú◊î ◊û◊ì◊ß◊î
				const colorClass = diffMin > 0 ? 'text-red-400' : 'text-yellow-400';
				const msg = diffMin > 0 
					? `‚ö†Ô∏è ◊ó◊°◊®◊ô◊ù ${diffMin} ◊ì◊ß◊ï◊™ ◊ú◊î◊©◊ú◊û◊™ ◊î◊û◊ô◊®◊ï◊•!` 
					: `‚ö†Ô∏è ◊ó◊®◊ô◊í◊î ◊©◊ú ${Math.abs(diffMin)} ◊ì◊ß◊ï◊™ ◊û◊¢◊ë◊® ◊ú◊ñ◊û◊ü ◊î◊û◊ô◊®◊ï◊•!`;
				
				bankHtml = `<div class="bg-navy-800 border border-navy-600 p-2 rounded mb-4 text-center text-sm font-bold animate-pulse ${colorClass}">${msg}</div>`;
			}

			// --- 2. ◊ô◊¶◊ô◊®◊™ ◊®◊©◊ô◊û◊™ ◊î◊°◊ò◊ô◊†◊ò◊ô◊ù (HTML) ---
			const listHtml = actualStints.map((stint, index) => {
				// ◊ë◊ì◊ô◊ß◊î ◊ê◊ù ◊ô◊© ◊¢◊¶◊ô◊®◊î ◊ê◊ó◊®◊ô ◊î◊°◊ò◊ô◊†◊ò ◊î◊ñ◊î
				const pitAfter = timeline.find(t => t.type === 'pit' && t.pitNumber === stint.stintNumber);
				const stintStart = stint.startTime instanceof Date ? stint.startTime : new Date(stint.startTime);
				const stintEnd = stint.endTime instanceof Date ? stint.endTime : new Date(stint.endTime);
				const durationMin = Math.round(stint.duration / 60000);

				// ◊ë◊ì◊ô◊ß◊î 1: ◊î◊ê◊ù ◊ô◊© ◊ì◊ê◊ë◊ú ◊°◊ò◊ô◊†◊ò ◊ú◊ê ◊ó◊ï◊ß◊ô?
				let warningBorder = '';
				if (index > 0 && !allowDouble) {
					const prevStint = actualStints[index - 1];
					// ◊ê◊ù ◊î◊†◊î◊í ◊î◊†◊ï◊õ◊ó◊ô ◊î◊ï◊ê ◊ê◊ï◊™◊ï ◊†◊î◊í ◊õ◊û◊ï ◊û◊ß◊ï◊ì◊ù, ◊ï◊î◊ì◊ê◊ë◊ú ◊ê◊°◊ï◊®
					if (prevStint.driverIdx === stint.driverIdx || prevStint.driverName === stint.driverName) {
						warningBorder = 'border-2 border-red-500 shadow-[0_0_10px_rgba(239,68,68,0.5)]'; 
					}
				}

				// ◊ë◊ì◊ô◊ß◊î 2: ◊ó◊®◊ô◊í◊î ◊û◊û◊ô◊†◊ô◊û◊ï◊ù/◊û◊ß◊°◊ô◊û◊ï◊ù ◊ñ◊û◊ü ◊°◊ò◊ô◊†◊ò
				let timeColor = 'text-neon';
				if (stint.duration < minStintMs || stint.duration > maxStintMs) {
					timeColor = 'text-red-500 font-bold'; // ◊¶◊ï◊ë◊¢ ◊ê◊™ ◊î◊û◊°◊§◊® ◊ë◊ê◊ì◊ï◊ù
				}

				// ◊ë◊†◊ô◊ô◊™ ◊î◊©◊ï◊®◊î
				return `
					<div class="stint-row flex items-center gap-2 bg-navy-950 p-2 rounded border-l-4 hover:bg-navy-900 transition mb-1 ${warningBorder}" 
						style="border-left-color: ${stint.color}"
						draggable="true"
						data-index="${index}"
						ondragstart="handleDragStart(event)"
						ondragover="handleDragOver(event)"
						ondragleave="handleDragLeave(event)"
						ondrop="handleDrop(event)">
						
						<div class="cursor-grab text-gray-600 hover:text-white px-1">
							<i class="fas fa-grip-vertical text-xs"></i>
						</div>

						<span class="text-xs text-gray-500 w-6">#${stint.stintNumber}</span>
						
						<div class="flex-1 min-w-0 pointer-events-none"> <span class="font-bold text-white block truncate">${stint.driverName}</span>
							<div class="flex items-center gap-1 text-[10px] text-gray-400">
								<span>${formatTimeOfDay(stintStart)}</span>
								<span class="text-gray-600 font-bold">${arrowIcon}</span>
								<span>${formatTimeOfDay(stintEnd)}</span>
							</div>
						</div>

						<div class="flex items-center gap-1">
							<input type="number" 
								value="${durationMin}" 
								class="w-12 bg-navy-800 border border-navy-600 rounded text-center text-sm font-mono focus:border-neon focus:outline-none ${timeColor}"
								onchange="updateStintDuration(${index}, this.value)">
							<span class="text-[10px] text-gray-500">min</span>
						</div>
						
						${pitAfter ? '<span class="text-xs text-gold ml-1" title="Pit Stop">üîß</span>' : '<span class="text-xs text-gray-600 ml-1">üèÅ</span>'}
					</div>
				`;
			}).join('');

			// ◊î◊ñ◊®◊ß◊™ ◊î-HTML ◊©◊ú ◊î◊®◊©◊ô◊û◊î ◊ï◊î◊ë◊†◊ß
			scheduleEl.innerHTML = `
				<div class="mb-6">
					<h4 class="text-sm font-bold text-gray-400 mb-2 flex items-center gap-2 justify-between">
						<span><i class="fas fa-list-ol"></i> ${typeof t === 'function' ? t('scheduleTitle') : 'Schedule'}</span>
					</h4>
					${bankHtml}
					<div class="space-y-1" id="stintListContainer">
						${listHtml}
					</div>
				</div>
				
				<div>
					<h4 class="text-sm font-bold text-gray-400 mb-2 flex items-center gap-2">
						<i class="fas fa-users"></i> ${typeof t === 'function' ? t('summaryTitle') : 'Driver Summary'}
					</h4>
					<div class="grid grid-cols-2 gap-2">
						${previewData.driverSchedule.map((driver) => {
							// ◊ó◊ô◊©◊ï◊ë ◊ì◊ô◊†◊û◊ô ◊©◊ú ◊õ◊û◊ï◊™ ◊î◊°◊ò◊ô◊†◊ò◊ô◊ù ◊ú◊†◊î◊í ◊û◊î◊®◊©◊ô◊û◊î ◊î◊†◊ï◊õ◊ó◊ô◊™
							const drvStints = actualStints.filter(s => s.driverName === driver.name);
							const stintCount = drvStints.length;
							const avgMin = stintCount > 0 ? (driver.totalTime / stintCount / 60000).toFixed(0) : 0;

							return `
							<div class="bg-navy-800 p-2 rounded border-l-2" style="border-color: ${driver.color}">
								<div class="flex justify-between items-center">
									<span class="text-xs text-white font-bold truncate pr-2">${driver.name}</span>
									<span class="text-xs text-ice font-mono">${formatTime(driver.totalTime)}</span>
								</div>
								<div class="flex justify-between mt-1 text-[10px] text-gray-500">
									<span>${stintCount} stints</span>
									<span>Avg: ${avgMin}m</span>
								</div>
							</div>
							`;
						}).join('')}
					</div>
				</div>
			`;
			
			// --- 3. ◊¢◊ì◊õ◊ï◊ü ◊ß◊ï◊ë◊ô◊ï◊™ ◊î◊°◊ô◊õ◊ï◊ù ◊ú◊û◊ò◊î (Strategy Summary) ---
			summaryEl.innerHTML = `
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Race Duration</div>
					<div class="text-xl font-bold text-ice">${formatTime(raceMs)}</div>
				</div>
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Pit Stops</div>
					<div class="text-xl font-bold text-neon">${actualStops}</div>
				</div>
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Total Stints</div>
					<div class="text-xl font-bold text-gold">${actualStints.length}</div>
				</div>
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Avg Stint</div>
					<div class="text-xl font-bold text-white">${formatTime(actualAvgStint)}</div>
				</div>
			`;
		}

		function moveStint(stintIndex, direction) {
			if (!previewData || !previewData.timeline) return;

			// Filter to get only stints indices in the timeline array
			const allEvents = previewData.timeline;
			const stintIndices = [];
			allEvents.forEach((evt, idx) => {
				if (evt.type === 'stint') stintIndices.push(idx);
			});

			const currentRealIdx = stintIndices[stintIndex];
			const targetRealIdx = stintIndices[stintIndex + direction];

			if (targetRealIdx === undefined) return;

			// Swap driver info but keep duration/schedule slots
			const currentStint = allEvents[currentRealIdx];
			const targetStint = allEvents[targetRealIdx];

			const temp = {
				driverIdx: currentStint.driverIdx,
				driverName: currentStint.driverName,
				color: currentStint.color,
				note: currentStint.note
			};

			currentStint.driverIdx = targetStint.driverIdx;
			currentStint.driverName = targetStint.driverName;
			currentStint.color = targetStint.color;
			currentStint.note = targetStint.note;

			targetStint.driverIdx = temp.driverIdx;
			targetStint.driverName = temp.driverName;
			targetStint.color = temp.color;
			targetStint.note = temp.note;

			// Recalculate stats
			recalculateDriverStatsFromTimeline();
			
			// Re-render
			renderPreview();
		}

		// ==================== DRAG AND DROP LOGIC ====================
		let draggedStintIndex = null;

		function handleDragStart(e) {
			// ◊©◊ï◊û◊®◊ô◊ù ◊ê◊™ ◊î◊ê◊ô◊†◊ì◊ß◊° ◊©◊ú ◊î◊ê◊ú◊û◊†◊ò ◊©◊†◊í◊®◊®
			draggedStintIndex = parseInt(e.currentTarget.getAttribute('data-index'));
			e.dataTransfer.effectAllowed = 'move';
			e.dataTransfer.setData('text/plain', draggedStintIndex);
			
			// ◊¢◊ô◊¶◊ï◊ë ◊ú◊ê◊ú◊û◊†◊ò ◊©◊†◊í◊®◊®
			e.currentTarget.classList.add('draggable-source');
		}

		function handleDragOver(e) {
			// ◊ó◊ï◊ë◊î ◊õ◊ì◊ô ◊ú◊ê◊§◊©◊® Drop
			e.preventDefault();
			e.dataTransfer.dropEffect = 'move';
			
			// ◊î◊ï◊°◊§◊™ ◊¢◊ô◊¶◊ï◊ë ◊ú◊ê◊ú◊û◊†◊ò ◊©◊¢◊ú◊ô◊ï ◊¢◊ï◊û◊ì◊ô◊ù
			const row = e.currentTarget;
			if (!row.classList.contains('drag-over')) {
				row.classList.add('drag-over');
			}
		}

		function handleDragLeave(e) {
			// ◊î◊°◊®◊™ ◊î◊¢◊ô◊¶◊ï◊ë ◊õ◊©◊ô◊ï◊¶◊ê◊ô◊ù ◊û◊î◊ê◊ú◊û◊†◊ò
			e.currentTarget.classList.remove('drag-over');
		}

		function handleDrop(e) {
			e.preventDefault();
			e.stopPropagation(); // ◊û◊ï◊†◊¢ ◊ë◊¢◊ô◊ï◊™ ◊ë◊ì◊§◊ì◊§◊†◊ô◊ù ◊û◊°◊ï◊ô◊û◊ô◊ù

			const targetRow = e.currentTarget;
			targetRow.classList.remove('drag-over');
			
			// ◊î◊°◊®◊™ ◊¢◊ô◊¶◊ï◊ë ◊û◊î◊û◊ß◊ï◊®
			const sourceRow = document.querySelector('.draggable-source');
			if (sourceRow) sourceRow.classList.remove('draggable-source');

			const targetIndex = parseInt(targetRow.getAttribute('data-index'));

			// ◊ê◊ù ◊í◊®◊®◊†◊ï ◊ú◊ê◊ï◊™◊ï ◊û◊ß◊ï◊ù, ◊ú◊ê ◊¢◊ï◊©◊ô◊ù ◊õ◊ú◊ï◊ù
			if (draggedStintIndex === null || draggedStintIndex === targetIndex) {
				return;
			}

			// ◊ë◊ô◊¶◊ï◊¢ ◊î◊î◊ó◊ú◊§◊î (Swap)
			swapStints(draggedStintIndex, targetIndex);
			
			draggedStintIndex = null;
		}

		function swapStints(fromIndex, toIndex) {
			if (!previewData || !previewData.timeline) return;

			// ◊ê◊†◊ó◊†◊ï ◊¢◊ï◊ë◊ì◊ô◊ù ◊®◊ß ◊¢◊ú ◊°◊ò◊ô◊†◊ò◊ô◊ù (◊û◊°◊†◊†◊ô◊ù ◊ê◊™ ◊î◊§◊ô◊ò◊°)
			const allEvents = previewData.timeline;
			const stintIndices = [];
			
			// ◊û◊ô◊§◊ï◊ô ◊ê◊ô◊†◊ì◊ß◊°◊ô◊ù ◊ê◊û◊ô◊™◊ô◊ô◊ù ◊ë-timeline
			allEvents.forEach((evt, idx) => {
				if (evt.type === 'stint') stintIndices.push(idx);
			});

			const realFromIdx = stintIndices[fromIndex];
			const realToIdx = stintIndices[toIndex];

			if (realFromIdx === undefined || realToIdx === undefined) return;

			// ◊î◊ó◊ú◊§◊™ ◊†◊™◊ï◊†◊ô ◊î◊†◊î◊í ◊ï◊î◊¶◊ë◊¢ (◊©◊ï◊û◊®◊ô◊ù ◊ê◊™ ◊î◊ñ◊û◊†◊ô◊ù ◊ë◊û◊ß◊ï◊û◊ù)
			const sourceStint = allEvents[realFromIdx];
			const targetStint = allEvents[realToIdx];

			const temp = {
				driverIdx: sourceStint.driverIdx,
				driverName: sourceStint.driverName,
				color: sourceStint.color,
				note: sourceStint.note
			};

			sourceStint.driverIdx = targetStint.driverIdx;
			sourceStint.driverName = targetStint.driverName;
			sourceStint.color = targetStint.color;
			sourceStint.note = targetStint.note;

			targetStint.driverIdx = temp.driverIdx;
			targetStint.driverName = temp.driverName;
			targetStint.color = temp.color;
			targetStint.note = temp.note;

			// ◊ó◊ô◊©◊ï◊ë ◊û◊ó◊ì◊© ◊©◊ú ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™
			recalculateDriverStatsFromTimeline();
			
			// ◊®◊ô◊†◊ì◊ï◊® ◊û◊ó◊ì◊©
			renderPreview();
			
			// ◊ë◊ï◊†◊ï◊°: ◊î◊§◊¢◊ú◊™ ◊®◊ò◊ò ◊ë◊û◊ï◊ë◊ô◊ô◊ú (◊ê◊ù ◊†◊™◊û◊ö) ◊ú◊ê◊ô◊©◊ï◊®
			if (navigator.vibrate) navigator.vibrate(50);
		}

		// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊¢◊ì◊õ◊ï◊ü ◊û◊©◊ö ◊°◊ò◊ô◊†◊ò (◊û◊ï◊§◊¢◊ú◊™ ◊û◊î-Input)
		function updateStintDuration(stintIndex, newDurationMin) {
			if (!previewData || !previewData.timeline) return;

			const newDurationMs = parseInt(newDurationMin) * 60000;
			if (isNaN(newDurationMs) || newDurationMs <= 0) return;

			// ◊û◊¶◊ô◊ê◊™ ◊î◊°◊ò◊ô◊†◊ò ◊î◊†◊õ◊ï◊ü ◊ë◊û◊¢◊®◊ö ◊î◊û◊ú◊ê (◊õ◊ï◊ú◊ú ◊§◊ô◊ò◊ô◊ù)
			const stintsOnly = previewData.timeline.filter(t => t.type === 'stint');
			const targetStint = stintsOnly[stintIndex];
			
			if (targetStint) {
				targetStint.duration = newDurationMs;
				
				// ◊ó◊ô◊©◊ï◊ë ◊û◊ó◊ì◊© ◊©◊ú ◊õ◊ú ◊î◊ñ◊û◊†◊ô◊ù ◊ë◊û◊¢◊®◊õ◊™
				recalculateTimelineTimes();
				
				// ◊®◊ô◊†◊ì◊ï◊® ◊û◊ó◊ì◊© (◊õ◊ì◊ô ◊ú◊¢◊ì◊õ◊ü ◊ê◊™ ◊î◊ë◊†◊ß ◊ï◊ê◊™ ◊ñ◊û◊†◊ô ◊î◊î◊™◊ó◊ú◊î/◊°◊ô◊ï◊ù)
				renderPreview();
			}
		}

		// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊ó◊ô◊©◊ï◊ë ◊û◊ó◊ì◊© ◊©◊ú ◊ñ◊û◊†◊ô ◊î◊™◊ó◊ú◊î ◊ï◊°◊ô◊ï◊ù ◊ú◊§◊ô ◊î◊û◊©◊õ◊ô◊ù ◊î◊ó◊ì◊©◊ô◊ù
		function recalculateTimelineTimes() {
			let currentTime = new Date(previewData.startTime);
			
			previewData.timeline.forEach(item => {
				item.startTime = new Date(currentTime);
				item.endTime = new Date(currentTime.getTime() + item.duration);
				currentTime = item.endTime;
			});

			// ◊¢◊ì◊õ◊ï◊ü ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊†◊î◊í◊ô◊ù ◊û◊ó◊ì◊©
			recalculateDriverStatsFromTimeline();
		}

		function recalculateDriverStatsFromTimeline() {
			// ◊ê◊ô◊§◊ï◊° ◊û◊ï◊†◊ô◊ù
			previewData.driverSchedule.forEach(d => d.totalTime = 0);
			
			// ◊°◊õ◊ô◊û◊î ◊û◊ó◊ì◊©
			previewData.timeline.forEach(t => {
				if (t.type === 'stint') {
					const driver = previewData.driverSchedule.find(d => d.name === t.driverName); // ◊ê◊ï ◊ú◊§◊ô ID ◊ê◊ù ◊ô◊©
					if (driver) {
						driver.totalTime += t.duration;
					}
				}
			});
		}

		function formatTimeOfDay(date) {
			return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
		}
		
		function formatTime(ms) {
			if (!ms) return '--:--';
			const totalSec = Math.floor(ms / 1000);
			const hours = Math.floor(totalSec / 3600);
			const mins = Math.floor((totalSec % 3600) / 60);
			const secs = totalSec % 60;
			
			if (hours > 0) {
				return `${hours}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
			}
			return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
		}

		function closePreview() {
			document.getElementById('previewScreen').classList.add('hidden');
			document.getElementById('setupScreen').classList.remove('hidden');
		}

		function editStrategy() {
			closePreview();
		}
		
		// ==================== DEMO MODE ====================
		function startDemoMode() {
			liveTimingConfig.demoMode = true;
			liveTimingConfig.enabled = true;
			
			initializeDemoCompetitors();
			
			document.getElementById('liveTimingStatus').innerText = "üéÆ Demo Mode Active";
			document.getElementById('liveTimingStatus').className = "text-[10px] text-neon text-center font-bold";
		}
		
		function initializeDemoCompetitors() {
			const teamNames = [
				'Your Team', 'Racing Stars', 'Speed Demons', 'Track Masters', 
				'Nitro Force', 'Apex Racing', 'Thunder Karts', 'Pro Racers',
				'Fast Lane', 'Grid Warriors'
			];
			
			demoState.competitors = teamNames.map((name, idx) => ({
				name: name,
				position: idx + 1,
				previousPosition: idx + 1,
				laps: 0,
				lastLap: null,
				bestLap: null,
				baseLapTime: null,
				totalRaceTime: 0,
				pitStops: 0,
				inPit: false,
				isOurTeam: idx === 0
			}));
			
			demoState.competitors.sort(() => Math.random() - 0.5);
			demoState.competitors.forEach((c, i) => {
				c.position = i + 1;
				c.previousPosition = i + 1;
			});
		}
		
		function updateDemoData() {
			if (!liveTimingConfig.demoMode || !state.isRunning) return;
			
			const raceElapsed = Date.now() - state.startTime;
			
			demoState.competitors.forEach((comp, idx) => {
				if (!comp.baseLapTime) {
					comp.baseLapTime = 61000 + (idx * 400) + (Math.random() * 500);
				}
				
				const expectedLaps = Math.floor(raceElapsed / comp.baseLapTime);
				
				if (expectedLaps > comp.laps) {
					comp.laps = expectedLaps;
					comp.lastLap = comp.baseLapTime + (Math.random() - 0.5) * 1000;
					
					if (!comp.bestLap || comp.lastLap < comp.bestLap) {
						comp.bestLap = comp.lastLap;
					}
				}
				
				const pitInterval = 50 * 60 * 1000 + (idx * 2 * 60 * 1000);
				const expectedPits = Math.floor(raceElapsed / pitInterval);
				if (expectedPits > comp.pitStops) {
					comp.pitStops = expectedPits;
				}
				
				const pitTimePenalty = 120000;
				const timeSinceLastPit = raceElapsed - (comp.pitStops * pitInterval);
				comp.inPit = timeSinceLastPit >= 0 && timeSinceLastPit < pitTimePenalty && comp.pitStops > 0;
				
				let currentPitPenalty = comp.pitStops * pitTimePenalty;
				if (comp.inPit) {
					currentPitPenalty = ((comp.pitStops - 1) * pitTimePenalty) + timeSinceLastPit;
				}
				
				comp.totalRaceTime = (comp.laps * comp.baseLapTime) + currentPitPenalty;
			});
			
			demoState.competitors.sort((a, b) => {
				if (b.laps !== a.laps) return b.laps - a.laps;
				return a.totalRaceTime - b.totalRaceTime;
			});
			
			const leader = demoState.competitors[0];
			demoState.competitors.forEach((c, i) => {
				c.previousPosition = c.position;
				c.position = i + 1;
				
				if (i === 0) {
					c.gapToLeader = 0;
				} else {
					c.gapToLeader = c.totalRaceTime - leader.totalRaceTime;
				}
			});
			
			// Update liveData with our team
			const ourTeam = demoState.competitors.find(c => c.isOurTeam);
			if (ourTeam) {
				liveData.previousPosition = liveData.position;
				liveData.position = ourTeam.position;
				liveData.lastLap = ourTeam.lastLap;
				liveData.bestLap = ourTeam.bestLap;
				liveData.laps = ourTeam.laps;
				liveData.gapToLeader = ourTeam.gapToLeader;
			}
			
			liveData.competitors = demoState.competitors;
			updateLiveTimingUI();
		}
		
		function formatLapTime(ms) {
			if (!ms) return '--';
			const totalSec = ms / 1000;
			const min = Math.floor(totalSec / 60);
			const sec = (totalSec % 60).toFixed(3);
			return `${min}:${sec.padStart(6, '0')}`;
		}
		
        function updateLiveTimingUI() {
			if (!liveTimingConfig.enabled) return;
			
			const panel = document.getElementById('liveTimingPanel');
			const indicator = document.getElementById('liveIndicator');
			if (panel) panel.classList.remove('hidden');
			if (indicator) indicator.classList.remove('hidden');
			
			const posEl = document.getElementById('livePosition');
			if (posEl) posEl.innerText = liveData.position || '-';
			
			const changeEl = document.getElementById('livePositionChange');
			if (changeEl && liveData.previousPosition && liveData.position) {
				const diff = liveData.previousPosition - liveData.position;
				if (diff > 0) {
					changeEl.innerText = `‚ñ≤ ${diff}`;
					changeEl.className = 'text-[10px] position-up';
				} else if (diff < 0) {
					changeEl.innerText = `‚ñº ${Math.abs(diff)}`;
					changeEl.className = 'text-[10px] position-down';
				} else {
					changeEl.innerText = '‚Äî';
					changeEl.className = 'text-[10px] position-same';
				}
			}
			
			const lastLapEl = document.getElementById('liveLastLap');
			if (lastLapEl && liveData.lastLap) lastLapEl.innerText = formatLapTime(liveData.lastLap);
			
			const bestLapEl = document.getElementById('liveBestLap');
			if (bestLapEl && liveData.bestLap) bestLapEl.innerText = formatLapTime(liveData.bestLap);
			
			updateCompetitorsTable();
		}

		// ◊û◊©◊™◊†◊î ◊¢◊ñ◊® ◊í◊ú◊ï◊ë◊ú◊ô ◊ú◊©◊û◊ô◊®◊™ ◊ñ◊û◊ü ◊î◊î◊™◊ó◊ú◊î ◊õ◊ì◊ô ◊ú◊û◊†◊ï◊¢ ◊ß◊§◊ô◊¶◊ï◊™
		let cachedRaceStartTime = null;

		/**
		 * ◊û◊¢◊ì◊õ◊ü ◊ê◊™ ◊û◊¢◊®◊ö ◊î◊†◊î◊í◊ô◊ù ◊û◊î◊†◊™◊ï◊†◊ô◊ù ◊©◊¢◊ú ◊î◊û◊°◊ö
		 */
		// ◊¢◊ì◊õ◊ï◊ü ◊®◊©◊ô◊û◊™ ◊î◊†◊î◊í◊ô◊ù ◊û◊î-DOM ◊ú◊û◊©◊™◊†◊î ◊î◊í◊ú◊ï◊ë◊ú◊ô
		function updateDriversFromUI() {
			const inputs = document.querySelectorAll('.driver-input');
			const squads = document.querySelectorAll('.squad-toggle');
			const radios = document.querySelectorAll('.starter-radio');
			
			if (!inputs || inputs.length === 0) return;

			let starterIdx = 0;
			radios.forEach((r, i) => { if (r.checked) starterIdx = i; });

			// ◊ë◊†◊ô◊ô◊™ ◊î◊û◊¢◊®◊ö ◊û◊ó◊ì◊©
			drivers = Array.from(inputs).map((input, i) => {
				// ◊©◊û◊ô◊®◊™ ◊¶◊ë◊¢ ◊ß◊ô◊ô◊ù ◊ê◊ù ◊ô◊©, ◊ê◊ó◊®◊™ ◊ô◊¶◊ô◊®◊™ ◊ó◊ì◊©
				const existingColor = (drivers && drivers[i]) ? drivers[i].color : `hsl(${(i * 360 / inputs.length)}, 70%, 50%)`;
				
				return {
					name: input.value || `Driver ${i+1}`,
					isStarter: i === starterIdx,
					squad: squads[i]?.checked ? 'B' : 'A',
					color: existingColor,
					totalTime: 0,
					stints: 0
				};
			});
		}
		
		function updateCompetitorsTable() {
			const tableEl = document.getElementById('competitorsTable');
			if (!tableEl) return;
			
			if (!liveData.competitors || liveData.competitors.length === 0) {
				tableEl.innerHTML = `<div class="text-gray-500 text-center py-2">${t('waitingData')}</div>`;
				return;
			}
			
			// Find our team for gap calculations
			const ourTeam = liveData.competitors.find(c => c.isOurTeam);
			
			let html = '';
			liveData.competitors.slice(0, 10).forEach((comp, idx) => {
				const isUs = comp.isOurTeam;
				const isDanger = !isUs && liveData.position && Math.abs(comp.position - liveData.position) <= 2;
				
				let posClass = 'text-gray-400';
				if (comp.position === 1) posClass = 'text-gold';
				else if (comp.position === 2) posClass = 'text-silver';
				else if (comp.position === 3) posClass = 'text-bronze';
				
				let rowClass = 'competitor-row py-1 px-2 rounded flex justify-between items-center mb-1';
				if (isUs) rowClass += ' our-team';
				else if (isDanger) rowClass += ' danger-zone';
				
				const pitIndicator = comp.inPit ? '<span class="text-fuel animate-pulse">üîß</span>' : '';
				
				// Calculate gap display
				let gapDisplay = '';
				if (comp.position === 1) {
					gapDisplay = '<span class="text-gold">Leader</span>';
				} else if (comp.gapToLeader) {
					// If gap is more than a lap worth (~65 sec), show laps + seconds
					if (ourTeam && !isUs) {
						const gapToUs = comp.totalRaceTime - ourTeam.totalRaceTime;
						if (Math.abs(gapToUs) < 120000) {
							const gapSec = (gapToUs / 1000).toFixed(1);
							gapDisplay = gapToUs > 0 
								? `<span class="text-green-400">+${gapSec}s</span>` 
								: `<span class="text-red-400">${gapSec}s</span>`;
						} else {
							const lapDiff = ourTeam.laps - comp.laps;
							if (lapDiff !== 0) {
								gapDisplay = lapDiff > 0 
									? `<span class="text-green-400">+${lapDiff} lap${lapDiff > 1 ? 's' : ''}</span>`
									: `<span class="text-red-400">${lapDiff} lap${Math.abs(lapDiff) > 1 ? 's' : ''}</span>`;
							}
						}
					} else if (!isUs) {
						const gapSec = (comp.gapToLeader / 1000).toFixed(1);
						gapDisplay = `<span class="text-gray-500">+${gapSec}s</span>`;
					}
				}
				
				// Last lap time
				const lastLapDisplay = comp.lastLap ? `<span class="text-gray-400">${formatLapTime(comp.lastLap)}</span>` : '';
				
				html += `
					<div class="${rowClass}">
						<div class="flex items-center gap-2">
							<span class="${posClass} font-bold w-5">${comp.position}</span>
							<span class="text-white text-[11px]">${comp.name}</span>
							${pitIndicator}
						</div>
						<div class="flex items-center gap-2 text-[10px]">
							${lastLapDisplay}
							<span class="w-16 text-right">${gapDisplay}</span>
						</div>
					</div>
				`;
			});
			
			tableEl.innerHTML = html;

			// ‚úÖ ◊í◊ú◊ï◊ú ◊ú◊ß◊ë◊ï◊¶◊î ◊©◊ú◊†◊ï
			if (liveData.competitors.some(c => c.isOurTeam)) {
				setTimeout(scrollToOurTeam, 500);
			}
		}

		function scrollToOurTeam() {
			const rows = document.querySelectorAll('.competitor-row');
			let ourRow = null;
			
			rows.forEach(row => {
				if (row.classList.contains('our-team')) {
					ourRow = row;
				}
			});
			
			if (ourRow) {
				ourRow.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'nearest'
				});
				
				ourRow.classList.add('flash-alert');
				setTimeout(() => {
					ourRow.classList.remove('flash-alert');
				}, 2000);
				
				console.log('‚úÖ Auto-scrolled to our team');
			}
		}
		
		function startLiveTimingUpdates() {
			if (liveTimingConfig.demoMode) {
				liveTimingInterval = setInterval(updateDemoData, 1000);
			} else if (liveTimingConfig.url) {
				startProxyLiveTiming();
			}
		}
		
		function stopLiveTiming() {
			// ◊¢◊¶◊ï◊® scraper
			if (liveTimingManager) {
				console.log('[Strateger] Stopping live timing scraper');
				liveTimingManager.stop();
				liveTimingManager = null;
			}
			
			// ◊†◊ß◊î ◊†◊™◊ï◊†◊ô◊ù
			liveData.position = null;
			liveData.lastLap = null;
			liveData.bestLap = null;
			liveData.laps = 0;
			liveData.gapToLeader = 0;
			liveData.competitors = [];
			liveData.previousPosition = null;
			
			// ‚úÖ ◊î◊°◊™◊® ◊§◊ê◊†◊ú
			const panel = document.getElementById('liveTimingPanel');
			if (panel) {
				panel.classList.add('hidden');
			}
			
			// ‚úÖ ◊î◊°◊™◊® live indicator
			const liveIndicator = document.getElementById('liveIndicator');
			if (liveIndicator) {
				liveIndicator.classList.add('hidden');
			}
			
			// ◊†◊ß◊î UI
			updateLiveTimingUI();
			updateCompetitorsTable();
			updateProxyStatus("‚èπÔ∏è " + t('stopped'));
			
			// ◊ê◊§◊° config
			liveTimingConfig.enabled = false;
			
			console.log('‚úÖ Live Timing fully stopped');
		}
		
		/**
		 * ◊ß◊ë◊ú◊™ ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊©◊ú ◊î-scraper
		 * ◊©◊ô◊û◊ï◊©◊ô ◊ú◊ì◊ô◊ë◊ï◊í
		 */
		function getLiveTimingStats() {
			if (liveTimingManager) {
				const stats = liveTimingManager.getStats();
				console.log('[Strateger] Live timing stats:', stats);
				return stats;
			}
			return null;
		}

		
		function stopLiveTimingUpdates() {
			if (liveTimingInterval) {
				clearInterval(liveTimingInterval);
				liveTimingInterval = null;
			}
			stopProxyLiveTiming();
		}

		// ==================== NEW SAVE STRATEGY LOGIC ====================

		// 1. ◊§◊™◊ô◊ó◊™ ◊î◊û◊ï◊ì◊ê◊ú (◊û◊ó◊ú◊ô◊£ ◊ê◊™ ◊î-Prompt ◊î◊ô◊©◊ü)
		function saveStrategy() {
			if (!previewData || !previewData.timeline) {
				alert("‚ö†Ô∏è ◊ô◊© ◊ú◊ô◊ô◊¶◊® ◊™◊ó◊ñ◊ô◊™ (Generate Preview) ◊ú◊§◊†◊ô ◊î◊©◊û◊ô◊®◊î.");
				return;
			}
			
			// ◊ê◊ô◊§◊ï◊° ◊©◊ì◊ï◊™
			document.getElementById('saveStrategyName').value = '';
			
			// ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú ◊ú◊§◊®◊ò◊ô
			const radios = document.getElementsByName('strategyVisibility');
			for(let r of radios) { 
				if(r.value === 'private') r.checked = true; 
			}

			// ◊î◊¶◊í◊™ ◊î◊û◊ï◊ì◊ê◊ú
			document.getElementById('saveStrategyModal').classList.remove('hidden');
			document.getElementById('saveStrategyName').focus();
		}

		// 2. ◊°◊í◊ô◊®◊™ ◊î◊û◊ï◊ì◊ê◊ú
		function closeSaveStrategyModal() {
			document.getElementById('saveStrategyModal').classList.add('hidden');
		}

		// 3. ◊ë◊ô◊¶◊ï◊¢ ◊î◊©◊û◊ô◊®◊î ◊ë◊§◊ï◊¢◊ú (◊†◊ß◊®◊ê ◊û◊õ◊§◊™◊ï◊® "◊©◊û◊ï◊® ◊õ◊¢◊™")
		async function performStrategySave() {
			const name = document.getElementById('saveStrategyName').value.trim();
			if (!name) {
				alert("◊†◊ê ◊ú◊î◊ñ◊ô◊ü ◊©◊ù ◊ú◊ê◊°◊ò◊®◊ò◊í◊ô◊î");
				return;
			}

			const isPublic = document.querySelector('input[name="strategyVisibility"]:checked').value === 'public';
			
			// ◊°◊í◊ô◊®◊™ ◊î◊û◊ï◊ì◊ê◊ú ◊ï◊î◊¶◊í◊™ ◊ú◊ï◊ê◊ì◊® (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô)
			closeSaveStrategyModal();
			
			// ◊ß◊ë◊ú◊™ ◊û◊ñ◊î◊î ◊û◊õ◊©◊ô◊® ◊ô◊ô◊ó◊ï◊ì◊ô (◊ú◊©◊û◊ô◊®◊î ◊§◊®◊ò◊ô◊™)
			let deviceId = localStorage.getItem('strateger_device_id');
			if (!deviceId) {
				deviceId = 'dev_' + Math.random().toString(36).substr(2, 9);
				localStorage.setItem('strateger_device_id', deviceId);
			}

			// ◊¢◊ì◊õ◊ï◊ü ◊õ◊§◊™◊ï◊® ◊ú◊©◊û◊ô◊®◊î...
			const saveBtn = document.querySelector('button[onclick="saveStrategy()"]'); // ◊î◊†◊ó◊î ◊©◊ñ◊î ◊î◊õ◊§◊™◊ï◊®
			const originalText = saveBtn ? saveBtn.innerHTML : '';
			if(saveBtn) saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

			const payload = {
				name: name,
				config: config,
				timeline: previewData.timeline,
				drivers: drivers,
				driverSchedule: previewData.driverSchedule,
				isPublic: isPublic,
				deviceId: deviceId, // ◊ó◊ï◊ë◊î ◊¢◊ë◊ï◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊ï◊™ ◊§◊®◊ò◊ô◊ï◊™
				userId: googleAccessToken ? 'google_user' : 'anonymous'
			};

			try {
				const response = await fetch('/.netlify/functions/save-strategy', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload)
				});

				const data = await response.json();

				if (data.success) {
					// ◊î◊ï◊ì◊¢◊™ ◊î◊¶◊ú◊ó◊î ◊ô◊§◊î (Toast ◊ê◊ï Alert)
					alert(`‚úÖ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î "${name}" ◊†◊©◊û◊®◊î ◊ë◊î◊¶◊ú◊ó◊î!`);
					// ◊®◊¢◊†◊ï◊ü ◊®◊©◊ô◊û◊™ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊ï◊™ ◊ê◊ù ◊§◊™◊ï◊ó◊î
					if (typeof loadStrategies === 'function') loadStrategies();
				} else {
					throw new Error(data.error || 'Unknown error');
				}
			} catch (error) {
				console.error('Save Error:', error);
				alert(`‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊î: ${error.message}`);
			} finally {
				if(saveBtn) saveBtn.innerHTML = originalText;
			}
		}

		async function loadStrategyLibrary() {
			let deviceId = localStorage.getItem('strateger_device_id') || '';
			
			try {
				const response = await fetch(`/.netlify/functions/get-strategies?deviceId=${deviceId}`);
				const result = await response.json();
				
				if (!result.success) {
					alert('Failed to load strategies');
					return;
				}
				
				showStrategyModal(result.strategies);
			} catch (e) {
				alert(`Error: ${e.message}`);
			}
		}

		async function loadStrategy(id) {
			try {
				const response = await fetch(`/.netlify/functions/load-strategies?id=${id}`);
				const result = await response.json();
				
				if (!result.success) {
					alert('Failed to load strategy');
					return;
				}
				
				const s = result.strategy;
				config = s.config;
				drivers = s.drivers.map(d => ({ ...d, totalMs: 0, stints: 0, logs: [] }));
				previewData = { timeline: s.timeline, driverSchedule: s.driverSchedule, startTime: new Date() };
				
				document.getElementById('strategyModal').classList.add('hidden');
				document.getElementById('setupScreen').classList.add('hidden');
				document.getElementById('previewScreen').classList.remove('hidden');
				
				// Set start time to now
				const now = new Date();
				document.getElementById('raceStartTime').value = 
					`${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
				
				renderPreview();
			} catch (e) {
				alert(`Error: ${e.message}`);
			}
		}
		
		// ==================== RACE STATE PERSISTENCE ====================
		function saveRaceState() {
			if (role !== 'host' || !state.isRunning) return;
			
			const raceState = {
				config,
				state,
				drivers,
				liveTimingConfig,
				myId,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem(RACE_STATE_KEY, JSON.stringify(raceState));
			} catch (e) {
				console.error("Failed to save race state:", e);
			}
		}

		async function saveRaceToDatabase() {
			if (role !== 'host') return;
			
			console.log('üíæ Saving race to Neon DB...');
			
			try {
				// ◊î◊õ◊ü ◊†◊™◊ï◊†◊ô◊ù
				const raceData = {
					raceDuration: config.raceMs,
					totalStints: state.pitCount + 1,
					totalPitStops: state.pitCount,
					drivers: drivers.map(d => ({
						name: d.name,
						totalTime: d.totalMs,
						stints: d.stints,
						avgStint: d.totalMs / d.stints,
						squad: d.squad
					})),
					strategyData: {
						targetStintMs: config.maxStintMs,
						actualAvgStint: drivers.reduce((sum, d) => sum + (d.totalMs / d.stints), 0) / drivers.length,
						fuelTracking: config.trackFuel,
						squadsUsed: config.useSquads
					},
					config: {
						raceMs: config.raceMs,
						reqStops: config.reqStops,
						minStintMs: config.minStintMs,
						maxStintMs: config.maxStintMs,
						minDriverMs: config.minDriverMs,
						maxDriverMs: config.maxDriverMs,
						useSquads: config.useSquads,
						trackFuel: config.trackFuel
					}
				};
				
				// ◊©◊ú◊ó ◊ú-Netlify Function
				const response = await fetch('/.netlify/functions/save-race', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify(raceData)
				});
				
				const result = await response.json();
				
				if (result.success) {
					console.log('‚úÖ Race saved! ID:', result.raceId);
					alert(`üèÅ Race Finished!\n‚úÖ Strategy saved to database (ID: ${result.raceId})`);
				} else {
					console.error('‚ùå Failed to save:', result.error);
				}
				
			} catch (error) {
				console.error('‚ùå Error saving to Neon:', error);
			}
		}

		function checkForSavedRace() {
			try {
				const saved = localStorage.getItem(RACE_STATE_KEY);
				if (!saved) return;
				
				const raceState = JSON.parse(saved);
				
				if (Date.now() - raceState.timestamp > 24 * 60 * 60 * 1000) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				if (!raceState.state || !raceState.state.isRunning) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				const elapsed = Date.now() - raceState.timestamp;
				const raceElapsedTotal = raceState.timestamp - raceState.state.startTime;
				const raceRemaining = raceState.config.raceMs - raceElapsedTotal - elapsed;
				
				if (raceRemaining <= 0) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				window.savedRaceData = { raceState, elapsed };
				
				document.getElementById('savedRaceDriver').innerText = raceState.drivers[raceState.state.currentDriverIdx].name;
				document.getElementById('savedRaceTime').innerText = fmtHMS(raceRemaining);
				document.getElementById('savedRacePits').innerHTML = `<span class="text-neon">${raceState.state.pitCount}</span> / <span>${raceState.config.reqStops}</span>`;
				document.getElementById('savedRaceModal').classList.remove('hidden');
				
			} catch (e) {
				console.error("Failed to check saved race:", e);
				localStorage.removeItem(RACE_STATE_KEY);
			}
		}

		function restoreRaceState(raceState, elapsed) {
			config = raceState.config;
			state = raceState.state;
			drivers = raceState.drivers;
			liveTimingConfig = raceState.liveTimingConfig || {};
			
			// FIX: Do NOT add elapsed time to stintOffset. 
			// Since we use (Date.now() - stintStart), wall-clock time is already accounted for.
			// Adding elapsed here causes the "Ghost Time" / Double Counting issue.
			// if (!state.isInPit) {
			// 	state.stintOffset += elapsed; 
			// }
			
			role = 'host';
			selectRole('host');
			
			const checkPeer = setInterval(() => {
				if (peer && peer.open) {
					clearInterval(checkPeer);
					startHostUI();
					startLiveTimingUpdates();
					
					// Force UI update for buttons immediately after restore
					updateButtonVisibility(); 
				}
			}, 100);
		}

		function updateButtonVisibility() {
            const resetBtn = document.getElementById('btnResetMode');
            if (!resetBtn) return;

            // Check if ANY special mode is active
            const isPush = state.pushMode || state.mode === 'push';
            const isBad = state.badMode || state.mode === 'bad';
            const isNight = state.squadsActive; // Night mode

            if (isPush || isBad || isNight) {
                resetBtn.classList.remove('hidden');
            } else {
                resetBtn.classList.add('hidden');
            }
        }

		function continueRace() {
			if (!window.savedRaceData) return;
			const { raceState, elapsed } = window.savedRaceData;
			document.getElementById('savedRaceModal').classList.add('hidden');
			restoreRaceState(raceState, elapsed);
			delete window.savedRaceData;
		}

		function confirmDiscardRace() {
			document.getElementById('confirmDiscardModal').classList.remove('hidden');
		}

		function cancelDiscard() {
			document.getElementById('confirmDiscardModal').classList.add('hidden');
		}

		function finalDiscardRace() {
			localStorage.removeItem(RACE_STATE_KEY);
			document.getElementById('savedRaceModal').classList.add('hidden');
			document.getElementById('confirmDiscardModal').classList.add('hidden');
			delete window.savedRaceData;
			console.log('Race discarded - ready for new race');
		}

        // ==================== AUDIO ====================
        function beep(freq = 800, type = 'sine', dur = 0.2) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.value = 0.3;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                o.stop(ctx.currentTime + dur);
            } catch (e) {}
        }

        function keepScreenAwake() {
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => {});
            }
        }

        // ==================== FORMAT HELPERS ====================
        function fmtHMS(ms) {
            const s = Math.floor(ms / 1000);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            return h > 0 
                ? `${h}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`
                : `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        }
		
		function copyCode(elementId) {
			const code = document.getElementById(elementId).innerText;
			if (!code || code === '---') return;
			navigator.clipboard.writeText(code);
		}

        // ==================== STATE PERSISTENCE ====================
		const SESSION_KEY = 'strateger_session';
		const HOST_ID_KEY = 'strateger_host_id';
		
		function saveHostState() {
			if (role !== 'host') return;
			
			const inputs = document.querySelectorAll('.driver-input');
			const radios = document.querySelectorAll('.starter-radio');
			const squads = document.querySelectorAll('.squad-toggle');
			
			let starterIdx = 0;
			radios.forEach((r, i) => { if (r.checked) starterIdx = i; });
			
			const driversData = Array.from(inputs).map((input, i) => ({
				name: input.value,
				isStarter: i === starterIdx,
				squad: squads[i]?.checked ? 'B' : 'A'
			}));
			
			const cfg = {
				raceDuration: document.getElementById('raceDuration').value,
				reqPitStops: document.getElementById('reqPitStops').value,
				minStint: document.getElementById('minStint').value,
				maxStint: document.getElementById('maxStint').value,
				minDriverTime: document.getElementById('minDriverTime').value,
				maxDriverTime: document.getElementById('maxDriverTime').value,
				minPitTime: document.getElementById('minPitTime').value,
				releaseBuffer: document.getElementById('releaseBuffer').value,
				allowDouble: document.getElementById('allowDouble').checked,
				trackFuel: document.getElementById('trackFuel').checked,
				maxFuelTime: document.getElementById('maxFuelTime').value,
				useSquads: document.getElementById('useSquads').checked,
				liveTimingUrl: document.getElementById('liveTimingUrl').value,
				searchType: document.querySelector('input[name="searchType"]:checked')?.value || 'team',
				searchValue: document.getElementById('searchValue')?.value || '',
				drivers: driversData,
				simResult: document.getElementById('simResult').innerText,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem('strateger_host_config', JSON.stringify(cfg));
			} catch (e) {
				console.error("Failed to save config:", e);
			}
		}
		
		function restoreHostState() {
			try {
				const saved = localStorage.getItem('strateger_host_config');
				if (!saved) return;
				
				const cfg = JSON.parse(saved);
				
				// Only restore if less than 24 hours old
				if (Date.now() - cfg.timestamp > 24 * 60 * 60 * 1000) {
					localStorage.removeItem('strateger_host_config');
					return;
				}
				
				// Restore values
				if (cfg.raceDuration) document.getElementById('raceDuration').value = cfg.raceDuration;
				if (cfg.reqPitStops) document.getElementById('reqPitStops').value = cfg.reqPitStops;
				if (cfg.minStint) document.getElementById('minStint').value = cfg.minStint;
				if (cfg.maxStint) document.getElementById('maxStint').value = cfg.maxStint;
				if (cfg.minDriverTime) document.getElementById('minDriverTime').value = cfg.minDriverTime;
				if (cfg.maxDriverTime) document.getElementById('maxDriverTime').value = cfg.maxDriverTime;
				if (cfg.minPitTime) document.getElementById('minPitTime').value = cfg.minPitTime;
				if (cfg.releaseBuffer) document.getElementById('releaseBuffer').value = cfg.releaseBuffer;
				document.getElementById('allowDouble').checked = cfg.allowDouble || false;
				document.getElementById('trackFuel').checked = cfg.trackFuel || false;
				if (cfg.maxFuelTime) document.getElementById('maxFuelTime').value = cfg.maxFuelTime;
				document.getElementById('useSquads').checked = cfg.useSquads || false;
				document.getElementById('liveTimingUrl').value = cfg.liveTimingUrl || '';
				document.getElementById('searchValue').value = cfg.searchValue || '';
				
				if (cfg.searchType) {
					const radio = document.querySelector(`input[name="searchType"][value="${cfg.searchType}"]`);
					if (radio) radio.checked = true;
				}
				
				// Restore drivers
				const list = document.getElementById('driversList');
				list.innerHTML = '';
				
				if (cfg.drivers && cfg.drivers.length > 0) {
					cfg.drivers.forEach((driver) => {
						createDriverInput(driver.name, driver.isStarter, driver.squad);
					});
				} else {
					generateDrivers();
				}
				
				toggleFuelInput();
				toggleSquadsInput();
				updateSearchPlaceholder();
				
				if (cfg.simResult) {
					document.getElementById('simResult').innerText = cfg.simResult;
				}
				
				runSim();
			
			// Add event listeners to auto-recalculate on changes
			attachConfigListeners();
			} catch (e) {
				console.error("Failed to restore config:", e);
			}
		}
		
		function attachConfigListeners() {
			// Attach listeners to all config inputs
			const configInputs = [
				'raceDuration', 'reqPitStops', 'minStint', 'maxStint',
				'minDriverTime', 'maxDriverTime', 'minPitTime', 'releaseBuffer',
				'maxFuelTime', 'allowDouble', 'trackFuel', 'useSquads'
			];
			
			configInputs.forEach(id => {
				const el = document.getElementById(id);
				if (el && !el.dataset.listenerAttached) {
					el.addEventListener('change', () => runSim());
					el.dataset.listenerAttached = 'true';
				}
			});
			
			// Weather condition radios
			document.querySelectorAll('input[name="weatherCondition"]').forEach(radio => {
				if (!radio.dataset.listenerAttached) {
					radio.addEventListener('change', () => runSim());
					radio.dataset.listenerAttached = 'true';
				}
			});
			
			// Starter driver radios
			document.querySelectorAll('.starter-radio').forEach(radio => {
				if (!radio.dataset.listenerAttached) {
					radio.addEventListener('change', () => runSim());
					radio.dataset.listenerAttached = 'true';
				}
			});
			
			// Squad toggles
			document.querySelectorAll('.squad-toggle').forEach(toggle => {
				if (!toggle.dataset.listenerAttached) {
					toggle.addEventListener('change', () => runSim());
					toggle.dataset.listenerAttached = 'true';
				}
			});
			
			console.log('‚úÖ Config change listeners attached');
		}

        // ==================== HOST PEER ====================
        function initHostPeer() {
            const statusText = document.getElementById('netStatusText');
            const retryBtn = document.getElementById('retryBtn');
            
            statusText.innerText = t('connecting');
            statusText.className = "text-[10px] text-yellow-500 mt-2";
            retryBtn.classList.add('hidden');
            
            try {
                myId = String(Math.floor(1000000 + Math.random() * 9000000));
                
                if (peer) {
                    peer.destroy();
					peer = null;
                }
                
                console.log("Creating peer with ID:", myId);
                peer = new Peer(myId, peerConfig);
                
                peer.on('open', (id) => {
					console.log("Peer connected with ID:", id);
					document.getElementById('myHostId').innerText = id;
					statusText.innerText = "‚úÖ " + t('connected');
					statusText.className = "text-[10px] text-green-500 font-bold mt-2";
					connectionRetries = 0;
					
					// Show load strategy button for host
					document.getElementById('loadStrategyBtn').classList.remove('hidden');
				});
                
                peer.on('connection', (c) => {
                    console.log("New client connected:", c.peer);
                    connections.push(c);
                    updateClientCount();
                    
                    c.on('open', () => {
						console.log("Connection opened with:", c.peer);
						if (state.isRunning) {
							c.send({ type: 'INIT', config, state, drivers, liveData, liveTimingConfig });
						}
					});
                    
                    c.on('data', (d) => {
                        if (d === 'REQUEST_INIT' && state.isRunning) {
                            c.send({ type: 'INIT', config, state, drivers, liveData, liveTimingConfig });
                        }
                    });
                    
                    c.on('close', () => {
                        connections = connections.filter(x => x !== c);
                        updateClientCount();
                    });
                });
                
                peer.on('error', (err) => {
                    console.error("Peer error:", err);
                    statusText.innerText = `‚ùå ${t('error')} ${err.type}`;
                    statusText.className = "text-[10px] text-red-500 mt-2";
                    retryBtn.classList.remove('hidden');
                });
                
                peer.on('disconnected', () => {
                    if (connectionRetries < MAX_RETRIES) {
                        connectionRetries++;
                        setTimeout(() => peer.reconnect(), 2000);
                    }
                });
            } catch (e) {
                statusText.innerText = `‚ùå ${t('error')} ${e.message}`;
                retryBtn.classList.remove('hidden');
            }
        }
        
        function updateClientCount() {
			const count = connections.filter(c => c.open).length;
			const syncText = document.getElementById('syncText');
			if (syncText) {
				const viewerText = {
					en: count > 1 ? 'viewers' : 'viewer',
					he: count > 1 ? '◊¶◊ï◊§◊ô◊ù' : '◊¶◊ï◊§◊î',
					fr: count > 1 ? 'spectateurs' : 'spectateur',
					pt: count > 1 ? 'espectadores' : 'espectador'
				};
				syncText.innerText = count > 0 ? `${count} ${viewerText[currentLang] || viewerText.en}` : t('synced');
			}
		}

        // ==================== CLIENT PEER ====================
		function initClientPeer() {
			return new Promise((resolve, reject) => {
				if (peer && !peer.destroyed) {
					if (peer.open) {
						resolve(peer.id);
						return;
					}
					peer.destroy();
				}
				
				const clientId = 'viewer_' + Math.random().toString(36).substr(2, 9);
				peer = new Peer(clientId, peerConfig);
				
				peer.on('open', (id) => {
					console.log("Client peer ready:", id);
					resolve(id);
				});
				
				peer.on('error', (err) => {
					console.error("Client peer error:", err);
					const msg = document.getElementById('clientConnMsg');
					if (msg) {
						msg.innerText = `${t('error')} ${err.type}`;
						msg.className = "text-xs text-red-500 mt-2";
					}
				});
				
				peer.on('disconnected', () => {
					if (peer && !peer.destroyed) {
						peer.reconnect();
					}
				});
			});
		}
		
		function disconnectClient() {
			if (conn) {
				conn.close();
				conn = null;
			}
			
			const msg = document.getElementById('clientConnMsg');
			msg.innerText = t('disconnected');
			msg.className = "text-xs text-gray-500 mt-2";
			
			document.getElementById('disconnectBtn').classList.add('hidden');
			
			const dashboardVisible = !document.getElementById('raceDashboard').classList.contains('hidden');
			if (dashboardVisible) {
				document.getElementById('raceDashboard').classList.add('hidden');
				document.getElementById('setupScreen').classList.remove('hidden');
			}
		}

        function connectToHost() {
			const hostId = document.getElementById('remoteIdInput').value.trim();
			if (!hostId) return;
			
			const msg = document.getElementById('clientConnMsg');
			msg.innerText = t('connecting');
			msg.className = "text-xs text-yellow-500 mt-2";
			
			if (conn) {
				conn.close();
				conn = null;
			}
			
			if (!peer || peer.destroyed) {
				initClientPeer().then(() => {
					doConnect(hostId, msg);
				});
				return;
			}
			
			if (peer.disconnected) {
				peer.reconnect();
				peer.once('open', () => {
					doConnect(hostId, msg);
				});
				return;
			}
			
			doConnect(hostId, msg);
		}

		function doConnect(hostId, msg) {
			console.log("Connecting to host:", hostId);
			
			conn = peer.connect(hostId, { reliable: true });
			
			if (!conn) {
				msg.innerText = `${t('error')} Connection failed`;
				msg.className = "text-xs text-red-500 mt-2";
				return;
			}
			
			conn.on('open', () => {
				console.log("Connected to host:", hostId);
				msg.innerText = t('waitingRace');
				msg.className = "text-xs text-green-500 mt-2";
				document.getElementById('disconnectBtn').classList.remove('hidden');
				conn.send('REQUEST_INIT');
			});

			conn.on('data', (d) => {
				console.log("Received data:", d.type);
				
				if (d.type === 'INIT' || d.type === 'UPDATE') { 
					if (d.config) config = d.config; 
					if (d.drivers) drivers = d.drivers; 
					if (d.state) state = d.state;
					if (d.liveTimingConfig) liveTimingConfig = d.liveTimingConfig;
					if (d.liveData) liveData = d.liveData;
					if (d.calculatedTimes) syncedTimes = d.calculatedTimes;
					
					const dashboardHidden = document.getElementById('raceDashboard').classList.contains('hidden');
					
					if (state && state.isRunning && dashboardHidden) {
						startClientUI();
					} else if (state && state.isRunning && !dashboardHidden) {
						renderFrame(); 
						updateStats(syncedTimes ? syncedTimes.stintElapsed : 0); 
						if (liveData) updateLiveTimingUI();
					} else if (!state || !state.isRunning) {
						msg.innerText = t('waitingRace');
						msg.className = "text-xs text-yellow-500 mt-2";
					}
				}
			});
			
			conn.on('close', () => {
				console.log("Disconnected from host");
				msg.innerText = t('disconnected');
				msg.className = "text-xs text-red-500 mt-2";
				
				document.getElementById('disconnectBtn').classList.add('hidden');
				
				const dashboardVisible = !document.getElementById('raceDashboard').classList.contains('hidden');
				if (dashboardVisible) {
					document.getElementById('raceDashboard').classList.add('hidden');
					document.getElementById('setupScreen').classList.remove('hidden');
				}
				
				conn = null;
			});
			
			conn.on('error', (err) => {
				console.error("Connection error:", err);
				msg.innerText = `${t('error')} ${err.type || err}`;
				msg.className = "text-xs text-red-500 mt-2";
			});
		}

        // ==================== BROADCAST ====================
        function broadcast() {
			if (role !== 'host' || !peer || connections.length === 0) return;
			const now = Date.now();
			
			// Calculate total pit time
			let totalPitTime = 0;
			drivers.forEach(d => {
				d.logs.forEach(log => {
					if (log.pit) totalPitTime += log.pit;
				});
			});
			
			// Add current pit time if in pit
			if (state.isInPit) {
				totalPitTime += (now - state.pitStart);
			}
			
			const msg = {
				config: config,
				drivers: drivers,
				state: state,
				liveTimingConfig: liveTimingConfig,
				syncedTimes: {
					raceElapsed: now - state.startTime,
					stintElapsed: state.isInPit ? 0 : (now - state.stintStart + state.stintOffset),
					pitElapsed: state.isInPit ? (now - state.pitStart) : 0,
					totalPitTime: totalPitTime,
					timestamp: now
				}
			};
			connections.forEach(c => {
				if (c.open) c.send(msg);
			});
			updateClientCount();
		}

        // ==================== UI TOGGLES ====================
        function toggleFuelInput() { 
            document.getElementById('fuelInputDiv').classList.toggle('hidden', !document.getElementById('trackFuel').checked); 
        }
        
        function toggleSquadsInput() { 
            document.querySelectorAll('.squad-toggle-container').forEach(el => 
                el.classList.toggle('hidden', !document.getElementById('useSquads').checked)
            ); 
        }

        // ==================== DRIVER MANAGEMENT ====================
        function generateDrivers() {
			const list = document.getElementById('driversList'); 
			list.innerHTML = '';
			["Driver 1", "Driver 2", "Driver 3", "Driver 4"].forEach((n, i) => createDriverInput(n, i === 0, i < 2 ? 'A' : 'B'));
			toggleSquadsInput();
		}
        
        function createDriverInput(val, checked, squad) {
			const div = document.createElement('div');
			div.className = "flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700";
			const radioId = 'starter_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
			
			// ‚úÖ ◊ô◊¶◊ô◊®◊™ ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊ô◊©◊ô◊®◊ï◊™
			const label = document.createElement('label');
			label.className = "flex items-center cursor-pointer";
			
			const radio = document.createElement('input');
			radio.type = 'radio';
			radio.name = 'starter';
			radio.id = radioId;
			radio.className = 'starter-radio sr-only';
			radio.checked = checked;
			
			const indicator = document.createElement('div');
			indicator.className = checked 
				? 'starter-indicator w-8 h-8 rounded-full border-2 border-ice bg-ice/30 shadow-[0_0_8px_rgba(34,211,238,0.5)] flex items-center justify-center text-sm'
				: 'starter-indicator w-8 h-8 rounded-full border-2 border-gray-500 flex items-center justify-center text-sm hover:border-ice transition';
			indicator.textContent = 'üèÅ';
			
			// ‚úÖ Event handler ◊ê◊û◊ô◊™◊ô ◊¢◊ù stopPropagation
			label.addEventListener('click', function(e) {
				e.stopPropagation();
				e.preventDefault();          // ‚úÖ ◊ó◊ì◊©
				e.stopImmediatePropagation(); // ‚úÖ ◊ó◊ì◊©
				
				radio.checked = true;
				updateStarterVisuals(e);
			}, true);  // ‚úÖ capture phase
			
			label.appendChild(radio);
			label.appendChild(indicator);
			
			// Driver input
			const driverInput = document.createElement('input');
			driverInput.type = 'text';
			driverInput.value = val;
			driverInput.className = 'driver-input bg-transparent text-white w-full outline-none font-bold';
			
			// Squad toggle
			const squadLabel = document.createElement('label');
			squadLabel.className = 'squad-toggle-container flex items-center cursor-pointer ml-auto bg-navy-800 rounded px-2 py-1 border border-gray-600 hidden';
			squadLabel.innerHTML = `
				<span class="text-[10px] mr-1 text-gray-400">${t('squads')}</span>
				<input type="checkbox" class="squad-toggle hidden" ${squad === 'B' ? 'checked' : ''} onchange="this.nextElementSibling.innerText = this.checked ? 'B' : 'A'; this.nextElementSibling.className = this.checked ? 'w-6 h-4 rounded bg-squadB text-[8px] flex items-center justify-center font-bold text-white' : 'w-6 h-4 rounded bg-squadA text-[8px] flex items-center justify-center font-bold text-white'">
				<div class="w-6 h-4 rounded ${squad === 'B' ? 'bg-squadB' : 'bg-squadA'} text-[8px] flex items-center justify-center font-bold text-white">${squad}</div>
			`;
			
			div.appendChild(label);
			div.appendChild(driverInput);
			div.appendChild(squadLabel);
			document.getElementById('driversList').appendChild(div);
		}
		
		function updateStarterVisuals(event) {
			if (event) {
				event.stopPropagation();
				event.preventDefault();
			}
			
			// ◊©◊û◊ï◊® scroll position
			const scrollPos = window.scrollY || document.documentElement.scrollTop;
			const configPanel = document.getElementById('configPanel');
			const panelScrollPos = configPanel ? configPanel.scrollTop : 0;
			
			// ◊¢◊ì◊õ◊ü ◊ê◊ô◊†◊ì◊ô◊ß◊ò◊ï◊®◊ô◊ù
			document.querySelectorAll('.starter-indicator').forEach(ind => {
				const radio = ind.previousElementSibling;
				if (radio && radio.checked) {
					ind.className = 'starter-indicator w-8 h-8 rounded-full border-2 border-ice bg-ice/30 shadow-[0_0_8px_rgba(34,211,238,0.5)] flex items-center justify-center text-sm';
				} else {
					ind.className = 'starter-indicator w-8 h-8 rounded-full border-2 border-gray-500 flex items-center justify-center text-sm hover:border-ice transition';
				}
			});
			
			// ◊î◊ó◊ñ◊® scroll position
			window.scrollTo(0, scrollPos);
			if (configPanel) {
				configPanel.scrollTop = panelScrollPos;
			}
		}

		function addDriverField() { 
			createDriverInput(`Driver ${document.getElementById('driversList').children.length + 1}`, false, 'A'); 
			toggleSquadsInput();
		}

		function removeDriverField() { 
			const l = document.getElementById('driversList'); 
			if (l.children.length > 2) {
				l.removeChild(l.lastChild);
			}
		}

        // ==================== RACE INITIALIZATION ====================
        function initRace() {
			// --- üõ°Ô∏è ◊ê◊ë◊ò◊ó◊î: ◊®◊ß ◊û◊ï◊®◊©◊ô ◊í◊ï◊í◊ú ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊§◊™◊ï◊ó ◊û◊ô◊®◊ï◊• ---
			if (!googleAccessToken) {
				alert("üîí ◊í◊ô◊©◊î ◊ú◊û◊†◊î◊ú◊ô◊ù ◊ë◊ú◊ë◊ì\n\n◊®◊ß ◊û◊©◊™◊û◊©◊ô◊ù ◊î◊û◊ó◊ï◊ë◊®◊ô◊ù ◊ú◊ó◊©◊ë◊ï◊ü Google ◊û◊ï◊®◊©◊î ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊†◊î◊ú ◊û◊ô◊®◊ï◊•.\n◊ê◊†◊ê ◊î◊™◊ó◊ë◊® ◊ú◊û◊¢◊ú◊î ◊û◊¶◊ì ◊©◊û◊ê◊ú.");
				return; // ◊¢◊ï◊¶◊® ◊ê◊™ ◊î◊§◊ï◊†◊ß◊¶◊ô◊î ◊õ◊ê◊ü
			}
			// ----------------------------------------------------

			if (role === 'client') return;
			
			const inputs = document.querySelectorAll('.driver-input');
			const radios = document.querySelectorAll('.starter-radio');
			const squads = document.querySelectorAll('.squad-toggle');
			let startIdx = 0; 
			radios.forEach((r, i) => { if (r.checked) startIdx = i; });
			
			if (inputs.length < 2) return alert("Minimum 2 drivers required");
			
			config = {
				raceMs: parseFloat(document.getElementById('raceDuration').value) * 3600000,
				reqStops: parseInt(document.getElementById('reqPitStops').value) || 0,
				minPitSec: parseInt(document.getElementById('minPitTime').value) || 0,
				releaseBufferSec: parseInt(document.getElementById('releaseBuffer').value) || 0,
				minStintMs: parseFloat(document.getElementById('minStint').value) * 60000,
				maxStintMs: parseFloat(document.getElementById('maxStint').value) * 60000,
				minDriverMs: parseFloat(document.getElementById('minDriverTime').value) * 60000,
				maxDriverMs: parseFloat(document.getElementById('maxDriverTime').value) * 60000,
				allowDouble: document.getElementById('allowDouble').checked,
				trackFuel: document.getElementById('trackFuel').checked,
				maxFuelMs: parseFloat(document.getElementById('maxFuelTime').value) * 60000,
				useSquads: document.getElementById('useSquads').checked
			};
			
			liveTimingConfig.url = document.getElementById('liveTimingUrl').value;
			updateSearchConfig();
			
			drivers = Array.from(inputs).map((d, i) => ({ 
				name: d.value, 
				totalMs: 0, 
				stints: 0, 
				squad: squads[i].checked ? 'B' : 'A', 
				logs: [], 
				isExpanded: false 
			}));
			
			const raceStartTime = Date.now();
			
			// Initialize State
			state = { 
				isRunning: true,
				pushMode: false,
				badMode: false, 
				startTime: raceStartTime, 
				stintStart: raceStartTime,
				fuelStart: raceStartTime, 
				currentDriverIdx: startIdx, 
				pitCount: 0, 
				isInPit: false, 
				mode: 'normal', 
				trackCondition: 'dry',
				stintOffset: 0, 
				activeSquad: 'A', 
				nextDriverIdx: (startIdx + 1) % drivers.length, 
				targetStintMs: config.raceMs / (config.reqStops + 1), 
				squadsActive: false,
				pendingPitEntry: false,
				globalStintNumber: 1,
				raceSaved: false,
				// New: Arrays for strategy tracking
				stintTargets: [],
				deltaHistory: []
			};

			// Load Strategy from Preview if available
			if (window.previewData && window.previewData.timeline) {
				const stints = window.previewData.timeline.filter(t => t.type === 'stint');
				// Map durations to targets
				state.stintTargets = stints.map(s => s.duration);
				
				// Use the generated strategy plan to set initial target
				state.targetStintMs = state.stintTargets[0] || config.maxStintMs;
				
				// If strategy dictates a specific start driver, use it (override UI if needed)
				// But usually UI starter matches strategy.
				console.log('üèÅ Race Initialized with Planned Strategy:', state.stintTargets);
			} else {
				// Fallback: Fill array with averages if no preview generated
				const avg = config.raceMs / (config.reqStops + 1);
				const totalStints = config.reqStops + 1;
				state.stintTargets = new Array(totalStints).fill(avg);
			}

			// Apply specific strategy details if available
			if (window.generatedStrategy) {
				if (window.generatedStrategy.doubleStints && window.generatedStrategy.doubleStints.length > 0) {
					state.plannedDoubles = window.generatedStrategy.doubleStints;
				}
			}

			setTimeout(() => {
				broadcast();
			}, 100);
			saveHostState();
			document.getElementById('btnResetMode').classList.add('hidden');
			broadcast(); 
			startHostUI();
			startLiveTimingUpdates();
		}

        // ==================== TICK ====================
		function tick() { 
			if (!state.isRunning) return;
			renderFrame();
			
			// Update stats with current stint time
			if (!state.isInPit) {
				const stintTime = Date.now() - state.stintStart + state.stintOffset;
				updateStats(stintTime);
			}
			
			if (liveTimingConfig.demoMode) {
				updateDemoData();
			}
		}

        // ==================== RENDERING ====================
        function renderFrame() {
			try {
				const now = Date.now();
				
				let raceRemaining, stintTime;
				
				if (role === 'host') {
					raceRemaining = config.raceMs - (now - state.startTime);
					stintTime = state.isInPit ? 0 : (now - state.stintStart + state.stintOffset);
				} else if (syncedTimes) {
					// Viewer mode - more precise calculation
					const timeSinceLastSync = now - syncedTimes.timestamp;
					
					// Race time includes all time that passed
					raceRemaining = config.raceMs - (syncedTimes.raceElapsed + timeSinceLastSync);
					
					// Stint time - only if not in pit
					if (!state.isInPit) {
						stintTime = syncedTimes.stintElapsed + timeSinceLastSync;
					} else {
						stintTime = 0;
					}
				} else {
					raceRemaining = config.raceMs - (now - state.startTime);
					stintTime = state.isInPit ? 0 : (now - state.stintStart + state.stintOffset);
				}

				// Update viewer pit indicator
				if (role === 'client') {
					const viewerPitIndicator = document.getElementById('viewerPitIndicator');
					const viewerPitTimer = document.getElementById('viewerPitTimer');
					const viewerNextDriver = document.getElementById('viewerNextDriver');
					
					if (state.isInPit) {
						viewerPitIndicator.classList.remove('hidden');
						const pitElapsed = syncedTimes ? (now - (syncedTimes.timestamp - syncedTimes.pitElapsed)) : 0;
						viewerPitTimer.innerText = Math.floor(pitElapsed / 1000) + 's';
						viewerNextDriver.innerText = drivers[state.nextDriverIdx]?.name || '---';
					} else {
						viewerPitIndicator.classList.add('hidden');
					}
				}
				
				if (raceRemaining <= 0) { 
					document.getElementById('raceTimerDisplay').innerText = "Finish"; 
					stopLiveTimingUpdates();
					
					// ‚úÖ ◊©◊û◊ï◊® ◊ú-DB (◊®◊ß ◊§◊¢◊ù ◊ê◊ó◊™)
					if (role === 'host' && !state.raceSaved) {
						state.raceSaved = true;
						saveRaceToDatabase();
					}
					
					return; 
				}
				document.getElementById('raceTimerDisplay').innerText = fmtHMS(raceRemaining);

				if (!state.isInPit && !state.pendingPitEntry) {
					document.getElementById('stintTimerDisplay').innerText = fmtHMS(Math.max(0, stintTime));
					document.getElementById('stintProgressBar').style.width = Math.min(100, (stintTime / config.maxStintMs) * 100) + '%';
					updateStrategy(stintTime);
				}

                document.getElementById('currentDriverName').innerText = drivers[state.currentDriverIdx].name;
                document.getElementById('nextDriverName').innerText = drivers[state.nextDriverIdx].name;
                document.getElementById('modalNextDriverName').innerText = drivers[state.nextDriverIdx].name;
                document.getElementById('pitCountDisplay').innerText = `${state.pitCount} / ${config.reqStops}`;
                
                if (config.useSquads) {
					document.getElementById('btnNight').classList.remove('hidden');
					
					const nightBtn = document.getElementById('btnNight');
					if (state.squadsActive) {
						// Night mode active - Squad A starts, Squad B finishes
						document.getElementById('activeSquadDisplay').classList.remove('hidden');
						document.getElementById('sleepWidget').classList.remove('hidden');
						
						const activeSquadText = document.getElementById('activeSquadText');
						const sleepersLabel = document.getElementById('sleepWidget').querySelector('p:first-child');
						
						activeSquadText.innerText = state.activeSquad;
						activeSquadText.className = state.activeSquad === 'A' 
							? 'text-lg font-bold text-squadA ml-2' 
							: 'text-lg font-bold text-squadB ml-2';
						
						const sleepers = drivers.filter(d => d.squad !== state.activeSquad);
						document.getElementById('sleepersList').innerText = sleepers.map(d => d.name).join(', ') || "---";
						
						// Show info about squad rotation
						if (sleepersLabel) {
							const restingText = { en: 'Resting', he: '◊†◊ó◊ô◊ù', fr: 'Au repos', pt: 'Descansando' };
							const nextText = { en: '(up next)', he: '(◊î◊ë◊ê◊ô◊ù)', fr: '(suivants)', pt: '(pr√≥ximos)' };
							sleepersLabel.innerHTML = `${restingText[currentLang] || restingText.en} <span class="text-gray-500">${state.activeSquad === 'A' ? nextText[currentLang] || nextText.en : ''}</span>:`;
						}
						nightBtn.className = "btn-press bg-cyan-900 border-2 border-cyan-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(6,182,212,0.5)]";
						nightBtn.innerHTML = `<span class="block text-lg">üåô ${t('nightActive')}</span>`;
					} else {
						// Night mode not active - everyone is awake
						document.getElementById('activeSquadDisplay').classList.add('hidden');
						document.getElementById('sleepWidget').classList.add('hidden');
						
						nightBtn.className = "btn-press bg-navy-800 border border-cyan-500/50 rounded-lg p-2 group hover:bg-navy-700 text-cyan-300";
						nightBtn.innerHTML = `<span class="block text-lg">üåô ${t('night')}</span>`;
					}
				} else {
					document.getElementById('btnNight').classList.add('hidden');
					document.getElementById('activeSquadDisplay').classList.add('hidden');
					document.getElementById('sleepWidget').classList.add('hidden');
				}
				
				const btnPush = document.getElementById('btnPush');
				if (btnPush) {
					if (state.pushMode || state.mode === 'push') {
						btnPush.className = "btn-press bg-green-700 border-2 border-green-400 rounded-lg p-3 text-white";
					} else {
						btnPush.className = "btn-press bg-navy-800 border border-green-900/50 rounded-lg p-3 hover:bg-navy-700";
					}
				}

				// Problem button styling
				const btnBad = document.getElementById('btnBad');
				if (btnBad) {
					if (state.badMode || state.mode === 'bad') {
						btnBad.className = "btn-press bg-red-700 border-2 border-red-400 rounded-lg p-3 text-white";
					} else {
						btnBad.className = "btn-press bg-navy-800 border border-red-900/50 rounded-lg p-3 hover:bg-navy-700";
					}
				}

				// Weather display
				const rIcon = document.getElementById('rainIcon');
				const rText = document.getElementById('rainText');
				const stratBox = document.getElementById('strategyBox');

				stratBox.className = "p-3 text-center border-b-2 flex flex-col items-center justify-center rounded-lg shadow-lg shrink-0 transition-colors duration-500";

				if (state.trackCondition === 'wet') {
					rIcon.innerHTML = "‚òÅÔ∏è";  // ◊¢◊†◊ü ◊ë◊ú◊ë◊ì
					rIcon.className = "text-lg text-ice";
					rText.innerText = t('wet');
					rText.className = "text-xs font-bold text-ice";
					stratBox.classList.add("bg-blue-900/90", "border-ice");
				} else if (state.trackCondition === 'drying') {
					rIcon.innerHTML = "üå§Ô∏è";  // ◊©◊û◊© ◊¢◊ù ◊¢◊†◊ü
					rIcon.className = "text-lg";
					rText.innerText = t('drying');
					rText.className = "text-xs font-bold text-yellow-400";
					stratBox.classList.add("bg-yellow-900/50", "border-yellow-500");
				} else {
					rIcon.innerHTML = "‚òÄÔ∏è";
					rIcon.className = "text-lg";
					rText.innerText = t('dry');
					rText.className = "text-xs font-bold text-yellow-400";
					stratBox.classList.add("bg-navy-900", "border-neon");
				}

                // Sync status
                if (role === 'host') {
                    const syncDot = document.getElementById('syncDot');
                    const syncText = document.getElementById('syncText');
                    const activeConns = connections.filter(c => c.open).length;
                    
                    if (activeConns > 0) {
                        syncDot.className = "sync-dot bg-green-500 mr-1";
                        syncText.innerText = `${activeConns} viewer${activeConns > 1 ? 's' : ''}`;
                    } else {
                        syncDot.className = "sync-dot bg-yellow-500 mr-1";
                        syncText.innerText = t('synced');
                    }
                }
				// Update current stint time in logs
				if (!state.isInPit) {
					const stintEl = document.getElementById(`currentStintTime_${state.currentDriverIdx}`);
					if (stintEl) {
						stintEl.innerText = fmtHMS(Math.max(0, stintTime));
					}
				}
            } catch (e) { 
                console.error("Render Error", e); 
            }
        }

		function checkTimerSync() {
			if (role !== 'host') return;
			
			const now = Date.now();
			const raceElapsed = now - state.startTime;
			
			// Calculate total stint time (driving time)
			let totalStintTime = 0;
			drivers.forEach(d => {
				totalStintTime += d.totalMs;
			});
			
			// Add current stint if driving
			if (!state.isInPit) {
				const currentStintTime = now - state.stintStart + state.stintOffset;
				totalStintTime += currentStintTime;
			}
			
			// Calculate total pit time
			let totalPitTime = 0;
			drivers.forEach(d => {
				d.logs.forEach(log => {
					if (log.pit) totalPitTime += log.pit;
				});
			});
			
			// Add current pit time if in pit
			if (state.isInPit) {
				totalPitTime += (now - state.pitStart);
			}
			
			// Total accounted time should equal race elapsed
			const totalAccountedTime = totalStintTime + totalPitTime;
			const diff = Math.abs(raceElapsed - totalAccountedTime);
			const diffSeconds = (diff / 1000).toFixed(1);
			
			console.log('‚è±Ô∏è Timer Sync Check:');
			console.log(`  Race Elapsed: ${fmtHMS(raceElapsed)}`);
			console.log(`  Driving Time: ${fmtHMS(totalStintTime)}`);
			console.log(`  Pit Time: ${fmtHMS(totalPitTime)}`);
			console.log(`  Total Accounted: ${fmtHMS(totalAccountedTime)}`);
			console.log(`  Difference: ${diffSeconds}s`);
			
			if (diff > 5000) {
				console.warn(`‚ö†Ô∏è Timer sync issue! ${diffSeconds}s difference`);
				return { synced: false, difference: diff };
			} else {
				console.log('‚úÖ Timers synced!');
				return { synced: true, difference: diff };
			}
		}

		// ◊ë◊ì◊ô◊ß◊î ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊õ◊ú 30 ◊©◊†◊ô◊ï◊™
		if (typeof window !== 'undefined' && !window.timerSyncInterval) {
			window.timerSyncInterval = setInterval(() => {
				if (role === 'host' && state.isRunning) {
					checkTimerSync();
				}
			}, 30000);
		}

        function updateStrategy(sTime) {
			// 1. ◊†◊ô◊î◊ï◊ú ◊õ◊§◊™◊ï◊® ◊î-RESET (◊î◊™◊ô◊ß◊ï◊ü)
			const btnReset = document.getElementById('btnResetMode');
			if (btnReset) {
				if (state.mode === 'push' || state.mode === 'bad') {
					btnReset.classList.remove('hidden'); // ◊™◊®◊ê◊î ◊®◊ß ◊ê◊ù ◊ô◊© ◊û◊¶◊ë ◊û◊ô◊ï◊ó◊ì
				} else {
					btnReset.classList.add('hidden'); // ◊ë◊õ◊ú ◊û◊¶◊ë ◊ê◊ó◊® - ◊™◊°◊™◊ô◊®!
				}
			}

			// 2. ◊©◊ê◊® ◊î◊ú◊ï◊í◊ô◊ß◊î ◊©◊ú ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î (◊†◊©◊ê◊®◊™ ◊ê◊ï◊™◊ï ◊ì◊ë◊®)
			if (state.mode === 'normal') {
				const currentTarget = state.stintTargets[state.globalStintNumber - 1] || state.targetStintMs;
				state.targetStintMs = Math.min(Math.max(currentTarget, config.minStintMs), config.maxStintMs);
			}
			
			// ◊¢◊ì◊õ◊ï◊ü ◊ò◊ß◊°◊ò◊ô◊ù
			const targetEl = document.getElementById('strategyTargetStint');
			if (targetEl) targetEl.innerText = fmtHMS(state.targetStintMs);

			const diff = state.targetStintMs - sTime;
			const dEl = document.getElementById('strategyDelta');
			
			if (dEl) {
				dEl.innerText = diff > 0 ? `-${Math.ceil(diff / 60000)}m` : `+${Math.floor(Math.abs(diff) / 60000)}m`;
				dEl.className = diff > 0 ? "text-lg font-bold text-gray-400" : "text-lg font-bold text-neon";
			}
			
			// Advice Text logic... (◊ê◊ô◊ü ◊¶◊ï◊®◊ö ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊ñ◊î, ◊®◊ß ◊™◊ï◊ï◊ì◊ê ◊©◊ñ◊î ◊ß◊ô◊ô◊ù)
			const advice = document.getElementById('strategyAdvice');
			if (advice) {
				const timeToMax = config.maxStintMs - sTime;
				if (timeToMax < 0) { 
					advice.innerText = t('timeExceeded');
					advice.className = "text-xs text-red-500 animate-pulse font-bold"; 
				} else if (state.mode === 'bad') {
					advice.innerText = t('problemQuick');
					advice.className = "text-xs text-red-400 font-bold";
				} else if (state.mode === 'push') {
					advice.innerText = t('pushExtend');
					advice.className = "text-xs text-green-400 font-bold";
				} else if (diff < 300000 && diff > -300000) {
					advice.innerText = t('targetWindow');
					advice.className = "text-xs text-ice font-bold";
				} else if (diff > 0) {
					advice.innerText = t('buildTime');
					advice.className = "text-xs text-gray-400";
				} else {
					advice.innerText = t('overExtend');
					advice.className = "text-xs text-yellow-400 font-bold";
				}
			}
		}

        function updateStats(stintMs) {
			const tb = document.getElementById('statsTable'); 
			tb.innerHTML = '';
			
			drivers.forEach((d, i) => {
				let tot = d.totalMs; 
				if (i === state.currentDriverIdx && !state.isInPit) tot += stintMs;
				
				let rowClass = "border-b border-gray-700";
				if (i === state.currentDriverIdx && !state.isInPit) {
					rowClass = "bg-white/10 font-bold text-white border-b border-gray-600";
				}
				
				let timeClass = "text-gray-300"; 
				let symbol = "";
				if (config.minDriverMs > 0 && tot < config.minDriverMs) { 
					timeClass = "text-yellow-500 font-bold"; 
					symbol = "‚ö†Ô∏è"; 
				} else if (config.maxDriverMs > 0 && tot > config.maxDriverMs) { 
					timeClass = "text-red-500 font-bold animate-pulse"; 
					symbol = "üõë"; 
				} else if (config.minDriverMs > 0) { 
					timeClass = "text-green-500 font-bold"; 
					symbol = "‚úÖ"; 
				}

				const mainRow = document.createElement('tr');
				mainRow.className = rowClass;
				mainRow.innerHTML = `
					<td class="text-center cursor-pointer p-2 hover:text-ice" onclick="toggleLog(${i})">${d.isExpanded ? '‚ñ≤' : '‚ñº'}</td>
					<td class="py-2 pr-2">${d.name} ${symbol}</td>
					<td class="py-2 text-center">${d.stints}${i === state.currentDriverIdx && !state.isInPit ? '+1' : ''}</td>
					<td class="py-2 ${timeClass}">${fmtHMS(tot)}</td>
				`;
				tb.appendChild(mainRow);

				let logContent = '';
				
				// Show past stints
				d.logs.forEach((l, idx) => {
					logContent += `
						<div class="flex justify-between items-center text-[10px] py-1 border-b border-gray-800">
							<span class="text-gray-500">#${l.globalStintNum || idx + 1}</span>
							<span class="text-ice">${fmtHMS(l.drive)}</span>
							<span class="text-fuel">${l.pit ? fmtHMS(l.pit) : '--'}</span>
						</div>
					`;
				});
				
				// Show current running stint for active driver
				if (i === state.currentDriverIdx && !state.isInPit && stintMs > 0) {
					logContent += `
						<div class="flex justify-between items-center text-[10px] py-1 border-b border-gray-800 bg-ice/10">
							<span class="text-ice font-bold">#${state.globalStintNumber} üèéÔ∏è</span>
							<span id="currentStintTime_${i}" class="text-ice font-bold">${fmtHMS(stintMs)}</span>
							<span class="text-gray-500">--</span>
						</div>
					`;
				}

				const logRow = document.createElement('tr');
				logRow.className = d.isExpanded ? '' : 'hidden';
				logRow.innerHTML = `
					<td colspan="4" class="bg-navy-950 p-2">
						<div class="flex justify-between text-[10px] text-gray-500 border-b border-gray-700 pb-1 mb-1">
							<span>Stint</span>
							<span>Drive</span>
							<span>Pit</span>
						</div>
						${logContent || '<div class="text-gray-600 text-[10px]">No stints yet</div>'}
					</td>
				`;
				tb.appendChild(logRow);
			});
		}

        // ==================== PIT STOP ====================
        function confirmPitEntry() {
			const now = Date.now();
			const sTime = (now - state.stintStart) + state.stintOffset;
			
			if (state.mode !== 'bad' && sTime < config.minStintMs) {
				if (!confirm(t('confirmEarlyPit'))) return;
			}

			// --- Strategy Delta Calculation ---
			// 1. Calculate actual duration of the stint we just finished
			const actualDuration = sTime;
			
			// 2. Get what was planned for this stint
			const plannedDuration = state.stintTargets[state.globalStintNumber - 1] || state.targetStintMs;
			
			// 3. Calculate Delta (Positive = drove longer than planned, Negative = pitted early)
			const delta = actualDuration - plannedDuration;
			
			state.deltaHistory.push({ 
				stint: state.globalStintNumber, 
				planned: plannedDuration,
				actual: actualDuration,
				delta: delta 
			});
			
			console.log(`Stint #${state.globalStintNumber} Finish. Plan: ${fmtHMS(plannedDuration)}, Actual: ${fmtHMS(actualDuration)}, Delta: ${(delta/1000).toFixed(1)}s`);

			// 4. Update Future Targets ("Burn" or "Save" time)
			const stintsRemaining = state.stintTargets.length - state.globalStintNumber;
			if (stintsRemaining > 0) {
				// Distribute the delta across remaining stints
				// If we drove 2 mins EXTRA (delta > 0), we can drive LESS in future stints (subtract positive delta)
				const correctionPerStint = Math.floor(delta / stintsRemaining);
				
				for (let i = state.globalStintNumber; i < state.stintTargets.length; i++) {
					state.stintTargets[i] -= correctionPerStint;
				}
				console.log(`Updated future targets by subtracting ${(correctionPerStint/1000).toFixed(1)}s per stint`);
			}
			// ----------------------------------

			state.isInPit = true;
			state.pendingPitEntry = false;
			state.pitStart = Date.now();
			
			const driveTime = (now - state.stintStart) + state.stintOffset;
			drivers[state.currentDriverIdx].totalMs += driveTime;
			drivers[state.currentDriverIdx].stints++;
			drivers[state.currentDriverIdx].logs.push({ 
				drive: driveTime, 
				pit: null,
				globalStintNum: state.globalStintNumber
			});
			state.globalStintNumber++;

			state.stintOffset = 0;
			if (state.squadsActive && drivers[state.nextDriverIdx].squad !== state.activeSquad) {
				state.activeSquad = drivers[state.nextDriverIdx].squad;
			}
			broadcast();

			document.getElementById('pitModal').classList.remove('hidden');
			document.getElementById('pitPhase2').classList.remove('hidden');
			document.getElementById('modalNextDriverName').innerText = drivers[state.nextDriverIdx].name;

			if (config.trackFuel) document.getElementById('fuelToggleContainer').classList.remove('hidden');
			else document.getElementById('fuelToggleContainer').classList.add('hidden');

			const notifyBtn = document.getElementById('notifyBtn');
			const notifiedMsg = document.getElementById('notifiedMsg');
			const confirmBtn = document.getElementById('confirmExitBtn');
			
			notifyBtn.classList.add('hidden');
			notifiedMsg.classList.add('hidden');
			confirmBtn.disabled = true;
			confirmBtn.innerText = t('wait');
			confirmBtn.className = "w-full bg-gray-800 text-gray-600 font-bold py-4 rounded-lg text-xl border border-gray-700 mb-4";
			
			let notified = false;
			let canExit = false;
			const releaseBuffer = config.releaseBufferSec || 0;

			notifyBtn.onclick = () => {
				notified = true;
				notifyBtn.classList.add('hidden');
				notifiedMsg.classList.remove('hidden');
				beep(800, 'sine', 0.3);
				setTimeout(() => beep(1000, 'sine', 0.2), 150);
			};

			confirmBtn.onclick = () => {
				if (!canExit) return;
				
				clearInterval(pitInterval);
				
				const pitTime = Date.now() - state.pitStart;
				const lastLog = drivers[state.currentDriverIdx].logs[drivers[state.currentDriverIdx].logs.length - 1];
				if (lastLog) lastLog.pit = pitTime;

				state.pitCount++; 
				state.currentDriverIdx = state.nextDriverIdx; 
				
				let nextCand = (state.currentDriverIdx + 1) % drivers.length;
				if (state.squadsActive) {
					let found = drivers.findIndex((d, i) => i !== state.currentDriverIdx && d.squad === state.activeSquad);
					if (found !== -1) nextCand = found;
				}
				state.nextDriverIdx = nextCand;

				state.stintStart = Date.now(); 
				state.isInPit = false; 
				state.mode = 'normal';
				
				const isRefuel = document.getElementById('isRefuelCheck')?.checked ?? true;
				if (!config.trackFuel || isRefuel) state.fuelStart = Date.now();

				document.getElementById('pitModal').classList.add('hidden');
				document.getElementById('pitPhase2').classList.add('hidden');
				document.getElementById('btnResetMode').classList.add('hidden');
				saveRaceState();
				broadcast();
			};

			if (pitInterval) clearInterval(pitInterval);
			
			pitInterval = setInterval(() => {
				const elapsed = (Date.now() - state.pitStart) / 1000;
				const remaining = config.minPitSec - elapsed;
				const timeToNotify = remaining - releaseBuffer;
				
				if (remaining > 0) {
					document.getElementById('pitTimerDisplay').innerText = Math.ceil(remaining);
					document.getElementById('pitTimerDisplay').className = "text-5xl font-bold big-digit text-red-500 font-mono";
				} else {
					document.getElementById('pitTimerDisplay').innerText = "0";
					document.getElementById('pitTimerDisplay').className = "text-5xl font-bold big-digit text-green-500 font-mono";
				}
				
				if (releaseBuffer > 0 && timeToNotify <= 0 && !notified && remaining > 0) {
					notifyBtn.classList.remove('hidden');
					notifyBtn.innerHTML = `üì¢ ${t('notifyDriver')} (${Math.ceil(remaining)}s)`;
					beep(600, 'sine', 0.2);
				}
				
				if (!notified && remaining > 0 && timeToNotify <= 0) {
					notifyBtn.innerHTML = `üì¢ ${t('notifyDriver')} (${Math.ceil(remaining)}s)`;
				}
				
				if (remaining <= 0 && !canExit) {
					canExit = true;
					notifyBtn.classList.add('hidden');
					confirmBtn.disabled = false;
					confirmBtn.innerText = t('confirmExit');
					confirmBtn.className = "w-full bg-green-500 text-black font-bold py-6 rounded-lg text-2xl shadow-[0_0_20px_#22c55e]";
					beep(800, 'square', 0.5);
				}
				
				updateStats(0);
			}, 100);
		}

        function closePitMenu() { 
            state.pendingPitEntry = false;
            document.getElementById('pitModal').classList.add('hidden'); 
        }
        
        function cancelPitStop() {
            clearInterval(pitInterval);
            
            const lastLog = drivers[state.currentDriverIdx].logs.pop();
            if (lastLog) {
                drivers[state.currentDriverIdx].totalMs -= lastLog.drive;
                drivers[state.currentDriverIdx].stints--;
                state.stintOffset = lastLog.drive;
                state.stintStart = Date.now() - state.stintOffset;
                state.stintOffset = 0;
            }
            
            state.isInPit = false;
            state.pendingPitEntry = false;
            
            document.getElementById('pitModal').classList.add('hidden');
            broadcast();
        }

        // ==================== CONTROLS ====================
		function copyHostCode() {
			const codeEl = document.getElementById('dashboardHostId');
			const code = codeEl.innerText;
			
			if (!code || code === '---') return;

			// ◊ô◊¶◊ô◊®◊™ ◊ß◊ô◊©◊ï◊® ◊ó◊õ◊ù ◊©◊õ◊ï◊ú◊ú ◊ê◊™ ◊î◊ß◊ï◊ì
			const magicLink = `${window.location.origin}${window.location.pathname}?join=${code}`;

			navigator.clipboard.writeText(magicLink).then(() => {
				// ◊§◊ô◊ì◊ë◊ß ◊û◊í◊†◊ô◊ë ◊ú◊û◊©◊™◊û◊©
				const originalText = codeEl.innerText;
				codeEl.innerText = "Link Copied! üîó";
				codeEl.classList.add('text-green-400');
				
				setTimeout(() => {
					codeEl.innerText = originalText;
					codeEl.classList.remove('text-green-400');
				}, 2000);
			}).catch(err => {
				console.error('Failed to copy: ', err);
			});
		}

		// Fallback for older browsers / iOS
		function fallbackCopy(text) {
			const textArea = document.createElement('textarea');
			textArea.value = text;
			textArea.style.position = 'fixed';
			textArea.style.left = '-9999px';
			textArea.style.top = '0';
			document.body.appendChild(textArea);
			textArea.focus();
			textArea.select();
			
			try {
				document.execCommand('copy');
				const codeEl = document.getElementById('dashboardHostId');
				if (codeEl) {
					codeEl.classList.add('text-white');
					setTimeout(() => codeEl.classList.remove('text-white'), 1000);
				}
				console.log('‚úÖ Code copied:', text);
			} catch (err) {
				console.error('Copy failed:', err);
				alert('Copy code: ' + text);
			}
			
			document.body.removeChild(textArea);
		}
		
        function adjustStint(ms) { 
            state.stintOffset += ms; 
            broadcast(); 
            renderFrame(); 
        }
		
		function cycleNextDriver() {
			if (role !== 'host') return;
			
			// Find eligible drivers (not current driver, and if squads active - same squad)
			let eligible = [];
			drivers.forEach((d, i) => {
				if (i === state.currentDriverIdx) return; // Skip current driver
				if (state.squadsActive && d.squad !== state.activeSquad) return; // Skip other squad if night mode
				eligible.push(i);
			});
			
			if (eligible.length === 0) return;
			
			// Find current position in eligible list and move to next
			const currentPos = eligible.indexOf(state.nextDriverIdx);
			const nextPos = (currentPos + 1) % eligible.length;
			state.nextDriverIdx = eligible[nextPos];
			
			broadcast();
			renderFrame();
		}
        
        function toggleNightMode() { 
            if (role === 'host') { 
                state.squadsActive = !state.squadsActive; 
                
                updateButtonVisibility(); // <--- Update Visibility Here
                
                broadcast(); 
                renderFrame(); 
            } 
        }
        
        function toggleRain() {
			if (role === 'host') {
				if (!state.trackCondition || state.trackCondition === 'dry') {
					state.trackCondition = 'wet';
				} else if (state.trackCondition === 'wet') {
					state.trackCondition = 'drying';
				} else {
					state.trackCondition = 'dry';
				}
				
				broadcast();
				renderFrame();
			}
		}
        
		function setMode(m) { 
			// Toggle mode instead of replacing
			if (m === 'push') {
				state.pushMode = !state.pushMode;
				if (state.pushMode) state.badMode = false; // Push cancels Problem
			} else if (m === 'bad') {
				state.badMode = !state.badMode;
				if (state.badMode) state.pushMode = false; // Problem cancels Push
			} else if (m === 'normal') {
				state.pushMode = false;
				state.badMode = false;
			}
			
			// Legacy compatibility
			state.mode = state.badMode ? 'bad' : (state.pushMode ? 'push' : 'normal');
			
			updateButtonVisibility(); // <--- Update Visibility Here
			
			recalculateTargetStint();
			broadcast(); 
			renderFrame();
		}

		function recalculateTargetStint() {
			const now = Date.now();
			const raceElapsed = now - state.startTime;
			const raceRemaining = config.raceMs - raceElapsed;
			const stopsRemaining = Math.max(0, config.reqStops - state.pitCount);
			
			// Estimate remaining pit time
			const remainingPitTimeMs = stopsRemaining * config.minPitSec * 1000;
			
			// Available driving time remaining
			const drivingTimeRemaining = raceRemaining - remainingPitTimeMs;
			
			if (state.mode === 'push') {
				state.targetStintMs = config.maxStintMs - 60000; // Max - 1 minute for safety
			} else if (state.mode === 'bad') {
				state.targetStintMs = config.minStintMs;
			} else {
				if (stopsRemaining > 0) {
					// Divide remaining driving time by remaining stints
					state.targetStintMs = Math.floor(drivingTimeRemaining / (stopsRemaining + 1));
				} else {
					state.targetStintMs = drivingTimeRemaining;
				}
				// Clamp to valid range
				state.targetStintMs = Math.min(state.targetStintMs, config.maxStintMs - 60000);
				state.targetStintMs = Math.max(state.targetStintMs, config.minStintMs);
			}
		}
        
        function toggleLog(idx) { 
            drivers[idx].isExpanded = !drivers[idx].isExpanded; 
            updateStats(state.isInPit ? 0 : (Date.now() - state.stintStart + state.stintOffset)); 
        }

        // ==================== UI INITIALIZATION ====================
        function startHostUI() { 
			document.getElementById('setupScreen').classList.add('hidden'); 
			document.getElementById('btnResetMode').classList.add('hidden');
			document.getElementById('raceDashboard').classList.remove('hidden'); 
			document.getElementById('syncControls').classList.remove('hidden');
			document.getElementById('hostCodeDisplay').classList.remove('hidden');
			document.getElementById('dashboardHostId').innerText = myId || '---';
			document.getElementById('zoneForbidden').style.width = ((config.minStintMs / config.maxStintMs) * 100) + '%'; 

			if (liveTimingConfig.enabled) {
				document.getElementById('liveTimingPanel').classList.remove('hidden');
				document.getElementById('liveIndicator').classList.remove('hidden');
			}

			// Auto-save race state every 5 seconds
			if (!window.raceSaveInterval) {
				window.raceSaveInterval = setInterval(() => {
					if (role === 'host' && state.isRunning) {
						saveRaceState();
					}
				}, 5000);
			}

			keepScreenAwake();
			
			raceInterval = setInterval(() => { 
				tick(); 
				broadcast(); 
			}, 1000); 
			
			tick(); 
			updateStats(0);
			applyViewerMode();
		}
        
        function startClientUI() {
			if (!config || !drivers || !state) {
				console.error("Missing data for client UI", { config, drivers, state });
				return;
			}
			
			if (!state.isRunning) {
				console.log("Race not started yet");
				return;
			}
			
			document.getElementById('setupScreen').classList.add('hidden');
			document.getElementById('raceDashboard').classList.remove('hidden');
			document.getElementById('zoneForbidden').style.width = ((config.minStintMs / config.maxStintMs) * 100) + '%';
			
			if (liveTimingConfig && liveTimingConfig.enabled) {
				document.getElementById('liveTimingPanel').classList.remove('hidden');
				document.getElementById('liveIndicator').classList.remove('hidden');
			}
			
			keepScreenAwake();
			
			// ‚úÖ ◊î◊ï◊°◊£ auto-update ◊úviewer
			if (!window.viewerInterval) {
				window.viewerInterval = setInterval(() => {
					if (role === 'client') {
						renderFrame();
					}
				}, 1000);
			}
			
			renderFrame();
			updateStats(syncedTimes ? syncedTimes.stintElapsed : 0);
		}

		// ==================== GOOGLE INTEGRATION ====================
		const GOOGLE_CLIENT_ID = '944328539678-cm1ao0asklck15o9rpneh48nbdtpdstk.apps.googleusercontent.com'; 
		let googleUser = null;
		let googleAccessToken = null;

		// Initialize Google Sign-In
		function initGoogleAuth() {
			if (typeof google === 'undefined') {
				console.log('Google API not loaded yet');
				setTimeout(initGoogleAuth, 1000);
				return;
			}
			
			// Check for existing session
			const savedUser = localStorage.getItem('strateger_google_user');
			if (savedUser) {
				try {
					googleUser = JSON.parse(savedUser);
					updateGoogleUI(true);
				} catch (e) {
					localStorage.removeItem('strateger_google_user');
				}
			}
			
			console.log('‚úÖ Google Auth initialized');
		}

		// Google Sign In - Request token with scopes
		function googleSignIn() {
			if (typeof google === 'undefined') {
				alert('Google API not loaded. Please refresh the page.');
				return;
			}
			
			const client = google.accounts.oauth2.initTokenClient({
				client_id: GOOGLE_CLIENT_ID,
				scope: 'https://www.googleapis.com/auth/gmail.send https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile',
				callback: async (tokenResponse) => {
					if (tokenResponse.error) {
						console.error('Auth error:', tokenResponse.error);
						alert('Sign in failed: ' + tokenResponse.error);
						return;
					}
					
					googleAccessToken = tokenResponse.access_token;
					console.log('‚úÖ Got access token');
					
					// Fetch user info
					await fetchGoogleUserInfo(tokenResponse.access_token);
				}
			});
			
			client.requestAccessToken();
		}

		// Fetch user info with access token
		async function fetchGoogleUserInfo(accessToken) {
			try {
				const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
					headers: { Authorization: `Bearer ${accessToken}` }
				});
				
				if (!response.ok) throw new Error('Failed to fetch user info');
				
				const data = await response.json();
				
				googleUser = {
					name: data.name,
					email: data.email,
					picture: data.picture,
					id: data.id
				};
				
				localStorage.setItem('strateger_google_user', JSON.stringify(googleUser));
				updateGoogleUI(true);
				console.log('‚úÖ Signed in as:', googleUser.name);
				
			} catch (error) {
				console.error('Error fetching user info:', error);
				alert('Error getting user info: ' + error.message);
			}
		}

		// Google Sign Out
		function googleSignOut() {
			if (googleAccessToken) {
				// Revoke the token
				google.accounts.oauth2.revoke(googleAccessToken, () => {
					console.log('Token revoked');
				});
			}
			
			googleUser = null;
			googleAccessToken = null;
			localStorage.removeItem('strateger_google_user');
			updateGoogleUI(false);
			console.log('‚úÖ Signed out');
		}

		// Update UI based on sign-in state
		function updateGoogleUI(signedIn) {
			const signInContainer = document.getElementById('googleSignInContainer');
			const signedInView = document.getElementById('googleSignedIn');
			const statusEl = document.getElementById('googleStatus');
			
			if (!signInContainer || !signedInView || !statusEl) return;
			
			if (signedIn && googleUser) {
				signInContainer.classList.add('hidden');
				signedInView.classList.remove('hidden');
				statusEl.innerText = '‚úÖ Connected';
				statusEl.className = 'text-[10px] text-green-400';
				
				const avatarEl = document.getElementById('googleAvatar');
				const nameEl = document.getElementById('googleName');
				const emailEl = document.getElementById('googleEmail');
				
				if (avatarEl) avatarEl.src = googleUser.picture || '';
				if (nameEl) nameEl.innerText = googleUser.name || 'User';
				if (emailEl) emailEl.innerText = googleUser.email || '';
			} else {
				signInContainer.classList.remove('hidden');
				signedInView.classList.add('hidden');
				statusEl.innerText = 'Not connected';
				statusEl.className = 'text-[10px] text-gray-500';
			}
		}

		// Initialize when page loads
		document.addEventListener('DOMContentLoaded', () => {
			setTimeout(initGoogleAuth, 1500);
		});

    </script>
	<!-- Hide preview when dashboard is active -->
	<script>
	(function() {
		const dashboard = document.getElementById('raceDashboard');
		const preview = document.getElementById('previewScreen');
		
		if (dashboard && preview) {
			const observer = new MutationObserver(() => {
				if (!dashboard.classList.contains('hidden')) {
					preview.classList.add('hidden');
				}
			});
			observer.observe(dashboard, { attributes: true, attributeFilter: ['class'] });
		}
	})();
	</script>
	<!-- Email Team Modal -->
	<div id="emailTeamModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex items-center justify-center p-4">
		<div class="bg-navy-900 rounded-lg border border-gray-700 w-full max-w-md p-4">
			<div class="flex items-center justify-between mb-4">
				<h3 class="text-ice text-lg font-bold">
					<i class="fas fa-envelope mr-2"></i>
					<span data-i18n="emailTeam">Email Team</span>
				</h3>
				<button onclick="closeEmailModal()" class="text-gray-400 hover:text-white">&times;</button>
			</div>
			
			<div class="space-y-3">
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="recipients">Recipients (comma separated)</label>
					<input type="text" id="emailRecipients" placeholder="driver1@email.com, driver2@email.com" 
						class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="emailSubject">Subject</label>
					<input type="text" id="emailSubject" value="üèÅ Race Strategy Update" 
						class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="message">Message</label>
					<textarea id="emailMessage" rows="4" placeholder="Race details and strategy..."
							class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm resize-none"></textarea>
				</div>
				
				<div class="flex items-center gap-2 bg-navy-800 p-2 rounded">
					<input type="checkbox" id="attachStrategy" checked class="w-4 h-4 accent-ice">
					<label class="text-sm text-gray-300" data-i18n="attachStrategy">Attach current strategy</label>
				</div>
				
				<button onclick="sendTeamEmail()" class="w-full bg-ice text-navy-950 font-bold py-3 rounded-lg">
					<i class="fas fa-paper-plane mr-2"></i>
					<span data-i18n="sendEmail">Send Email</span>
				</button>
			</div>
		</div>
	</div>

	<!-- Calendar Event Modal -->
	<div id="calendarModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex items-center justify-center p-4">
		<div class="bg-navy-900 rounded-lg border border-gray-700 w-full max-w-md p-4">
			<div class="flex items-center justify-between mb-4">
				<h3 class="text-neon text-lg font-bold">
					<i class="fas fa-calendar-plus mr-2"></i>
					<span data-i18n="addToCalendar">Add to Google Calendar</span>
				</h3>
				<button onclick="closeCalendarModal()" class="text-gray-400 hover:text-white">&times;</button>
			</div>
			
			<div class="space-y-3">
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="eventTitle">Event Title</label>
					<input type="text" id="calendarTitle" value="üèéÔ∏è Endurance Race" 
						class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
				</div>
				
				<div class="grid grid-cols-2 gap-2">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="startDate">Start Date</label>
						<input type="date" id="calendarDate" 
							class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="startTime">Start Time</label>
						<input type="time" id="calendarTime" 
							class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="location">Location</label>
					<input type="text" id="calendarLocation" placeholder="Track name..." 
						class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="inviteDrivers">Invite Drivers (emails)</label>
					<input type="text" id="calendarInvites" placeholder="driver1@email.com, driver2@email.com" 
						class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
				</div>
				
				<div class="flex items-center gap-2 bg-navy-800 p-2 rounded">
					<input type="checkbox" id="addReminder" checked class="w-4 h-4 accent-neon">
					<label class="text-sm text-gray-300" data-i18n="addReminder">Add reminder (1 day before)</label>
				</div>
				
				<<button onclick="createCalendarEvent()" class="w-full bg-neon text-navy-950 font-bold py-3 rounded-lg">
					<i class="fas fa-calendar-check mr-2"></i>
					<span data-i18n="createEvent">Create Event</span>
				</button>
			</div>
		</div>
	</div>

	<script>
	// ==================== EMAIL FUNCTIONS ====================
	function showTeamEmailModal() {
		if (!googleUser) {
			alert('Please sign in with Google first');
			return;
		}
		
		// Pre-fill message with race info
		const raceDur = document.getElementById('raceDuration')?.value || '12';
		const driverInputs = document.querySelectorAll('.driver-input');
		const driverNames = Array.from(driverInputs).map(d => d.value).join(', ');
		
		document.getElementById('emailMessage').value = 
			`Race Details:\n` +
			`üìç Duration: ${raceDur} hours\n` +
			`üë• Drivers: ${driverNames}\n\n` +
			`Please confirm your availability and review the strategy.`;
		
		document.getElementById('emailTeamModal').classList.remove('hidden');
	}

	function closeEmailModal() {
		document.getElementById('emailTeamModal').classList.add('hidden');
	}

	async function sendTeamEmail() {
		if (!googleAccessToken) {
			alert('Please sign in with Google first');
			return;
		}
		
		const recipients = document.getElementById('emailRecipients').value;
		const subject = document.getElementById('emailSubject').value;
		let message = document.getElementById('emailMessage').value;
		const attachStrategy = document.getElementById('attachStrategy').checked;
		
		if (!recipients || !subject) {
			alert('Please fill in recipients and subject');
			return;
		}
		
		// Add strategy summary if checkbox is checked
		if (attachStrategy) {
			message += '\n\n';
			message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
			message += 'üèÅ RACE STRATEGY SUMMARY\n';
			message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
			
			// Basic race info from config
			if (config && config.raceMs) {
				const raceDurHours = (config.raceMs / 3600000).toFixed(1);
				message += `‚è±Ô∏è Race Duration: ${raceDurHours} hours\n`;
				message += `üîß Required Pit Stops: ${config.reqStops || 0}\n`;
				message += `üìä Stint Range: ${(config.minStintMs/60000).toFixed(0)}-${(config.maxStintMs/60000).toFixed(0)} minutes\n`;
				message += `‚è∞ Min Pit Time: ${config.minPitSec || 0} seconds\n\n`;
			}
			
			// Driver info from preview or current drivers
			if (previewData && previewData.driverSchedule && previewData.driverSchedule.length > 0) {
				message += 'üë• DRIVER SCHEDULE:\n';
				message += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
				previewData.driverSchedule.forEach((d, idx) => {
					const avgStint = d.totalTime / d.stints.length;
					message += `${idx + 1}. ${d.name}\n`;
					message += `   ‚Ä¢ Stints: ${d.stints.length}\n`;
					message += `   ‚Ä¢ Total Time: ${formatTime(d.totalTime)}\n`;
					message += `   ‚Ä¢ Avg Stint: ${formatTime(avgStint)}\n`;
					if (d.stints && d.stints.length > 0) {
						message += `   ‚Ä¢ Stint Numbers: ${d.stints.map(s => '#' + s.globalNumber).join(', ')}\n`;
					}
					message += '\n';
				});
			} else if (drivers && drivers.length > 0) {
				// Fallback to drivers array
				message += 'üë• DRIVERS:\n';
				message += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
				drivers.forEach((d, idx) => {
					message += `${idx + 1}. ${d.name}`;
					if (config.useSquads) message += ` (Squad ${d.squad})`;
					message += '\n';
				});
				message += '\n';
			}
			
			// Timeline info
			if (previewData && previewData.timeline && previewData.timeline.length > 0) {
				const stints = previewData.timeline.filter(t => t.type === 'stint');
				const pits = previewData.timeline.filter(t => t.type === 'pit');
				
				message += 'üìã STINT TIMELINE:\n';
				message += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
				stints.forEach(stint => {
					const startTime = stint.startTime ? new Date(stint.startTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '--:--';
					const endTime = stint.endTime ? new Date(stint.endTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '--:--';
					message += `#${stint.stintNumber} | ${stint.driverName} | ${startTime} ‚Üí ${endTime} | ${formatTime(stint.duration)}\n`;
				});
				message += '\n';
				
				message += `üìä Total Stints: ${stints.length}\n`;
				message += `üîß Total Pit Stops: ${pits.length}\n`;
			}
			
			message += '\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
			message += 'üì± Powered by Strateger\n';
			message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
		}
		
		try {
			// Create email in RFC 2822 format
			const email = [
				`To: ${recipients}`,
				`Subject: ${subject}`,
				`Content-Type: text/plain; charset=utf-8`,
				'',
				message
			].join('\r\n');
			
			// Encode for Gmail API
			const encodedEmail = btoa(unescape(encodeURIComponent(email)))
				.replace(/\+/g, '-')
				.replace(/\//g, '_')
				.replace(/=+$/, '');
			
			console.log('üìß Sending email to:', recipients);
			console.log('üìß Subject:', subject);
			console.log('üìß Message length:', message.length);
			
			const response = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages/send', {
				method: 'POST',
				headers: {
					'Authorization': `Bearer ${googleAccessToken}`,
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({ raw: encodedEmail })
			});
			
			if (response.ok) {
				const result = await response.json();
				console.log('‚úÖ Email sent! ID:', result.id);
				alert('‚úÖ Email sent successfully!');
				closeEmailModal();
			} else {
				const error = await response.json();
				console.error('‚ùå Gmail API error:', error);
				throw new Error(error.error?.message || 'Failed to send email');
			}
		} catch (error) {
			console.error('Email error:', error);
			alert(`‚ùå Error sending email: ${error.message}`);
		}
	}

	function shareStrategyEmail() {
		if (!previewData) {
			alert('Please generate a strategy preview first');
			return;
		}
		showTeamEmailModal();
		document.getElementById('emailSubject').value = 'üèéÔ∏è Race Strategy - Please Review';
	}

	// ==================== CALENDAR FUNCTIONS ====================
	function showCalendarModal() {
		if (!googleUser) {
			alert('Please sign in with Google first');
			return;
		}
		
		// Set default date to today
		const today = new Date().toISOString().split('T')[0];
		document.getElementById('calendarDate').value = today;
		
		// Set default time
		document.getElementById('calendarTime').value = '09:00';
		
		// Pre-fill with race duration
		const raceDur = document.getElementById('raceDuration')?.value || '12';
		document.getElementById('calendarTitle').value = `üèéÔ∏è ${raceDur}h Endurance Race`;
		
		document.getElementById('calendarModal').classList.remove('hidden');
	}

	function closeCalendarModal() {
		document.getElementById('calendarModal').classList.add('hidden');
	}

	async function createCalendarEvent() {
		if (!googleAccessToken) {
			alert('Please sign in with Google first');
			return;
		}
		
		const title = document.getElementById('calendarTitle').value;
		const date = document.getElementById('calendarDate').value;
		const time = document.getElementById('calendarTime').value;
		const location = document.getElementById('calendarLocation').value;
		const invites = document.getElementById('calendarInvites').value;
		const addReminder = document.getElementById('addReminder').checked;
		
		if (!title || !date || !time) {
			alert('Please fill in title, date and time');
			return;
		}
		
		const raceDurHours = parseFloat(document.getElementById('raceDuration')?.value || 12);
		const startDateTime = new Date(`${date}T${time}`);
		const endDateTime = new Date(startDateTime.getTime() + raceDurHours * 60 * 60 * 1000);
		
		// Build description
		let description = 'Race managed by Strateger\n\n';
		if (previewData?.driverSchedule) {
			description += 'Driver Schedule:\n';
			previewData.driverSchedule.forEach(d => {
				description += `‚Ä¢ ${d.name}: ${d.stints.length} stints\n`;
			});
		}
		
		// Build attendees list
		const attendees = invites.split(',')
			.map(e => e.trim())
			.filter(e => e.includes('@'))
			.map(email => ({ email }));
		
		const event = {
			summary: title,
			location: location,
			description: description,
			start: {
				dateTime: startDateTime.toISOString(),
				timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
			},
			end: {
				dateTime: endDateTime.toISOString(),
				timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
			},
			attendees: attendees.length > 0 ? attendees : undefined,
			reminders: addReminder ? {
				useDefault: false,
				overrides: [
					{ method: 'email', minutes: 24 * 60 },
					{ method: 'popup', minutes: 60 }
				]
			} : { useDefault: true }
		};
		
		try {
			const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events?sendUpdates=all', {
				method: 'POST',
				headers: {
					'Authorization': `Bearer ${googleAccessToken}`,
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(event)
			});
			
			if (response.ok) {
				const result = await response.json();
				alert(`‚úÖ Event created!\n\nOpen in Calendar: ${result.htmlLink}`);
				closeCalendarModal();
			} else {
				const error = await response.json();
				throw new Error(error.error?.message || 'Failed to create event');
			}
		} catch (error) {
			console.error('Calendar error:', error);
			alert(`‚ùå Error creating event: ${error.message}`);
		}
	}

	// ==================== TEAM AVAILABILITY ====================
	async function checkTeamAvailability() {
		if (!googleAccessToken) {
			alert('Please sign in with Google first');
			return;
		}
		
		const date = prompt('Check availability for date (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
		if (!date) return;
		
		try {
			const timeMin = new Date(`${date}T00:00:00`).toISOString();
			const timeMax = new Date(`${date}T23:59:59`).toISOString();
			
			const response = await fetch(
				`https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin=${timeMin}&timeMax=${timeMax}&singleEvents=true`,
				{
					headers: { 'Authorization': `Bearer ${googleAccessToken}` }
				}
			);
			
			if (response.ok) {
				const data = await response.json();
				const events = data.items || [];
				
				if (events.length === 0) {
					alert(`‚úÖ You're free on ${date}!\nNo events scheduled.`);
				} else {
					let msg = `üìÖ Events on ${date}:\n\n`;
					events.forEach(e => {
						const start = new Date(e.start.dateTime || e.start.date);
						msg += `‚Ä¢ ${start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${e.summary}\n`;
					});
					alert(msg);
				}
			}
		} catch (error) {
			console.error('Availability check error:', error);
			alert(`‚ùå Error: ${error.message}`);
		}
	}

	// ==================== AUTO JOIN LOGIC ====================
	window.addEventListener('load', () => {
		const urlParams = new URLSearchParams(window.location.search);
		const joinCode = urlParams.get('join');

		if (joinCode) {
			console.log("üîó ◊ñ◊ï◊î◊î ◊ß◊ô◊©◊ï◊® ◊î◊¶◊ò◊®◊§◊ï◊™:", joinCode);
			
			// 1. ◊î◊°◊™◊®◊™ ◊û◊°◊õ◊ô ◊†◊ô◊î◊ï◊ú (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô, ◊ú◊û◊¢◊ü ◊î◊°◊ì◊® ◊î◊ò◊ï◊ë)
			// document.getElementById('hostControls').classList.add('hidden'); // ◊ê◊ù ◊ô◊© ◊ú◊ö ID ◊õ◊ñ◊î
			
			// 2. ◊û◊ô◊ú◊ï◊ô ◊î◊ß◊ï◊ì ◊ë◊©◊ì◊î (◊ê◊ù ◊ß◊ô◊ô◊ù ◊©◊ì◊î ◊õ◊ñ◊î ◊ë-UI ◊©◊ú ◊î◊ß◊ú◊ô◊ô◊†◊ò)
			const codeInput = document.getElementById('joinCodeInput'); // ◊ï◊ï◊ì◊ê ◊©◊ñ◊î ◊î-ID ◊î◊†◊õ◊ï◊ü ◊ê◊¶◊ú◊ö
			if (codeInput) codeInput.value = joinCode;

			// 3. ◊ë◊ô◊¶◊ï◊¢ ◊î◊¶◊ò◊®◊§◊ï◊™ ◊ë◊§◊ï◊¢◊ú
			// ◊î◊†◊ó◊î: ◊ô◊© ◊ú◊ö ◊§◊ï◊†◊ß◊¶◊ô◊î ◊©◊û◊ó◊ë◊®◊™ ◊ú◊ß◊ï◊ó, ◊ú◊û◊©◊ú joinGame() ◊ê◊ï connectToHost()
			// ◊ê◊ù ◊î◊ú◊ï◊í◊ô◊ß◊î ◊©◊ú◊ö ◊†◊û◊¶◊ê◊™ ◊ë◊™◊ï◊ö ◊õ◊§◊™◊ï◊®, ◊†◊ú◊ó◊• ◊¢◊ú◊ô◊ï ◊ï◊ô◊®◊ò◊ï◊ê◊ú◊ô◊™:
			
			if (typeof joinGame === 'function') {
				joinGame(joinCode);
			} else {
				// ◊ê◊ù ◊ê◊ô◊ü ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ô◊©◊ô◊®◊î, ◊†◊ó◊§◊© ◊ê◊™ ◊õ◊§◊™◊ï◊® ◊î◊î◊¶◊ò◊®◊§◊ï◊™
				const joinBtn = document.getElementById('btnJoinGame'); // ◊ï◊ï◊ì◊ê ◊©◊ñ◊î ◊î-ID
				if (joinBtn && codeInput) {
					joinBtn.click();
				}
			}
			
			// ◊†◊ß◊î ◊ê◊™ ◊î-URL ◊õ◊ì◊ô ◊©◊ñ◊î ◊ú◊ê ◊ô◊®◊ê◊î ◊û◊ú◊ï◊õ◊ú◊ö (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô)
			window.history.replaceState({}, document.title, window.location.pathname);
		}
	});
	</script>

</body>
</html>