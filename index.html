<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Strateger - Race Strategy Manager</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2322d3ee' width='100' height='100' rx='15'/><text x='50' y='70' text-anchor='middle' font-size='60' fill='black' font-weight='bold'>S</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
	<style>
		/* Fallback icons if Font Awesome blocked */
		.fa-server:before { content: "üñ•Ô∏è"; }
		.fa-mobile-screen:before { content: "üì±"; }
		.fa-cloud-rain:before { content: "üåßÔ∏è"; }
		.fa-cloud-showers-heavy:before { content: "üåßÔ∏è"; }
	</style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
	<script src="/js/racefacer-scraper.js"></script>
	<script src="/js/live-timing-manager.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        navy: { 950: '#020617', 900: '#0f172a', 800: '#1e293b', 700: '#334155' },
                        ice: '#22d3ee',
                        neon: '#a3e635',
                        danger: '#ef4444',
                        fuel: '#f97316',
                        squadA: '#3b82f6',
                        squadB: '#06b6d4',
                        live: '#ef4444',
                        gold: '#fbbf24',
                        silver: '#9ca3af',
                        bronze: '#f97316'
                    },
                    animation: { 
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'flash': 'flash 0.5s ease-in-out'
                    }
                }
            }
        }
    </script>
    <style>
	/* Tailwind Fallback for Safari/Offline */
	.hidden { display: none !important; }
	.flex { display: flex; }
	.flex-col { flex-direction: column; }
	.flex-1 { flex: 1 1 0%; }
	.items-center { align-items: center; }
	.justify-center { justify-content: center; }
	.gap-2 { gap: 0.5rem; }
	.gap-3 { gap: 0.75rem; }
	.p-2 { padding: 0.5rem; }
	.p-3 { padding: 0.75rem; }
	.p-4 { padding: 1rem; }
	.rounded { border-radius: 0.25rem; }
	.rounded-lg { border-radius: 0.5rem; }
	.text-white { color: white; }
	.text-center { text-align: center; }
	.font-bold { font-weight: 700; }
	.w-full { width: 100%; }
	.border { border-width: 1px; }
	.bg-navy-950 { background-color: #020617; }
	.bg-navy-900 { background-color: #0f172a; }
	.text-ice { color: #22d3ee; }
	.text-neon { color: #a3e635; }
	/* ◊û◊ï◊†◊¢ auto-scroll ◊¢◊ú focus */
	.starter-radio:focus,
	.starter-indicator:focus {
		outline: none;
		scroll-margin: 0;
		scroll-behavior: auto;
	}
	
        :root {
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);
        }
        
        html, body {
			margin: 0;
			padding: 0;
			height: 100%;
			overflow: hidden;  /* ‚úÖ */
			overscroll-behavior: none;
			-webkit-overflow-scrolling: touch;
		}
        
        body { 
            background: #020617; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding-top: var(--safe-area-top);
            padding-bottom: var(--safe-area-bottom);
        }
        
        .sync-dot { width: 8px; height: 8px; border-radius: 50%; animation: pulse 2s infinite; }
        .live-dot { background: #ef4444; box-shadow: 0 0 8px #ef4444; }
        
        .big-digit { font-variant-numeric: tabular-nums; letter-spacing: 0.05em; }
        
        .btn-press { 
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-press:active { transform: scale(0.95); }
        
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .flash-alert { animation: flash 0.3s ease-in-out 3; }
        
        /* Progress bar zones */
        .zone-forbidden { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 5px, #991b1b 5px, #991b1b 10px); opacity: 0.3; }
        .zone-optimal { background: linear-gradient(90deg, #22c55e, #a3e635); }
        
        /* RTL support */
        [dir="rtl"] .grid { direction: rtl; }
        
        /* Live Timing styles */
        .position-up { color: #22c55e; }
        .position-down { color: #ef4444; }
        .position-same { color: #9ca3af; }
        .competitor-row { transition: background-color 0.3s; }
        .competitor-row.our-team { background: rgba(34, 211, 238, 0.2); border: 1px solid #22d3ee; }
        .competitor-row.danger-zone { background: rgba(239, 68, 68, 0.15); }
        
        /* Scrollable lists */
        .overflow-y-auto { overflow-y: auto !important; -webkit-overflow-scrolling: touch; }
		
		/* Radio button styling */
		input[type="radio"]:checked + span { color: #22d3ee; font-weight: bold; }
		.has-\[\:checked\]\:border-ice:has(:checked) { border-color: #22d3ee; }
		.has-\[\:checked\]\:bg-ice\/20:has(:checked) { background-color: rgba(34, 211, 238, 0.2); }
		
		/* Starter radio styling */
		.starter-radio:checked + div {
			border-color: #22d3ee !important;
			background-color: rgba(34, 211, 238, 0.3);
			box-shadow: 0 0 8px rgba(34, 211, 238, 0.5);
		}
		
		/* Responsive design for laptop/desktop */
		@media (min-width: 768px) {
			#raceDashboard {
				max-width: 900px;  /* ‚úÖ ◊©◊ï◊†◊î ◊û-600px ◊ú-900px */
				margin: 0 auto;
				border-left: 1px solid #334155;
				border-right: 1px solid #334155;
			}
			
			#setupScreen .max-w-md {
				max-width: 500px;
			}
		}

		/* Extra large screens - ◊ó◊ì◊©! */
		@media (min-width: 1200px) {
			#raceDashboard {
				max-width: 1000px;
			}
		}
		
		#langSelect {
			width: auto !important;
			max-width: 70px;
		}

		/* Viewer mode - disable interactions - ◊ó◊ì◊©! */
		.viewer-mode button:not(.btn-view-only),
		.viewer-mode .editable,
		.viewer-mode input,
		.viewer-mode select:not(#langSelect),
		.viewer-mode .host-only {
			display: none !important;
		}

		.viewer-mode .btn-view-only {
			cursor: default !important;
			pointer-events: auto !important;
		}

		/* Preview screen responsive fixes */
		@media (max-width: 640px) {
			/* EXISTING RULES - KEEP THESE */
			header .flex {
				flex-direction: column;
				align-items: stretch;
			}
			
			#hostCodeDisplay {
				order: -1;
				margin-bottom: 0.5rem;
			}
			
			.header-info-grid {
				display: grid;
				grid-template-columns: 1fr;
				gap: 0.5rem;
				width: 100%;
			}
			
			.header-info-item {
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 0.5rem;
				background: rgba(15, 23, 42, 0.5);
				border-radius: 0.5rem;
			}
			
			.header-info-label {
				font-size: 0.65rem;
				color: #9ca3af;
				margin-bottom: 0.25rem;
			}
			
			.header-info-value {
				font-size: 1.25rem;
				font-weight: bold;
			}
			
			/* ADD THESE NEW RULES */
			.simulation-preview {
				padding: 0.75rem;
			}
			
			.simulation-preview h2 {
				font-size: 1.25rem;
			}
			
			.simulation-preview h3 {
				font-size: 1rem;
			}
			
			/* Stack preview buttons vertically on phones */
			#previewScreen .flex.gap-3:last-of-type {
				flex-direction: column;
			}
			
			#previewScreen .flex.gap-3:last-of-type button {
				width: 100%;
			}
			
			/* Strategy summary - single column */
			#strategySummary {
				grid-template-columns: 1fr !important;
			}
		}
		
		@media (min-width: 1024px) {
			#raceDashboard {
				max-width: 700px;
			}
			
			.text-4xl {
				font-size: 3rem;
			}
			
			.text-2xl {
				font-size: 1.75rem;
			}
		}
		
		/* Dynamic grid for control buttons */
		.control-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 0.5rem;
		}

		.control-grid.no-night {
			grid-template-columns: repeat(2, 1fr);
		}

		@media (max-width: 640px) {
			.control-grid {
				grid-template-columns: repeat(2, 1fr);
			}
			
			.control-grid.no-night {
				grid-template-columns: 1fr;
			}
		}
		
		/* Pre-race simulation preview */
		.simulation-preview {
			background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
			border: 2px solid #22d3ee;
			border-radius: 1rem;
			padding: 1rem;
		}

		.stint-timeline {
			position: relative;
			height: 60px;
			background: #0f172a;
			border-radius: 0.5rem;
			overflow: hidden;
		}

		.stint-block {
			position: absolute;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.75rem;
			font-weight: bold;
			border-right: 2px solid #020617;
			transition: all 0.3s;
		}

		.stint-block:hover {
			transform: scaleY(1.1);
			z-index: 10;
		}

		.pit-marker {
			position: absolute;
			width: 3px;
			height: 100%;
			background: #ef4444;
			box-shadow: 0 0 8px #ef4444;
		}

		.time-marker {
			position: absolute;
			bottom: -20px;
			font-size: 0.65rem;
			color: #9ca3af;
			transform: translateX(-50%);
		}
		
		#driversList {
			-webkit-overflow-scrolling: touch;
		}
		
		/* Prevent over-scrolling in setup and preview screens */
		#setupScreen {
			overflow-y: auto !important;
			-webkit-overflow-scrolling: touch;
			height: 100%;
			max-height: 100vh;
			padding-bottom: env(safe-area-inset-bottom, 1rem);
		}

		#previewScreen {
			max-height: 100vh;
			overflow-y: auto;
			padding-bottom: env(safe-area-inset-bottom, 1rem);
		}

		/* Ensure content doesn't extend beyond last button */
		#setupScreen > div,
		#previewScreen > div {
			padding-bottom: 2rem;
		}

		/* Make sure buttons stay visible */
		#startRaceBtn,
		#previewScreen .flex.gap-3:last-of-type {
			margin-bottom: 0;
		}
    </style>
</head>
<body class="bg-navy-950 text-gray-200 min-h-screen flex flex-col">
    <!-- Header -->
	<header class="bg-navy-900 border-b border-gray-800 p-2 shrink-0">
		<div class="flex justify-between items-center gap-3">
			<!-- Code & Viewers - ◊û◊©◊û◊ê◊ú -->
			<div class="flex items-center gap-2">
				<div id="hostCodeDisplay" class="hidden flex items-center gap-2 bg-navy-800 px-3 py-2 rounded border border-ice/50">
					<i class="fas text-ice text-sm"></i>
					<span class="text-[10px] text-gray-400" data-i18n="code">Code:</span>
					<code id="dashboardHostId" class="text-ice font-mono font-bold text-sm">---</code>
					<button onclick="copyHostCode()" class="text-gray-400 hover:text-white transition-colors ml-1" title="Copy code">
						<i class="fas fa-copy text-xs"></i>
					</button>
				</div>
				
				<div id="syncControls" class="hidden flex items-center gap-2 bg-navy-800 px-3 py-2 rounded border border-gray-700">
					<span id="syncDot" class="sync-dot bg-green-500"></span>
					<span id="syncText" class="text-xs text-gray-400" data-i18n="synced">Synced</span>
				</div>
				
				<div id="liveIndicator" class="hidden sync-dot live-dot"></div>
			</div>
			
			<!-- Language Select - ◊û◊ô◊û◊ô◊ü -->
			<select id="langSelect" onchange="setLanguage(this.value)" 
					class="text-xs bg-navy-800 px-2 py-1 rounded border border-gray-700 hover:bg-navy-700 text-white cursor-pointer">
				<option value="en">EN</option>
				<option value="he">HE</option>
				<option value="fr">FR</option>
				<option value="pt">PT</option>
			</select>
		</div>
	</header>

    <!-- Setup Screen -->
    <div id="setupScreen" class="flex-1 overflow-y-auto p-4">
        <div class="max-w-md mx-auto">
            <div class="text-center mb-4">
				<h1 class="text-2xl font-bold text-white tracking-widest">STRAT<span class="text-ice">EGER</span></h1>
                <p class="text-[10px] text-gray-500 mt-1" data-i18n="subtitle">Endurance Race Strategy Manager</p>
            </div>

            <!-- Role Selection -->
            <div class="grid grid-cols-2 gap-3 mb-4">
                <button onclick="selectRole('host')" id="hostBtn" class="bg-navy-800 border-2 border-navy-700 rounded-lg p-4 text-center hover:border-ice transition group">
                    <i class="fa-solid fa-server text-3xl text-gray-400 group-hover:text-ice mb-2"></i>
                    <p class="text-sm font-bold" data-i18n="host">Host</p>
                    <p class="text-[10px] text-gray-500" data-i18n="hostDesc">Manage the race</p>
                </button>
                <button onclick="selectRole('client')" id="clientBtn" class="bg-navy-800 border-2 border-navy-700 rounded-lg p-4 text-center hover:border-neon transition group">
                    <i class="fa-solid fa-mobile-screen text-3xl text-gray-400 group-hover:text-neon mb-2"></i>
                    <p class="text-sm font-bold" data-i18n="viewer">Viewer</p>
                    <p class="text-[10px] text-gray-500" data-i18n="viewerDesc">Watch live</p>
                </button>
            </div>
			<button id="loadStrategyBtn" onclick="loadStrategyLibrary()" 
					class="hidden w-full bg-navy-800 text-gray-300 text-sm py-2 rounded-lg mb-3 border border-gray-700 hover:border-ice">
				üìö <span data-i18n="loadStrategy">Load Saved Strategy</span>
			</button>

            <!-- Host Section -->
            <div id="hostSection" class="hidden">
                <div class="bg-gradient-to-r from-ice/20 to-navy-800 p-3 rounded-lg border border-ice/50 mb-4">
                    <p class="text-xs text-gray-400 mb-1" data-i18n="yourCode">Your Code:</p>
                    <div class="flex items-center gap-2">
                        <span id="myHostId" class="text-2xl font-mono font-bold text-ice tracking-widest">---</span>
                        <button onclick="copyCode('myHostId')" class="text-gray-400 hover:text-white">üìã</button>
                    </div>
                    <p id="netStatusText" class="text-[10px] text-gray-500 mt-2"></p>
                    <button id="retryBtn" class="hidden text-xs bg-red-900 text-red-300 px-3 py-1 rounded mt-2" onclick="initHostPeer()" data-i18n="retry">Retry</button>
                </div>
                
                <button onclick="toggleConfigPanel(event)" class="w-full bg-navy-800 text-gray-300 text-sm py-2 rounded-lg mb-3 border border-gray-700 flex items-center justify-center gap-2">
                    <span data-i18n="raceSettings">‚öôÔ∏è Race Settings</span>
                    <span id="configArrow">‚ñº</span>
                </button>
            </div>
            
            <!-- Config Panel -->
            <div id="configPanel" class="space-y-3 hidden transition-opacity duration-300">
                
                <!-- Live Timing Section -->
                <div class="bg-gradient-to-r from-red-900/30 to-navy-800 p-3 rounded-lg border border-red-500/50">
                    <div class="flex items-center gap-2 mb-2">
                        <span class="sync-dot live-dot"></span>
                        <span class="text-sm font-bold text-white" data-i18n="liveTiming">Live Timing (Optional)</span>
                    </div>
                    <div class="space-y-2">
                        <div>
                            <label class="text-[10px] text-gray-400" data-i18n="liveTimingUrl">Live Timing URL (APEX/RaceFacer)</label>
                            <input type="url" id="liveTimingUrl" placeholder="https://live.racefacer.com/race/..." class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
                        </div>
                        
                        <div>
                            <label class="text-[10px] text-gray-400 mb-1 block" data-i18n="searchBy">Search by:</label>
                            <div class="grid grid-cols-3 gap-1 mb-2">
                                <label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
                                    <input type="radio" name="searchType" value="team" checked class="hidden">
                                    <span class="text-[10px] text-gray-300">üèéÔ∏è <span data-i18n="team">Team</span></span>
                                </label>
                                <label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
                                    <input type="radio" name="searchType" value="kart" class="hidden">
                                    <span class="text-[10px] text-gray-300">üî¢ <span data-i18n="kart">Kart</span></span>
                                </label>
                                <label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
                                    <input type="radio" name="searchType" value="driver" class="hidden">
                                    <span class="text-[10px] text-gray-300">üë§ <span data-i18n="driver">Driver</span></span>
                                </label>
                            </div>
                            <input type="text" id="searchValue" placeholder="Enter team name..." class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
                        </div>
                        
                        <div class="flex gap-2">
                            <button onclick="testLiveTiming()" class="flex-1 bg-red-900/50 border border-red-500/50 text-red-300 text-xs py-2 rounded hover:bg-red-900">üî¥ <span data-i18n="testConnection">Test</span></button>
                            <button onclick="startDemoMode()" class="flex-1 bg-neon/20 border border-neon/50 text-neon text-xs py-2 rounded hover:bg-neon/30">üéÆ <span data-i18n="demo">Demo</span></button>
							<button onclick="openManualInput()" class="flex-1 bg-fuel/20 border border-fuel/50 text-fuel text-xs py-2 rounded hover:bg-fuel/30">‚úèÔ∏è <span data-i18n="manual">Manual</span></button>
                        </div>
                        <div id="liveTimingStatus" class="text-[10px] text-gray-500 text-center"></div>
                    </div>
                </div>

                <div id="simResult" class="bg-navy-950 p-2 rounded text-xs text-ice border border-navy-700 font-mono text-center whitespace-pre-line">...</div>

                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="duration">Duration (hours)</label>
                        <input type="number" id="raceDuration" value="12" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="reqStops">Required Stops</label>
                        <input type="number" id="reqPitStops" value="13" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-neon font-bold text-sm">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="minStint">Min Stint (min)</label>
                        <input type="number" id="minStint" value="10" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="maxStint">Max Stint (min)</label>
                        <input type="number" id="maxStint" value="60" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
					<!-- Pit Window Restrictions -->
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="pitClosedStart">üö´ Pit Closed Start (min)</label>
						<input type="number" id="pitClosedStart" min="0" max="120" value="0" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="pitClosedEnd">üö´ Pit Closed End (min)</label>
						<input type="number" id="pitClosedEnd" min="0" max="120" value="0" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
					</div>
                </div>
                
                <div class="bg-navy-800 p-2 rounded border border-gray-700">
                    <p class="text-[10px] text-gray-400 text-center mb-1 font-bold" data-i18n="driverLimits">Driver Limits (0 = no limit)</p>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="text-[10px] text-gray-400" data-i18n="minDrive">Min Drive</label>
                            <input type="number" id="minDriverTime" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
                        </div>
                        <div>
                            <label class="text-[10px] text-gray-400" data-i18n="maxDrive">Max Drive</label>
                            <input type="number" id="maxDriverTime" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="pitTime">Pit Time (sec)</label>
                        <input type="number" id="minPitTime" value="120" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="releaseBuffer">Release Buffer (sec)</label>
                        <input type="number" id="releaseBuffer" value="0" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-fuel text-sm">
                    </div>
                </div>
                
                <div class="grid grid-cols-3 gap-2 border-t border-gray-700 pt-2 mt-2">
					<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
						<input type="checkbox" id="allowDouble" class="w-4 h-4 accent-ice">
						<span class="text-[10px] text-gray-300" data-i18n="doubleStint">Double</span>
					</label>
					<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
						<input type="checkbox" id="trackFuel" onchange="toggleFuelInput()" class="w-4 h-4 accent-fuel">
						<span class="text-[10px] text-gray-300" data-i18n="fuel">Fuel</span>
					</label>
					<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
						<input type="checkbox" id="useSquads" onchange="toggleSquadsInput()" class="w-4 h-4 accent-squadB">
						<span class="text-[10px] text-gray-300" data-i18n="squads">Squads</span>
					</label>
				</div>
                
                <div id="fuelInputDiv" class="hidden">
                    <label class="text-[10px] text-fuel" data-i18n="fuelTankTime">Fuel Tank Time (min)</label>
                    <input type="number" id="maxFuelTime" value="60" class="w-full bg-navy-950 border border-fuel/50 rounded p-2 text-white text-sm">
                </div>

                <div class="pt-2">
                    <div class="flex justify-between items-center mb-1">
                        <label class="text-xs text-gray-400 font-bold" data-i18n="driversSetup">Drivers (mark starter)</label>
                        <div class="space-x-1">
                            <button onclick="addDriverField()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600">+</button>
                            <button onclick="removeDriverField()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600">-</button>
                        </div>
                    </div>
                    <div id="driversList" class="space-y-2 transition-all duration-300"></div>
                </div>
				
				<button onclick="generatePreview()" 
						class="w-full mt-4 bg-gradient-to-r from-purple-600 to-fuchsia-500 hover:from-fuchsia-500 hover:to-purple-600 text-white font-bold py-4 rounded-lg shadow-[0_0_20px_rgba(168,85,247,0.4)] transition-all">
					<i class="fas fa-chart-gantt mr-2"></i>
					<span data-i18n="previewStrategy">Preview Strategy</span>
				</button>
                <button id="startRaceBtn" onclick="initRace()" class="w-full bg-ice hover:bg-cyan-300 text-navy-950 font-bold py-3 rounded-lg text-lg mt-2 shadow-[0_0_15px_rgba(34,211,238,0.3)] transition btn-press" data-i18n="startRace">
                    Start Race (Host)
                </button>
            </div>

            <!-- Client Section -->
            <div id="clientSection" class="hidden">
                <div class="bg-gradient-to-r from-neon/20 to-navy-800 p-3 rounded-lg border border-neon/50">
                    <label class="text-xs text-gray-400" data-i18n="enterCode">Enter Host Code:</label>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="remoteIdInput" placeholder="1234567" class="flex-1 bg-navy-950 border border-gray-600 rounded p-2 text-white text-center text-lg font-mono tracking-widest">
                        <button onclick="connectToHost()" class="bg-neon text-navy-950 font-bold px-4 rounded hover:bg-lime-400 transition" data-i18n="connect">Connect</button>
                    </div>
					<p id="clientConnMsg" class="text-xs text-gray-500 mt-2"></p>
					<button id="disconnectBtn" onclick="disconnectClient()" class="hidden text-xs text-red-400 mt-2" data-i18n="disconnect">Disconnect</button>
                </div>
            </div>
        </div>
		<script>
		// Hide preview when dashboard is active
		function hidePreviewWhenDashboardActive() {
			const dashboard = document.getElementById('raceDashboard');
			const preview = document.getElementById('previewScreen');
			if (dashboard && preview) {
				const observer = new MutationObserver(() => {
					if (!dashboard.classList.contains('hidden')) {
						preview.classList.add('hidden');
					}
				});
				observer.observe(dashboard, { attributes: true, attributeFilter: ['class'] });
			}
		}
		window.addEventListener('DOMContentLoaded', hidePreviewWhenDashboardActive);
		</script>
    </div>
	<!-- Pre-Race Simulation Preview -->
	<div id="previewScreen" class="hidden flex-1 overflow-y-auto p-4">
		<div class="max-w-4xl mx-auto">
			<div class="simulation-preview">
				<div class="flex items-center justify-between mb-4">
					<h2 class="text-2xl font-bold text-ice">
						<i class="fas fa-chart-gantt mr-2"></i>
						<span data-i18n="racePreview">Race Strategy Preview</span>
					</h2>
					<button onclick="closePreview()" class="text-gray-400 hover:text-white">
						<i class="fas fa-times text-xl"></i>
					</button>
				</div>
				
				<!-- AI Strategy Assistant (Moved from Setup) -->
			<div class="bg-navy-900 p-4 rounded-lg border border-purple-500/30 shadow-lg mb-4">
				<h3 class="text-sm font-bold text-purple-400 mb-3 flex items-center gap-2">
					<span>ü§ñ</span>
					<span data-i18n="aiAssistant">AI Strategy Assistant</span>
				</h3>

				<!-- Weather Conditions -->
				<div class="mb-3">
					<label class="text-[10px] text-gray-400 mb-1 block data-i18n="expectedConditions">Expected Conditions:</label>
					<div class="grid grid-cols-3 gap-1">
						<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-yellow-400 has-[:checked]:bg-yellow-400/20">
							<input type="radio" name="weatherCondition" value="dry" checked class="hidden">
							<span class="text-[10px]">‚òÄÔ∏è Dry</span>
						</label>
						<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-blue-400 has-[:checked]:bg-blue-400/20">
							<input type="radio" name="weatherCondition" value="wet" class="hidden">
							<span class="text-[10px]">‚òÅÔ∏è Wet</span>
						</label>
						<label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-orange-400 has-[:checked]:bg-orange-400/20">
							<input type="radio" name="weatherCondition" value="mixed" class="hidden">
							<span class="text-[10px]"><span data-i18n="mixed">üå§Ô∏è Mixed</span></span>
						</label>
					</div>
				</div>
				
				<div class="mb-3">
					<label class="text-[10px] text-gray-400 mb-1 block data-i18n="strategyInstructions">Strategy Instructions:</label>
					<textarea id="strategyInstructions" 
							placeholder="e.g., 'Focus double stints during night shifts for Squad A', 'Keep driver X fresh for final stints', 'Minimize pit stops in first 3 hours'..."
							class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-xs h-20 resize-none"></textarea>
				</div>
				
				<button onclick="generateAIStrategy()" 
						class="w-full bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 rounded flex items-center justify-center gap-2 transition">
					<span data-i18n="generateAi">ü§ñ Generate AI Strategy</span>
				</button>
				
				<div id="aiStrategyStatus" class="text-[10px] text-center mt-2 hidden"></div>
			</div>
			
			<!-- Race Start Time Configuration -->
				<div class="bg-navy-900 rounded-lg p-4 mb-4">
					<label class="block text-sm text-gray-400 mb-2">
						<i class="fas fa-clock mr-2"></i>
						<span data-i18n="raceStartTime">Race Start Time</span>
					</label>
					<div class="flex justify-between text-xs text-gray-400 mt-6">
						<span>Start: <span id="timelineStart">--:--</span></span>
						<span>End: <span id="timelineEnd">--:--</span></span>
					</div>
					<input type="time" id="raceStartTime" 
						   class="w-full bg-navy-800 border border-gray-700 rounded px-3 py-2 text-white"
						   onchange="updatePreview()">
				</div>
	
				
				<!-- Driver Breakdown -->
				<div class="bg-navy-900 rounded-lg p-4 mb-4">
					<h3 class="text-lg font-bold text-neon mb-3">
						<i class="fas fa-users mr-2"></i>
						<span data-i18n="driverSchedule">Driver Schedule</span>
					</h3>
					<div id="driverScheduleList" class="space-y-3"></div>
				</div>
				
				<!-- Strategy Summary -->
				<div class="bg-navy-900 rounded-lg p-4 mb-4">
					<h3 class="text-lg font-bold text-neon mb-3">
						<i class="fas fa-list-check mr-2"></i>
						<span data-i18n="strategySummary">Strategy Summary</span>
					</h3>
					<div id="strategySummary" class="grid grid-cols-2 gap-3"></div>
				</div>
				
				<!-- Action Buttons -->
				<div class="flex flex-col sm:flex-row gap-3 mb-0">
					<button onclick="editStrategy()" 
							class="w-full sm:flex-1 bg-navy-800 hover:bg-navy-700 text-white font-bold py-3 rounded-lg border border-gray-700">
						<i class="fas fa-edit mr-2"></i>
						<span data-i18n="editStrategy">Edit Strategy</span>
					</button>
					<button onclick="saveStrategy()" 
							class="w-full sm:flex-1 bg-gold/20 hover:bg-gold/30 text-gold font-bold py-3 rounded-lg border border-gold/50">
						<i class="fas fa-save mr-2"></i>
						<span data-i18n="saveStrategy">Save Strategy</span>
					</button>
					<button onclick="initRace()" 
							class="w-full sm:flex-1 bg-gradient-to-r from-neon to-green-400 hover:from-green-400 hover:to-neon text-black font-bold py-3 rounded-lg shadow-lg">
						<i class="fas fa-flag-checkered mr-2"></i>
						<span data-i18n="startRace">Start Race</span>
					</button>
				</div>
			</div>
		</div>
	</div>

    <!-- Race Dashboard -->
    <div id="raceDashboard" class="hidden flex flex-col h-full overflow-hidden">
        <!-- Top Bar -->
        <div class="bg-navy-900 border-b border-gray-800 shrink-0">
			<!-- Race Info Section -->
			<div class="p-2 flex items-center justify-between gap-3">
				<!-- Race Time -->
				<div class="flex flex-col items-center">
					<p class="text-[10px] text-gray-500" data-i18n="raceTime">Race Time</p>
					<p id="raceTimerDisplay" class="text-xl font-mono font-bold text-white big-digit">00:00:00</p>
				</div>
				
				<!-- Pit Stops -->
				<div class="flex flex-col items-center">
					<p class="text-[10px] text-gray-500" data-i18n="pitStops">Pit Stops</p>
					<p id="pitCountDisplay" class="text-lg font-bold">
						<span class="text-neon">0</span>
						<span class="text-gray-500">/</span>
						<span>0</span>
					</p>
				</div>
				
				<!-- Weather Button -->
				<button id="btnRain" onclick="toggleRain()" class="btn-press bg-navy-800 border border-blue-500/50 rounded-lg px-3 py-2 hover:bg-navy-700">
					<span id="rainIcon" class="text-lg">‚òÄÔ∏è</span>
					<span id="rainText" class="text-xs font-bold text-yellow-400 block" data-i18n="dry">Dry</span>
				</button>
			</div>
		</div>

        <!-- Live Timing Panel (collapsible) -->
        <div id="liveTimingPanel" class="hidden bg-navy-900/80 border-b border-red-500/50 overflow-hidden transition-all duration-300 shrink-0" style="max-height: 350px;">
            <div class="p-2">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <span class="sync-dot live-dot"></span>
                        <span class="text-sm font-bold text-white">LIVE</span>
                    </div>
					<div class="flex items-center gap-1">
						<button onclick="openManualInput()" class="text-xs bg-fuel/30 border border-fuel/50 text-fuel px-2 py-1 rounded hover:bg-fuel/50" title="Manual Input">‚úèÔ∏è</button>
						<button onclick="refreshLiveTiming()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600" title="Refresh">üîÑ</button>
						<button onclick="toggleLiveTimingEmbed()" class="text-xs bg-red-900/50 px-2 py-1 rounded hover:bg-red-900" title="Embed">üñ•Ô∏è</button>
						<button onclick="stopLiveTiming()" 
								class="btn-press bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-xs">
							<i class="fas fa-stop"></i> 
							<span data-i18n="stopLiveTiming">Stop</span>
						</button>
					</div>
                </div>
                
                <!-- Quick Stats -->
                <div class="grid grid-cols-3 gap-2 mb-2">
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Pos</p>
                        <p id="livePosition" class="text-xl font-bold text-ice">-</p>
                        <p id="livePositionChange" class="text-[10px] position-same">‚Äî</p>
                    </div>
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Last</p>
                        <p id="liveLastLap" class="text-lg font-mono text-white">--</p>
                    </div>
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Best</p>
                        <p id="liveBestLap" class="text-lg font-mono text-neon">--</p>
                    </div>
                </div>
                
                <!-- Competitors Table -->
                <div id="competitorsTable" class="bg-navy-950 rounded border border-gray-700 p-1 max-h-[180px] overflow-y-auto text-[11px]">
                    <div class="text-gray-500 text-center py-2" data-i18n="waitingData">Waiting for data...</div>
                </div>
				
				<!-- Proxy Debug Info -->
				<div id="proxyDebug" class="hidden mt-2 p-2 bg-navy-950 rounded border border-gray-700 text-[10px] text-gray-500 max-h-20 overflow-y-auto">
					<p class="font-bold text-gray-400" data-i18n="proxyData">Proxy Data:</p>
					<pre id="proxyDataPreview" class="whitespace-pre-wrap break-all"></pre>
				</div>
            </div>
        </div>
		
		<!-- Live Timing Embed (iframe) -->
		<div id="liveTimingEmbed" class="hidden bg-navy-900 border-b border-gray-700">
			<div class="flex items-center justify-between p-1 bg-navy-800">
				<span class="text-[10px] text-gray-400" data-i18n="liveView">Live View</span>
				<button onclick="closeLiveTimingEmbed()" class="text-red-400 text-xs">‚úï</button>
			</div>
			<iframe id="liveTimingIframe" class="w-full h-64 border-0" src="about:blank"></iframe>
		</div>

        <!-- Strategy Box -->
        <div id="strategyBox" class="p-3 text-center border-b-2 border-neon flex flex-col items-center justify-center rounded-lg shadow-lg shrink-0 bg-navy-900">
            <p class="text-gray-400 text-xs mb-1" data-i18n="targetStint">Target Stint</p>
            <div class="flex items-baseline gap-2">
                <span id="strategyTargetStint" class="text-2xl font-bold text-white big-digit">--:--</span>
                <span id="strategyDelta" class="text-lg font-bold text-gray-400">--</span>
            </div>
            <p id="strategyAdvice" class="text-xs text-gray-400 mt-1" data-i18n="buildTime">Build Time</p>
        </div>

        <!-- Stint Timer -->
        <div class="p-3 bg-navy-950 border-b border-gray-800 shrink-0">
			<div class="grid grid-cols-2 gap-3 mb-2">
				<div class="flex flex-col items-center">
					<p class="text-gray-500 text-xs mb-1" data-i18n="stintTime">Stint Time</p>
					<p id="stintTimerDisplay" class="text-3xl font-mono font-bold text-white big-digit">00:00</p>
				</div>
				<div class="flex flex-col items-center">
					<p class="text-gray-500 text-xs mb-1" data-i18n="currentDriver">Current Driver</p>
					<p id="currentDriverName" class="text-xl font-bold text-ice">---</p>
				</div>
			</div>
			<div class="relative h-4 bg-navy-800 rounded-full overflow-hidden">
                <div id="zoneForbidden" class="absolute top-0 left-0 h-full zone-forbidden"></div>
                <div id="stintProgressBar" class="absolute top-0 left-0 h-full zone-optimal transition-all duration-500" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Pit Indicator for Viewer Mode -->
        <div id="viewerPitIndicator" class="hidden bg-fuel/20 border-b border-fuel/50 p-2 text-center shrink-0">
            <div class="flex items-center justify-center gap-2">
                <span class="text-fuel text-sm font-bold">üèÅ IN PIT</span>
                <span id="viewerPitTimer" class="text-fuel font-mono font-bold text-lg">--</span>
            </div>
            <p class="text-[10px] text-gray-400 mt-1">
                <span data-i18n="nextDriverIn">Next Driver:</span> 
                <span id="viewerNextDriver" class="text-white font-bold">---</span>
            </p>
        </div>
        
        <!-- Squad & Night Display -->
        <div id="activeSquadDisplay" class="hidden bg-navy-800 border-b border-gray-600 p-2 text-center shrink-0">
			<span class="text-xs text-gray-400" data-i18n="activeSquad">Active Squad:</span>
			<span id="activeSquadText" class="text-lg font-bold text-squadA ml-2">A</span>
		</div>
        
        <div id="sleepWidget" class="hidden bg-navy-800 border-b border-gray-700 p-2 text-center shrink-0">
            <p class="text-[10px] text-gray-500" data-i18n="resting">Resting:</p>
            <p id="sleepersList" class="text-xs text-gray-400">---</p>
        </div>

        <!-- Control Buttons -->
        <div class="control-grid" id="controlButtonsGrid">
			<button id="btnPush" onclick="setMode('push')" data-viewer-disabled="true" class="btn-press bg-navy-800 border border-green-900/50 rounded-lg p-2 group hover:bg-navy-700">
				<span class="block text-lg">üî• <span data-i18n="push">Push</span></span>
			</button>
            <button id="btnBad" onclick="setMode('bad')" data-viewer-disabled="true" class="btn-press bg-navy-800 border border-red-900/50 rounded-lg p-2 group hover:bg-navy-700">
				<span class="block text-lg">üê¢ <span data-i18n="problem">Problem</span></span>
			</button>
			<button id="btnNight" onclick="toggleNightMode()" data-viewer-disabled="true" class="hidden btn-press bg-navy-800 border border-purple-500/50 rounded-lg p-2 group hover:bg-navy-700 text-purple-300">
                <span class="block text-lg">üåô <span data-i18n="night">Night</span></span>
            </button>
			<button id="btnResetMode" onclick="setMode('normal')" data-viewer-disabled="true" class="hidden btn-press bg-navy-800 border border-gray-600 rounded-lg p-2 col-span-3">
                <span class="text-sm text-gray-400" data-i18n="resetMode">‚Ü©Ô∏è Reset Mode</span>
            </button>
        </div>

        <!-- Driver Stats -->
        <div class="flex-1 overflow-y-auto bg-navy-950 p-2">
            <table class="w-full text-sm">
                <thead class="text-gray-500 text-xs sticky top-0 bg-navy-950">
                    <tr>
                        <th class="p-1 w-8"></th>
                        <th class="text-right p-1" data-i18n="driverHeader">Driver</th>
                        <th class="text-center p-1" data-i18n="stintsHeader">St.</th>
                        <th class="text-left p-1" data-i18n="totalHeader">Total</th>
                    </tr>
                </thead>
                <tbody id="statsTable"></tbody>
            </table>
        </div>

        <!-- Pit Button & Next Driver -->
        <div class="bg-navy-900 border-t border-gray-800 p-2 shrink-0 space-y-2">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-2">
					<div>
						<p class="text-[10px] text-gray-500" data-i18n="nextDriver">Next Driver</p>
						<p id="nextDriverName" class="text-lg font-bold text-neon cursor-pointer hover:text-white" onclick="cycleNextDriver()" data-viewer-disabled="true">---</p>
					</div>
					<button onclick="cycleNextDriver()" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600" title="Change next driver">üîÑ</button>
                </div>
                <div class="flex gap-2">
                    <button onclick="adjustStint(-60000)" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded">-1m</button>
					<button onclick="adjustStint(60000)" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded">+1m</button>
                </div>
            </div>
            <button id="pitEntryBtn" onclick="confirmPitEntry()" data-viewer-disabled="true" class="w-full bg-danger hover:bg-red-600 text-white font-bold py-4 rounded-lg text-xl shadow-[0_0_15px_rgba(239,68,68,0.3)] transition btn-press" data-i18n="enterPit">
                üèÅ Enter Pit
            </button>
        </div>
    </div>

    <!-- Pit Modal -->
    <div id="pitModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <h2 class="text-ice text-2xl font-bold mb-2 tracking-widest border-b border-ice pb-1" data-i18n="inPit">IN PIT</h2>
		<p class="text-gray-400 text-sm mb-4"><span data-i18n="nextDriverIn">Next Driver:</span> <span id="modalNextDriverName" class="text-white font-bold">---</span></p>

        <div id="pitPhase2" class="w-full max-w-sm flex flex-col items-center">
            <div id="fuelToggleContainer" class="hidden mb-4 bg-navy-800 p-3 rounded border border-fuel/50 w-full">
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm font-bold text-gray-300" data-i18n="refuel">Kart Change / Refuel?</span>
                    <input type="checkbox" id="isRefuelCheck" checked class="w-6 h-6 accent-fuel">
                </label>
            </div>
            
            <div class="relative w-48 h-48 flex items-center justify-center border-4 border-gray-700 rounded-full mb-4 bg-navy-900">
                <span id="pitTimerDisplay" class="text-5xl font-bold big-digit text-white font-mono">00</span>
            </div>
            
            <button id="notifyBtn" class="hidden w-full bg-fuel text-black font-bold py-3 rounded-lg text-lg mb-2">
                üì¢ <span data-i18n="notifyDriver">Notify Driver</span>
            </button>
            <div id="notifiedMsg" class="hidden text-fuel text-sm mb-2 font-bold">‚úì <span data-i18n="notified">Notified - Waiting for line cross</span></div>
            
            <button id="confirmExitBtn" disabled class="w-full bg-gray-800 text-gray-600 font-bold py-4 rounded-lg text-xl border border-gray-700 mb-4" data-i18n="wait">
                Wait...
            </button>
            
            <button onclick="cancelPitStop()" class="text-red-400 py-2 text-sm">‚ùå <span data-i18n="cancelPit">Cancel Pit Entry</span></button>
        </div>
    </div>

	<!-- Saved Race Modal -->
	<div id="savedRaceModal" class="hidden fixed inset-0 bg-navy-950/98 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-md">
		<div class="bg-gradient-to-br from-navy-900 to-navy-950 p-6 rounded-2xl border-2 border-ice shadow-[0_0_40px_rgba(34,211,238,0.3)] w-full max-w-md">
			<div class="text-center mb-6">
				<div class="w-16 h-16 bg-ice/20 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
					<i class="fas fa-flag-checkered text-3xl text-ice"></i>
				</div>
				<h2 class="text-2xl font-bold text-ice mb-2" data-i18n="activeRaceFound">Active Race Found!</h2>
				<p class="text-gray-400 text-sm" data-i18n="raceInProgress">A race is currently in progress</p>
			</div>
			
			<div class="bg-navy-950 rounded-lg p-4 mb-6 border border-gray-700">
				<div class="space-y-3">
					<div class="flex items-center justify-between">
						<span class="text-gray-400 text-sm flex items-center gap-2">
							<i class="fas fa-user text-ice"></i>
							<span data-i18n="currentDriver">Current Driver</span>
						</span>
						<span id="savedRaceDriver" class="text-white font-bold text-lg">---</span>
					</div>
					<div class="flex items-center justify-between">
						<span class="text-gray-400 text-sm flex items-center gap-2">
							<i class="fas fa-clock text-neon"></i>
							<span data-i18n="timeRemaining">Time Remaining</span>
						</span>
						<span id="savedRaceTime" class="text-neon font-bold text-lg font-mono">--:--:--</span>
					</div>
					<div class="flex items-center justify-between">
						<span class="text-gray-400 text-sm flex items-center gap-2">
							<i class="fas fa-stop text-fuel"></i>
							<span data-i18n="pitStops">Pit Stops</span>
						</span>
						<span id="savedRacePits" class="text-white font-bold">
							<span class="text-neon">0</span> / <span>0</span>
						</span>
					</div>
				</div>
			</div>
			
			<div class="space-y-3">
				<button onclick="continueRace()" 
						class="w-full bg-gradient-to-r from-ice to-cyan-400 hover:from-cyan-400 hover:to-ice text-navy-950 font-bold py-4 rounded-lg text-lg shadow-lg transition-all transform hover:scale-105">
					<i class="fas fa-play mr-2"></i>
					<span data-i18n="continueRace">Continue Race</span>
				</button>
				<button onclick="confirmDiscardRace()" 
						class="w-full bg-navy-800 hover:bg-navy-700 text-gray-300 font-bold py-3 rounded-lg border border-gray-600 transition-all">
					<i class="fas fa-times mr-2"></i>
					<span data-i18n="discardRace">Discard & Start New</span>
				</button>
			</div>
			
			<p class="text-xs text-gray-500 text-center mt-4">
				<i class="fas fa-exclamation-triangle text-yellow-500 mr-1"></i>
				<span data-i18n="raceWarning">Discarding will permanently delete this race data</span>
			</p>
		</div>
	</div>

	<!-- Confirm Discard Modal -->
	<div id="confirmDiscardModal" class="hidden fixed inset-0 bg-navy-950/98 z-[60] flex flex-col items-center justify-center p-4 backdrop-blur-md">
		<div class="bg-navy-900 p-6 rounded-xl border-2 border-red-500 shadow-[0_0_40px_rgba(239,68,68,0.3)] w-full max-w-sm">
			<div class="text-center mb-6">
				<div class="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
					<i class="fas fa-exclamation-triangle text-3xl text-red-500"></i>
				</div>
				<h3 class="text-xl font-bold text-white mb-2" data-i18n="confirmDiscard">Are You Sure?</h3>
				<p class="text-gray-400 text-sm" data-i18n="confirmDiscardMessage">This will permanently delete the active race. This action cannot be undone.</p>
			</div>
			<div class="space-y-3">
				<button onclick="finalDiscardRace()" 
						class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition-all">
					<i class="fas fa-trash mr-2"></i>
					<span data-i18n="yesDiscard">Yes, Discard Race</span>
				</button>
				<button onclick="cancelDiscard()" 
						class="w-full bg-navy-800 hover:bg-navy-700 text-gray-300 font-bold py-3 rounded-lg border border-gray-600 transition-all">
					<i class="fas fa-arrow-left mr-2"></i>
					<span data-i18n="noKeepRace">No, Keep Race</span>
				</button>
			</div>
		</div>
	</div>
	
	<!-- Manual Input Modal -->
	<div id="manualInputModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
		<div class="bg-navy-900 p-4 rounded-lg border border-gray-700 w-full max-w-sm">
			<h3 class="text-ice text-lg font-bold mb-4 text-center" data-i18n="manualInput">Manual Input</h3>
			
			<div class="space-y-3">
				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="position">Position</label>
						<input type="number" id="manualPosition" placeholder="1" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="laps">Laps</label>
						<input type="number" id="manualLaps" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
				</div>
				
				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="lastLap">Last Lap</label>
						<input type="text" id="manualLastLap" placeholder="1:02.345" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="bestLap">Best Lap</label>
						<input type="text" id="manualBestLap" placeholder="1:01.234" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
					</div>
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="gap">Gap to Leader</label>
					<input type="text" id="manualGap" placeholder="+1:23.456 or +2 laps" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
				</div>
				
				<div class="flex items-center gap-2 bg-navy-800 p-2 rounded">
					<input type="checkbox" id="manualInPit" class="w-4 h-4 accent-fuel">
					<label class="text-sm text-gray-300" data-i18n="inPitNow">Currently in Pit</label>
				</div>
			</div>
			
			<div class="flex gap-2 mt-4">
				<button onclick="applyManualInput()" class="flex-1 bg-ice text-navy-950 font-bold py-2 rounded-lg" data-i18n="apply">Apply</button>
				<button onclick="closeManualInput()" class="flex-1 bg-navy-700 text-gray-300 py-2 rounded-lg" data-i18n="cancel">Cancel</button>
			</div>
		</div>
	</div>
	<!-- Strategy Library Modal -->
	<div id="strategyModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
		<div class="bg-navy-900 rounded-lg border border-gray-700 w-full max-w-lg max-h-[80vh] flex flex-col">
			<div class="flex items-center justify-between p-4 border-b border-gray-700">
				<h3 class="text-ice text-lg font-bold">üìö Saved Strategies</h3>
				<button onclick="closeStrategyModal()" class="text-gray-400 hover:text-white text-xl">&times;</button>
			</div>
			<div id="strategyList" class="flex-1 overflow-y-auto p-4 space-y-2">
				<p class="text-gray-500 text-center">Loading...</p>
			</div>
		</div>
	</div>

    <script>
        // ==================== GLOBALS ====================
        let peer = null, conn = null, connections = [], myId = null, role = null;
        let config = {}; 
        let state = { 
            isRunning: false, 
            mode: 'normal', 
			trackCondition: 'dry',
            isRain: false, 
            currentDriverIdx: 0, 
            pitCount: 0, 
            startTime: 0, 
            stintStart: 0, 
            pitStart: 0, 
            isInPit: false, 
            fuelStart: 0, 
            stintOffset: 0, 
            activeSquad: 'A', 
            nextDriverIdx: 0, 
            targetStintMs: 0, 
            squadsActive: false,
            pendingPitEntry: false
        };
        let drivers = []; 
		let savedHostConfig = null;
		let savedConfigPanelState = null;
        let raceInterval, pitInterval, liveTimingInterval;
        let connectionRetries = 0;
        const MAX_RETRIES = 3;
		const RACE_STATE_KEY = 'strateger_race_state';
		let liveTimingManager = null;
		let proxyFetchInterval = null;
		let syncedTimes = null;
        
        // Live Timing State
        let liveTimingConfig = {
            url: '',
            teamName: '',
            enabled: false,
            demoMode: false
        };
		
		// Search configuration
		let searchConfig = {
			teamName: '',
			driverName: '',
			kartNumber: ''
		};
        
        let liveData = {
            position: null,
            previousPosition: null,
            lastLap: null,
            bestLap: null,
            laps: null,
            gapToLeader: null,
            competitors: []
        };
        
        // Demo mode state
        let demoState = {
            competitors: [],
            updateInterval: null
        };

		let aiStrategyConfig = {
			weatherCondition: 'dry',
			instructions: '',
			starterDriverIdx: 0,
			useAI: false
		};

		// Strategy preferences based on conditions
		const strategyPreferences = {
			dry: {
				stintPenalty: 0,
				description: 'Standard strategy - maximize stint length'
			},
			wet: {
				stintPenalty: 120000, // 2 minutes shorter stints in wet
				description: 'Wet conditions - shorter, safer stints'
			},
			mixed: {
				stintPenalty: 60000, // 1 minute shorter in mixed
				description: 'Mixed conditions - flexible strategy'
			}
		};
		
		// ==================== I18N ====================
		let currentLang = 'en';
		
		const translations = {
			en: {
				offline: 'Offline',
				subtitle: 'Endurance Race Strategy Manager',
				host: 'Host',
				hostDesc: 'Manage the race',
				viewer: 'Viewer',
				viewerDesc: 'Watch live',
				yourCode: 'Your Code:',
				retry: 'Retry',
				raceSettings: '‚öôÔ∏è Race Settings',
				liveTiming: 'Live Timing (Optional)',
				liveTimingUrl: 'Live Timing URL (APEX/RaceFacer)',
				searchBy: 'Search by:',
				team: 'Team',
				kart: 'Kart',
				driver: 'Driver',
				testConnection: 'Test',
				demo: 'Demo',
				manual: 'Manual',
				duration: 'Duration (hours)',
				reqStops: 'Required Stops',
				minStint: 'Min Stint (min)',
				maxStint: 'Max Stint (min)',
				driverLimits: 'Driver Limits (0 = no limit)',
				minDrive: 'Min Drive',
				maxDrive: 'Max Drive',
				pitTime: 'Pit Time (sec)',
				releaseBuffer: 'Release Buffer (sec)',
				doubleStint: 'Double',
				fuel: 'Fuel',
				squads: 'Squads',
				fuelTankTime: 'Fuel Tank Time (min)',
				driversSetup: 'Drivers (mark starter)',
				startRace: 'Start Race (Host)',
				enterCode: 'Enter Host Code:',
				connect: 'Connect',
				disconnect: 'Disconnect',
				code: 'Code:',
				synced: 'Synced',
				raceTime: 'Race Time',
				pitStops: 'Pit Stops',
				dry: 'Dry',
				wet: 'Wet',
				drying: 'Drying',
				targetStint: 'Target Stint',
				buildTime: 'Build Time',
				stintTime: 'Stint Time',
				currentDriver: 'Current Driver',
				activeSquad: 'Active Squad:',
				resting: 'Resting:',
				push: 'Push',
				problem: 'Problem',
				night: 'Night',
				resetMode: '‚Ü©Ô∏è Reset Mode',
				driverHeader: 'Driver',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Next Driver',
				enterPit: 'üèÅ Enter Pit',
				inPit: 'IN PIT',
				nextDriverIn: 'Next Driver:',
				refuel: 'Kart Change / Refuel?',
				notifyDriver: 'Notify Driver',
				notified: 'Notified - Waiting for line cross',
				wait: 'Wait...',
				cancelPit: 'Cancel Pit Entry',
				manualInput: 'Manual Input',
				position: 'Position',
				laps: 'Laps',
				lastLap: 'Last Lap',
				bestLap: 'Best Lap',
				gap: 'Gap to Leader',
				inPitNow: 'Currently in Pit',
				apply: 'Apply',
				cancel: 'Cancel',
				waitingData: 'Waiting for data...',
				proxyData: 'Proxy Data:',
				liveView: 'Live View',
				connecting: 'Connecting...',
				connected: 'Connected',
				waitingRace: 'Connected! Waiting for race...',
				disconnected: 'Disconnected',
				enterUrl: '‚ùå Enter URL',
				enterValue: '‚ùå Enter',
				testing: 'üîÑ Testing...',
				found: '‚úÖ Found! Position:',
				notFound: '‚ö†Ô∏è Not found - check details or use iframe',
				error: '‚ùå Error:',
				confirmEarlyPit: 'Window closed! Enter anyway?',
				confirmExit: '‚úÖ Confirm Line Cross',
				timeExceeded: 'üö® Time Exceeded!',
				problemQuick: 'üê¢ Problem - Quick Entry!',
				pushExtend: 'üî• Extending! Build time',
				nearLimit: '‚ö†Ô∏è Near limit!',
				targetWindow: '‚úÖ Target Window',
				overExtend: 'üì• Over Extended',
				nightActive: 'üåô Night Active',
				pushActive: 'üî• Push Active',
				problemActive: 'üê¢ Problem Active',
				connecting: 'Connecting...',
				connected: 'Connected',
				teamNotFound: 'Team not found',
				connectionIssues: 'Connection issues',
				usingIframe: 'Using iframe',
				connectionFailed: 'Connection failed',
				stopped: 'Stopped',
				racePreview: 'Race Strategy Preview',
				raceStartTime: 'Race Start Time',
				driverSchedule: 'Driver Schedule',
				strategySummary: 'Strategy Summary',
				editStrategy: 'Back to Setup',
				saveStrategy: 'Save Strategy',
				previewStrategy: 'Preview Strategy',
				stopLiveTiming: 'Stop',
				activeRaceFound: 'Active Race Found!',
				raceInProgress: 'A race is currently in progress',
				timeRemaining: 'Time Remaining',
				continueRace: 'Continue Race',
				discardRace: 'Discard & Start New',
				raceWarning: 'Discarding will permanently delete this race data',
				confirmDiscard: 'Are You Sure?',
				confirmDiscardMessage: 'This will permanently delete the active race. This action cannot be undone.',
				yesDiscard: 'Yes, Discard Race',
				noKeepRace: 'No, Keep Race',
				loadStrategy: 'Load Saved Strategy',
				savedStrategies: 'üìö Saved Strategies',
				noSavedStrategies: 'No saved strategies yet',
				strategyName: 'Strategy Name:',
				strategySaved: '‚úÖ Strategy saved:',
				aiAssistant: 'ü§ñ AI Strategy Assistant',
				expectedConditions: 'Expected Conditions:',
				mixed: 'Mixed',
				strategyInstructions: 'Strategy Instructions:',
				aiPlaceholder: "e.g., 'Focus double stints during night for Squad A', 'Keep driver X fresh for final stints'...",
				generateAi: 'ü§ñ Generate AI Strategy',
				analyzing: 'ü§ñ Analyzing strategy...',
				aiApplied: '‚úÖ AI strategy applied!',
				aiError: '‚ùå Error generating strategy',
				pitClosedStart: 'üö´ Pit Closed Start (min)',
				pitClosedEnd: 'üö´ Pit Closed End (min)',
				finish: 'Finish',
				raceFinished: 'üèÅ Race Finished!',
				savedToDb: '‚úÖ Strategy saved to database',
				safetyWarning: '‚ö†Ô∏è Safety Warning',
			},
			he: {
				offline: '◊ú◊ê ◊û◊ó◊ï◊ë◊®',
				subtitle: '◊û◊†◊î◊ú ◊ê◊°◊ò◊®◊ò◊í◊ô◊ô◊™ ◊û◊ô◊®◊ï◊¶◊ô ◊°◊ô◊ë◊ï◊ú◊™',
				host: '◊û◊ê◊®◊ó',
				hostDesc: '◊†◊î◊ú ◊ê◊™ ◊î◊û◊ô◊®◊ï◊•',
				viewer: '◊¶◊ï◊§◊î',
				viewerDesc: '◊¶◊§◊î ◊ë◊©◊ô◊ì◊ï◊® ◊ó◊ô',
				yourCode: '◊î◊ß◊ï◊ì ◊©◊ú◊ö:',
				retry: '◊†◊°◊î ◊©◊ï◊ë',
				raceSettings: '‚öôÔ∏è ◊î◊í◊ì◊®◊ï◊™ ◊û◊ô◊®◊ï◊•',
				liveTiming: 'Live Timing (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô)',
				liveTimingUrl: '◊ß◊ô◊©◊ï◊® Live Timing (APEX/RaceFacer)',
				searchBy: '◊ó◊§◊© ◊ú◊§◊ô:',
				team: '◊ß◊ë◊ï◊¶◊î',
				kart: '◊ß◊ê◊®◊ò',
				driver: '◊†◊î◊í',
				testConnection: '◊ë◊ì◊ï◊ß',
				demo: '◊ì◊û◊ï',
				manual: '◊ô◊ì◊†◊ô',
				duration: '◊û◊©◊ö (◊©◊¢◊ï◊™)',
				reqStops: '◊¢◊¶◊ô◊®◊ï◊™ ◊ó◊ï◊ë◊î',
				minStint: '◊û◊ô◊†\' ◊°◊ò◊ô◊†◊ò (◊ì◊ß\')',
				maxStint: '◊û◊ß◊°\' ◊°◊ò◊ô◊†◊ò (◊ì◊ß\')',
				driverLimits: '◊í◊ë◊ï◊ú◊ï◊™ ◊†◊î◊í (0 = ◊ú◊ú◊ê ◊î◊í◊ë◊ú◊î)',
				minDrive: '◊û◊ô◊†◊ô◊û◊ï◊ù ◊†◊î◊ô◊í◊î',
				maxDrive: '◊û◊ß◊°◊ô◊û◊ï◊ù ◊†◊î◊ô◊í◊î',
				pitTime: '◊ñ◊û◊ü ◊§◊ô◊ò◊° (◊©◊†◊ô◊ï◊™)',
				releaseBuffer: '◊î◊ß◊ì◊û◊™ ◊î◊™◊®◊ê◊î (◊©◊†\')',
				doubleStint: '◊ì◊ê◊ë◊ú',
				fuel: '◊ì◊ú◊ß',
				squads: '◊ó◊ï◊ú◊ô◊ï◊™',
				fuelTankTime: '◊ñ◊û◊ü ◊û◊ô◊õ◊ú ◊ì◊ú◊ß (◊ì◊ß\')',
				driversSetup: '◊î◊í◊ì◊®◊™ ◊†◊î◊í◊ô◊ù (◊°◊û◊ü ◊û◊ñ◊†◊ß)',
				startRace: '◊î◊™◊ó◊ú ◊û◊®◊ï◊• (◊û◊†◊î◊ú)',
				enterCode: '◊î◊õ◊†◊° ◊ß◊ï◊ì ◊û◊ê◊®◊ó:',
				connect: '◊î◊™◊ó◊ë◊®',
				disconnect: '◊î◊™◊†◊™◊ß',
				code: '◊ß◊ï◊ì:',
				synced: '◊û◊°◊ï◊†◊õ◊®◊ü',
				raceTime: '◊ñ◊û◊ü ◊û◊ô◊®◊ï◊•',
				pitStops: '◊¢◊¶◊ô◊®◊ï◊™ ◊§◊ô◊ò◊°',
				dry: '◊ô◊ë◊©',
				wet: '◊í◊©◊ù',
				drying: '◊û◊™◊ô◊ô◊ë◊©',
				targetStint: '◊ô◊¢◊ì ◊°◊ò◊ô◊†◊ò ◊†◊ï◊õ◊ó◊ô',
				buildTime: '◊¶◊ë◊ï◊® ◊ñ◊û◊ü',
				stintTime: '◊ñ◊û◊ü ◊°◊ò◊ô◊†◊ò',
				currentDriver: '◊†◊î◊í ◊†◊ï◊õ◊ó◊ô',
				activeSquad: '◊ó◊ï◊ú◊ô◊î ◊§◊¢◊ô◊ú◊î:',
				resting: '◊†◊ó◊ô◊ù:',
				push: '◊ß◊¶◊ë',
				problem: '◊™◊ß◊ú◊î',
				night: '◊ú◊ô◊ú◊î',
				resetMode: '‚Ü©Ô∏è ◊ê◊ô◊§◊ï◊° ◊û◊¶◊ë',
				driverHeader: '◊†◊î◊í',
				stintsHeader: '◊°◊ò\'',
				totalHeader: '◊°◊î"◊õ',
				nextDriver: '◊†◊î◊í ◊î◊ë◊ê',
				enterPit: 'üèÅ ◊õ◊†◊ô◊°◊î ◊ú◊§◊ô◊ò◊°',
				inPit: '◊ë◊§◊ô◊ò◊°',
				nextDriverIn: '◊†◊î◊í ◊†◊õ◊†◊°:',
				refuel: '◊î◊ï◊ó◊ú◊£ ◊ß◊ê◊®◊ò / ◊™◊ì◊ú◊ï◊ß?',
				notifyDriver: '◊î◊ï◊ì◊¢ ◊ú◊†◊î◊í ◊ú◊î◊™◊õ◊ï◊†◊ü',
				notified: '◊î◊ï◊ì◊¢◊î ◊†◊©◊ú◊ó◊î - ◊û◊û◊™◊ô◊ü ◊ú◊ó◊¶◊ô◊ô◊™ ◊ß◊ï',
				wait: '◊î◊û◊™◊ü...',
				cancelPit: '◊ë◊ò◊ú ◊õ◊†◊ô◊°◊î ◊ú◊§◊ô◊ò◊°',
				manualInput: '◊î◊ñ◊†◊î ◊ô◊ì◊†◊ô◊™',
				position: '◊û◊ô◊ß◊ï◊ù',
				laps: '◊î◊ß◊§◊ï◊™',
				lastLap: '◊î◊ß◊§◊î ◊ê◊ó◊®◊ï◊†◊î',
				bestLap: '◊î◊ß◊§◊î ◊î◊ò◊ï◊ë◊î',
				gap: '◊§◊¢◊® ◊û◊û◊ï◊ë◊ô◊ú',
				inPitNow: '◊õ◊®◊í◊¢ ◊ë◊§◊ô◊ò◊°',
				apply: '◊î◊ó◊ú',
				cancel: '◊ë◊ô◊ò◊ï◊ú',
				waitingData: '◊û◊û◊™◊ô◊ü ◊ú◊†◊™◊ï◊†◊ô◊ù...',
				proxyData: '◊†◊™◊ï◊†◊ô ◊§◊®◊ï◊ß◊°◊ô:',
				liveView: '◊™◊¶◊ï◊í◊î ◊ó◊ô◊î',
				connecting: '◊û◊™◊ó◊ë◊®...',
				connected: '◊û◊ó◊ï◊ë◊®',
				waitingRace: '◊û◊ó◊ï◊ë◊®! ◊û◊û◊™◊ô◊ü ◊ú◊™◊ó◊ô◊ú◊™ ◊û◊®◊ï◊•...',
				disconnected: '◊†◊ï◊™◊ß ◊û◊î◊û◊ê◊®◊ó',
				enterUrl: '‚ùå ◊î◊õ◊†◊° ◊ß◊ô◊©◊ï◊®',
				enterValue: '‚ùå ◊î◊õ◊†◊°',
				testing: 'üîÑ ◊ë◊ï◊ì◊ß...',
				found: '‚úÖ ◊†◊û◊¶◊ê! ◊û◊ô◊ß◊ï◊ù:',
				notFound: '‚ö†Ô∏è ◊ú◊ê ◊†◊û◊¶◊ê - ◊ë◊ì◊ï◊ß ◊ê◊™ ◊î◊§◊®◊ò◊ô◊ù ◊ê◊ï ◊î◊©◊™◊û◊© ◊ë-iframe',
				error: '‚ùå ◊©◊í◊ô◊ê◊î:',
				confirmEarlyPit: '◊ó◊ú◊ï◊ü ◊°◊í◊ï◊®! ◊ú◊î◊ô◊õ◊†◊°?',
				confirmExit: '‚úÖ ◊ê◊©◊® ◊ó◊¶◊ô◊ô◊™ ◊ß◊ï',
				timeExceeded: 'üö® ◊ó◊®◊ô◊í◊™ ◊ñ◊û◊ü!',
				problemQuick: 'üê¢ ◊™◊ß◊ú◊î - ◊õ◊†◊ô◊°◊î ◊û◊î◊ô◊®◊î!',
				pushExtend: 'üî• ◊û◊ê◊®◊ô◊õ◊ô◊ù! ◊¶◊ë◊ï◊® ◊ñ◊û◊ü',
				nearLimit: '‚ö†Ô∏è ◊ß◊®◊ï◊ë ◊ú◊í◊ë◊ï◊ú!',
				targetWindow: '‚úÖ ◊ó◊ú◊ï◊ü ◊ô◊¢◊ì',
				overExtend: 'üì• ◊î◊ê◊®◊õ◊™ ◊ô◊™◊®',
				nightActive: 'üåô ◊ú◊ô◊ú◊î ◊§◊¢◊ô◊ú',
				pushActive: 'üî• ◊ß◊¶◊ë ◊§◊¢◊ô◊ú',
				problemActive: 'üê¢ ◊™◊ß◊ú◊î ◊§◊¢◊ô◊ú',
				connecting: '◊û◊™◊ó◊ë◊®...',
				connected: '◊û◊ó◊ï◊ë◊®',
				teamNotFound: '◊ß◊ë◊ï◊¶◊î ◊ú◊ê ◊†◊û◊¶◊ê◊î',
				connectionIssues: '◊ë◊¢◊ô◊ï◊™ ◊ó◊ô◊ë◊ï◊®',
				usingIframe: '◊û◊©◊™◊û◊© ◊ë-iframe',
				connectionFailed: '◊î◊ó◊ô◊ë◊ï◊® ◊†◊õ◊©◊ú',
				stopped: '◊†◊¢◊¶◊®',
				racePreview: '◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î ◊©◊ú ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				raceStartTime: '◊©◊¢◊™ ◊î◊™◊ó◊ú◊™ ◊î◊û◊ô◊®◊ï◊•',
				driverSchedule: '◊ú◊ï◊ó ◊ñ◊û◊†◊ô◊ù ◊†◊î◊í◊ô◊ù',
				strategySummary: '◊°◊ô◊õ◊ï◊ù ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				editStrategy: '◊ó◊ñ◊®◊î ◊ú◊û◊°◊ö ◊®◊ê◊©◊ô',
				saveStrategy: '◊©◊û◊ï◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				previewStrategy: '◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î',
				stopLiveTiming: '◊¢◊¶◊ï◊®',
				activeRaceFound: '◊†◊û◊¶◊ê ◊û◊ô◊®◊ï◊• ◊§◊¢◊ô◊ú!',
				raceInProgress: '◊û◊ô◊®◊ï◊• ◊û◊™◊ß◊ô◊ô◊ù ◊õ◊¢◊™',
				timeRemaining: '◊ñ◊û◊ü ◊†◊ï◊™◊®',
				continueRace: '◊î◊û◊©◊ö ◊û◊ô◊®◊ï◊•',
				discardRace: '◊û◊ó◊ß ◊ï◊î◊™◊ó◊ú ◊ó◊ì◊©',
				raceWarning: '◊û◊ó◊ô◊ß◊î ◊™◊û◊ó◊ß ◊ú◊¶◊û◊ô◊™◊ï◊™ ◊ê◊™ ◊†◊™◊ï◊†◊ô ◊î◊û◊ô◊®◊ï◊•',
				confirmDiscard: '◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó?',
				confirmDiscardMessage: '◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊™◊û◊ó◊ß ◊ú◊¶◊û◊ô◊™◊ï◊™ ◊ê◊™ ◊î◊û◊ô◊®◊ï◊• ◊î◊§◊¢◊ô◊ú. ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ë◊ò◊ú ◊§◊¢◊ï◊ú◊î ◊ñ◊ï.',
				yesDiscard: '◊õ◊ü, ◊û◊ó◊ß ◊û◊ô◊®◊ï◊•',
				noKeepRace: '◊ú◊ê, ◊©◊û◊ï◊® ◊û◊ô◊®◊ï◊•',
				loadStrategy: '◊ò◊¢◊ü ◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊©◊û◊ï◊®◊î',
				savedStrategies: 'üìö ◊ê◊°◊ò◊®◊ò◊í◊ô◊ï◊™ ◊©◊û◊ï◊®◊ï◊™',
				noSavedStrategies: '◊ê◊ô◊ü ◊ê◊°◊ò◊®◊ò◊í◊ô◊ï◊™ ◊©◊û◊ï◊®◊ï◊™ ◊¢◊ì◊ô◊ô◊ü',
				strategyName: '◊©◊ù ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î:',
				strategySaved: '‚úÖ ◊î◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊†◊©◊û◊®◊î:',
				aiAssistant: 'ü§ñ ◊¢◊ï◊ñ◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊î (AI)',
				expectedConditions: '◊™◊†◊ê◊ô◊ù ◊¶◊§◊ï◊ô◊ô◊ù:',
				mixed: '◊û◊¢◊ï◊®◊ë',
				strategyInstructions: '◊î◊ï◊®◊ê◊ï◊™ ◊ú◊ê◊ú◊í◊ï◊®◊ô◊™◊ù:',
				aiPlaceholder: "◊ú◊ì◊ï◊í◊û◊î: '◊™◊ü ◊ì◊ê◊ë◊ú ◊°◊ò◊ô◊†◊ò◊ô◊ù ◊ë◊ú◊ô◊ú◊î ◊ú◊ó◊ï◊ú◊ô◊î ◊ê', '◊©◊û◊ï◊® ◊ê◊™ ◊†◊î◊í X ◊ú◊°◊ï◊£'...",
				generateAi: 'ü§ñ ◊¶◊ï◊® ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				analyzing: 'ü§ñ ◊û◊†◊™◊ó ◊ê◊°◊ò◊®◊ò◊í◊ô◊î...',
				aiApplied: '‚úÖ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î ◊î◊ï◊ó◊ú◊î!',
				aiError: '‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊ô◊¶◊ô◊®◊™ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î',
				pitClosedStart: 'üö´ ◊§◊ô◊ò◊° ◊°◊í◊ï◊® ◊ë◊î◊™◊ó◊ú◊î (◊ì◊ß\')',
				pitClosedEnd: 'üö´ ◊§◊ô◊ò◊° ◊°◊í◊ï◊® ◊ë◊°◊ï◊£ (◊ì◊ß\')',
				finish: '◊°◊ô◊ï◊ù',
				raceFinished: 'üèÅ ◊î◊û◊ô◊®◊ï◊• ◊î◊°◊™◊ô◊ô◊ù!',
				savedToDb: '‚úÖ ◊†◊©◊û◊® ◊ú◊û◊°◊ì ◊î◊†◊™◊ï◊†◊ô◊ù',
				safetyWarning: '‚ö†Ô∏è ◊ê◊ñ◊î◊®◊™ ◊ë◊ò◊ô◊ó◊ï◊™',
			},
			fr: {
				offline: 'Hors ligne',
				subtitle: 'Gestionnaire de Strat√©gie de Course d\'Endurance',
				host: 'H√¥te',
				hostDesc: 'G√©rer la course',
				viewer: 'Spectateur',
				viewerDesc: 'Regarder en direct',
				yourCode: 'Votre Code:',
				retry: 'R√©essayer',
				raceSettings: '‚öôÔ∏è Param√®tres de Course',
				liveTiming: 'Chronom√©trage en Direct (Optionnel)',
				liveTimingUrl: 'URL Chronom√©trage (APEX/RaceFacer)',
				searchBy: 'Rechercher par:',
				team: '√âquipe',
				kart: 'Kart',
				driver: 'Pilote',
				testConnection: 'Tester',
				demo: 'D√©mo',
				manual: 'Manuel',
				duration: 'Dur√©e (heures)',
				reqStops: 'Arr√™ts Requis',
				minStint: 'Stint Min (min)',
				maxStint: 'Stint Max (min)',
				driverLimits: 'Limites Pilote (0 = illimit√©)',
				minDrive: 'Min Conduite',
				maxDrive: 'Max Conduite',
				pitTime: 'Temps Pit (sec)',
				releaseBuffer: 'Alerte Avance (sec)',
				doubleStint: 'Double',
				fuel: 'Carburant',
				squads: '√âquipes',
				fuelTankTime: 'Autonomie R√©servoir (min)',
				driversSetup: 'Pilotes (marquer le d√©part)',
				startRace: 'D√©marrer Course (H√¥te)',
				enterCode: 'Entrer Code H√¥te:',
				connect: 'Connecter',
				disconnect: 'D√©connecter',
				code: 'Code:',
				synced: 'Synchronis√©',
				raceTime: 'Temps Course',
				pitStops: 'Arr√™ts Pit',
				dry: 'Sec',
				wet: 'Mouill√©',
				drying: 'S√©chage',
				targetStint: 'Stint Cible',
				buildTime: 'Accumuler Temps',
				stintTime: 'Temps Stint',
				currentDriver: 'Pilote Actuel',
				activeSquad: '√âquipe Active:',
				resting: 'Au Repos:',
				push: 'Pousser',
				problem: 'Probl√®me',
				night: 'Nuit',
				resetMode: '‚Ü©Ô∏è R√©initialiser',
				driverHeader: 'Pilote',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Prochain Pilote',
				enterPit: 'üèÅ Entrer Pit',
				inPit: 'AU PIT',
				nextDriverIn: 'Prochain Pilote:',
				refuel: 'Changement Kart / Ravitaillement?',
				notifyDriver: 'Alerter Pilote',
				notified: 'Alert√© - Attente passage ligne',
				wait: 'Attendre...',
				cancelPit: 'Annuler Entr√©e Pit',
				manualInput: 'Saisie Manuelle',
				position: 'Position',
				laps: 'Tours',
				lastLap: 'Dernier Tour',
				bestLap: 'Meilleur Tour',
				gap: '√âcart au Leader',
				inPitNow: 'Actuellement au Pit',
				apply: 'Appliquer',
				cancel: 'Annuler',
				waitingData: 'En attente de donn√©es...',
				proxyData: 'Donn√©es Proxy:',
				liveView: 'Vue en Direct',
				connecting: 'Connexion...',
				connected: 'Connect√©',
				waitingRace: 'Connect√©! En attente de la course...',
				disconnected: 'D√©connect√©',
				enterUrl: '‚ùå Entrer URL',
				enterValue: '‚ùå Entrer',
				testing: 'üîÑ Test...',
				found: '‚úÖ Trouv√©! Position:',
				notFound: '‚ö†Ô∏è Non trouv√© - v√©rifier ou utiliser iframe',
				error: '‚ùå Erreur:',
				confirmEarlyPit: 'Fen√™tre ferm√©e! Entrer quand m√™me?',
				confirmExit: '‚úÖ Confirmer Passage Ligne',
				timeExceeded: 'üö® Temps D√©pass√©!',
				problemQuick: 'üê¢ Probl√®me - Entr√©e Rapide!',
				pushExtend: 'üî• On prolonge! Accumuler temps',
				nearLimit: '‚ö†Ô∏è Proche limite!',
				targetWindow: '‚úÖ Fen√™tre Cible',
				overExtend: 'üì• Prolongation Excessive',
				nightActive: 'üåô Nuit Active',
				pushActive: 'üî• Pousser Actif',
				problemActive: 'üê¢ Probl√®me Actif',
				stopped: 'Arr√™t√©',
				racePreview: 'Aper√ßu de la Strat√©gie',
				raceStartTime: 'Heure de D√©part',
				driverSchedule: 'Horaire des Pilotes',
				strategySummary: 'R√©sum√© de la Strat√©gie',
				editStrategy: 'Retour √† l\'√©cran principal',
				saveStrategy: 'Enregistrer la Strat√©gie',
				previewStrategy: 'Aper√ßu de la Strat√©gie',
				stopLiveTiming: 'Arr√™ter',
				activeRaceFound: 'Course Active Trouv√©e!',
				raceInProgress: 'Une course est actuellement en cours',
				timeRemaining: 'Temps Restant',
				continueRace: 'Continuer la Course',
				discardRace: 'Supprimer et Recommencer',
				raceWarning: 'La suppression effacera d√©finitivement les donn√©es de course',
				confirmDiscard: '√ätes-vous S√ªr?',
				confirmDiscardMessage: 'Cela supprimera d√©finitivement la course active. Cette action ne peut pas √™tre annul√©e.',
				yesDiscard: 'Oui, Supprimer la Course',
				noKeepRace: 'Non, Garder la Course',
				loadStrategy: 'Charger une Strat√©gie',
				savedStrategies: 'üìö Strat√©gies Enregistr√©es',
				noSavedStrategies: 'Aucune strat√©gie enregistr√©e',
				strategyName: 'Nom de la strat√©gie:',
				strategySaved: '‚úÖ Strat√©gie enregistr√©e:',
				aiAssistant: 'ü§ñ Assistant Strat√©gie IA',
				expectedConditions: 'Conditions Pr√©vues:',
				mixed: 'Mixte',
				strategyInstructions: 'Instructions:',
				aiPlaceholder: "ex: 'Double relais la nuit pour l'√©quipe A', 'Garder pilote X pour la fin'...",
				generateAi: 'ü§ñ G√©n√©rer Strat√©gie',
				analyzing: 'ü§ñ Analyse en cours...',
				aiApplied: '‚úÖ Strat√©gie appliqu√©e!',
				aiError: '‚ùå Erreur de g√©n√©ration',
				pitClosedStart: 'üö´ Pit Ferm√© D√©but (min)',
				pitClosedEnd: 'üö´ Pit Ferm√© Fin (min)',
				finish: 'Fin',
				raceFinished: 'üèÅ Course Termin√©e!',
				savedToDb: '‚úÖ Enregistr√© dans la BDD',
				safetyWarning: '‚ö†Ô∏è Avertissement de S√©curit√©',
			},
			pt: {
				offline: 'Offline',
				subtitle: 'Gestor de Estrat√©gia de Corrida de Endurance',
				host: 'Anfitri√£o',
				hostDesc: 'Gerir a corrida',
				viewer: 'Espectador',
				viewerDesc: 'Ver ao vivo',
				yourCode: 'Seu C√≥digo:',
				retry: 'Tentar Novamente',
				raceSettings: '‚öôÔ∏è Configura√ß√µes da Corrida',
				liveTiming: 'Cronometragem ao Vivo (Opcional)',
				liveTimingUrl: 'URL Cronometragem (APEX/RaceFacer)',
				searchBy: 'Pesquisar por:',
				team: 'Equipa',
				kart: 'Kart',
				driver: 'Piloto',
				testConnection: 'Testar',
				demo: 'Demo',
				manual: 'Manual',
				duration: 'Dura√ß√£o (horas)',
				reqStops: 'Paragens Obrigat√≥rias',
				minStint: 'Stint M√≠n (min)',
				maxStint: 'Stint M√°x (min)',
				driverLimits: 'Limites Piloto (0 = ilimitado)',
				minDrive: 'M√≠n Condu√ß√£o',
				maxDrive: 'M√°x Condu√ß√£o',
				pitTime: 'Tempo Pit (seg)',
				releaseBuffer: 'Alerta Antecipado (seg)',
				doubleStint: 'Duplo',
				fuel: 'Combust√≠vel',
				squads: 'Equipas',
				fuelTankTime: 'Autonomia Tanque (min)',
				driversSetup: 'Pilotos (marcar partida)',
				startRace: 'Iniciar Corrida (Anfitri√£o)',
				enterCode: 'Inserir C√≥digo Anfitri√£o:',
				connect: 'Conectar',
				disconnect: 'Desconectar',
				code: 'C√≥digo:',
				synced: 'Sincronizado',
				raceTime: 'Tempo Corrida',
				pitStops: 'Paragens Pit',
				dry: 'Seco',
				wet: 'Molhado',
				drying: 'Secando',
				targetStint: 'Stint Alvo',
				buildTime: 'Acumular Tempo',
				stintTime: 'Tempo Stint',
				currentDriver: 'Piloto Atual',
				activeSquad: 'Equipa Ativa:',
				resting: 'Descansando:',
				push: 'Atacar',
				problem: 'Problema',
				night: 'Noite',
				resetMode: '‚Ü©Ô∏è Reiniciar',
				driverHeader: 'Piloto',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Pr√≥ximo Piloto',
				enterPit: 'üèÅ Entrar Pit',
				inPit: 'NO PIT',
				nextDriverIn: 'Pr√≥ximo Piloto:',
				refuel: 'Troca Kart / Reabastecimento?',
				notifyDriver: 'Alertar Piloto',
				notified: 'Alertado - Aguardando passagem linha',
				wait: 'Aguardar...',
				cancelPit: 'Cancelar Entrada Pit',
				manualInput: 'Entrada Manual',
				position: 'Posi√ß√£o',
				laps: 'Voltas',
				lastLap: '√öltima Volta',
				bestLap: 'Melhor Volta',
				gap: 'Diferen√ßa ao L√≠der',
				inPitNow: 'Atualmente no Pit',
				apply: 'Aplicar',
				cancel: 'Cancelar',
				waitingData: 'Aguardando dados...',
				proxyData: 'Dados Proxy:',
				liveView: 'Vista ao Vivo',
				connecting: 'Conectando...',
				connected: 'Conectado',
				waitingRace: 'Conectado! Aguardando corrida...',
				disconnected: 'Desconectado',
				enterUrl: '‚ùå Inserir URL',
				enterValue: '‚ùå Inserir',
				testing: 'üîÑ Testando...',
				found: '‚úÖ Encontrado! Posi√ß√£o:',
				notFound: '‚ö†Ô∏è N√£o encontrado - verificar ou usar iframe',
				error: '‚ùå Erro:',
				confirmEarlyPit: 'Janela fechada! Entrar mesmo assim?',
				confirmExit: '‚úÖ Confirmar Passagem Linha',
				timeExceeded: 'üö® Tempo Excedido!',
				problemQuick: 'üê¢ Problema - Entrada R√°pida!',
				pushExtend: 'üî• Prolongando! Acumular tempo',
				nearLimit: '‚ö†Ô∏è Perto do limite!',
				targetWindow: '‚úÖ Janela Alvo',
				overExtend: 'üì• Prolongamento Excessivo',
				nightActive: 'üåô Noite Ativa',
				pushActive: 'üî• Atacar Ativo',
				problemActive: 'üê¢ Problema Ativo',
				stopped: 'Parado',
				racePreview: 'Visualiza√ß√£o da Estrat√©gia de Corrida',
				raceStartTime: 'Hora de In√≠cio da Corrida',
				driverSchedule: 'Hor√°rio dos Pilotos',
				strategySummary: 'Resumo da Estrat√©gia',
				editStrategy: 'Voltar para tela principal',
				saveStrategy: 'Salvar Estrat√©gia',
				previewStrategy: 'Visualizar Estrat√©gia',
				stopLiveTiming: 'Parar',
				activeRaceFound: 'Corrida Ativa Encontrada!',
				raceInProgress: 'Uma corrida est√° atualmente em andamento',
				timeRemaining: 'Tempo Restante',
				continueRace: 'Continuar Corrida',
				discardRace: 'Descartar e Come√ßar Novo',
				raceWarning: 'Descartar ir√° excluir permanentemente os dados da corrida',
				confirmDiscard: 'Tem Certeza?',
				confirmDiscardMessage: 'Isso excluir√° permanentemente a corrida ativa. Esta a√ß√£o n√£o pode ser desfeita.',
				yesDiscard: 'Sim, Descartar Corrida',
				noKeepRace: 'N√£o, Manter Corrida',
				loadStrategy: 'Carregar Estrat√©gia',
				savedStrategies: 'üìö Estrat√©gias Salvas',
				noSavedStrategies: 'Nenhuma estrat√©gia salva',
				strategyName: 'Nome da Estrat√©gia:',
				strategySaved: '‚úÖ Estrat√©gia salva:',
				aiAssistant: 'ü§ñ Assistente de Estrat√©gia IA',
				expectedConditions: 'Condi√ß√µes Esperadas:',
				mixed: 'Misto',
				strategyInstructions: 'Instru√ß√µes:',
				aiPlaceholder: "ex: 'Duplo stint √† noite para Equipa A', 'Guardar piloto X para o fim'...",
				generateAi: 'ü§ñ Gerar Estrat√©gia',
				analyzing: 'ü§ñ Analisando estrat√©gia...',
				aiApplied: '‚úÖ Estrat√©gia aplicada!',
				aiError: '‚ùå Erro ao gerar',
				pitClosedStart: 'üö´ Pit Fechado In√≠cio (min)',
				pitClosedEnd: 'üö´ Pit Fechado Fim (min)',
				finish: 'Fim',
				raceFinished: 'üèÅ Corrida Terminada!',
				savedToDb: '‚úÖ Salvo no banco de dados',
				safetyWarning: '‚ö†Ô∏è Aviso de Seguran√ßa',
			}
		};
		
		function t(key) {
			return translations[currentLang][key] || translations['en'][key] || key;
		}
		
		function setLanguage(lang) {
			if (!['en', 'he', 'fr', 'pt'].includes(lang)) return;
			
			currentLang = lang;
			document.documentElement.lang = currentLang;
			document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
			
			document.getElementById('langSelect').value = currentLang;
			
			applyTranslations();
			localStorage.setItem('strateger_lang', currentLang);
		}

		function applyTranslations() {
			document.querySelectorAll('[data-i18n]').forEach(el => {
				const key = el.getAttribute('data-i18n');
				if (translations[currentLang][key]) {
					el.innerText = translations[currentLang][key];
				}
			});
			updateSearchPlaceholder();
			const aiInput = document.getElementById('strategyInstructions');
			if (aiInput) {
				aiInput.placeholder = t('aiPlaceholder');
			}
		}
		
		function updateSearchPlaceholder() {
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			const input = document.getElementById('searchValue');
			if (!input) return;
			
			const placeholders = {
				en: {
					team: 'Enter team name (e.g. RACING TEAM)',
					kart: 'Enter kart number (e.g. 07)',
					driver: 'Enter driver name (e.g. John)'
				},
				he: {
					team: '◊î◊õ◊†◊° ◊©◊ù ◊ß◊ë◊ï◊¶◊î (◊ú◊û◊©◊ú: RACING)',
					kart: '◊î◊õ◊†◊° ◊û◊°◊§◊® ◊ß◊ê◊®◊ò (◊ú◊û◊©◊ú: 07)',
					driver: '◊î◊õ◊†◊° ◊©◊ù ◊†◊î◊í (◊ú◊û◊©◊ú: ◊ô◊†◊ô◊ë)'
				},
				fr: {
					team: 'Nom d\'√©quipe (ex: RACING TEAM)',
					kart: 'Num√©ro de kart (ex: 07)',
					driver: 'Nom du pilote (ex: Jean)'
				},
				pt: {
					team: 'Nome da equipa (ex: RACING TEAM)',
					kart: 'N√∫mero do kart (ex: 07)',
					driver: 'Nome do piloto (ex: Jo√£o)'
				}
			};
			
			input.placeholder = placeholders[currentLang]?.[searchType] || placeholders.en[searchType];
		}
		
		// ==================== INIT ====================
		document.addEventListener('DOMContentLoaded', () => {
			// Load saved language
			const savedLang = localStorage.getItem('strateger_lang');
			if (savedLang && ['en', 'he', 'fr', 'pt'].includes(savedLang)) {
				currentLang = savedLang;
				document.documentElement.lang = currentLang;
				document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
			}
			document.getElementById('langSelect').value = currentLang;
			applyTranslations();
			
			// Setup search type change handler
			document.querySelectorAll('input[name="searchType"]').forEach(radio => {
				radio.addEventListener('change', updateSearchPlaceholder);
			});
			
			generateDrivers();
			runSim();
            restoreHostState();
            console.log("Strateger loaded");
            
            // Check for saved race after a short delay
            setTimeout(checkForSavedRace, 500);
		});

        // PeerJS configuration
        const peerConfig = {
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ]
            }
        };

        // ==================== ROLE SELECTION ====================
        function selectRole(r) {
			// Destroy existing peer if switching roles
			if (peer) {
				peer.destroy();
				peer = null;
			}
			conn = null;
			connections = [];
			
			// Hide load strategy button when switching roles
			const loadBtn = document.getElementById('loadStrategyBtn');
			if (loadBtn) loadBtn.classList.add('hidden');
			
            role = r;
            document.getElementById('hostBtn').classList.toggle('border-ice', r === 'host');
            document.getElementById('clientBtn').classList.toggle('border-neon', r === 'client');
            document.getElementById('hostSection').classList.toggle('hidden', r !== 'host');
            document.getElementById('clientSection').classList.toggle('hidden', r !== 'client');
            document.getElementById('configPanel').classList.add('hidden');

            if (r === 'host') {
                initHostPeer();
            } else {
                initClientPeer();
            }
        }

		function applyViewerMode() {
			const dashboard = document.getElementById('raceDashboard');
			
			if (role === 'client') {
				dashboard.classList.add('viewer-mode');
				
				// ‚úÖ ◊î◊°◊™◊® ◊õ◊§◊™◊ï◊®◊ô◊ù (◊ú◊ê disable)
				const hideInViewer = [
					'btnPush',
					'btnBad', 
					'btnNight',
					'btnResetMode',
					'pitEntryBtn'
				];
				
				hideInViewer.forEach(id => {
					const el = document.getElementById(id);
					if (el) {
						el.classList.add('hidden');
					}
				});
				
				// ◊í◊ù ◊î◊°◊™◊® ◊õ◊§◊™◊ï◊®◊ô ◊î◊™◊ê◊û◊î
				document.querySelectorAll('[data-viewer-disabled="true"]').forEach(el => {
					if (el.tagName === 'BUTTON' || el.onclick) {
						el.classList.add('hidden');
					}
				});
				
				const headerText = document.getElementById('headerModeText');
				if (headerText) {
					headerText.textContent = 'VIEWER MODE';
					headerText.classList.remove('text-gray-500');
					headerText.classList.add('text-neon');
				}
				
				console.log('‚úÖ Viewer mode - Buttons hidden');
				
			} else if (role === 'host') {
				dashboard.classList.remove('viewer-mode');
				
				const showInHost = ['btnPush', 'btnBad', 'btnResetMode', 'pitEntryBtn'];
				showInHost.forEach(id => {
					const el = document.getElementById(id);
					if (el && id !== 'btnResetMode') {  // resetMode ◊û◊ï◊¶◊í ◊®◊ß ◊õ◊©◊ô◊© mode
						el.classList.remove('hidden');
					}
				});
				
				// btnNight ◊™◊ú◊ï◊ô ◊ë-squads
				const btnNight = document.getElementById('btnNight');
				if (btnNight && config.useSquads) {
					btnNight.classList.remove('hidden');
				}
				
				document.querySelectorAll('[data-viewer-disabled="true"]').forEach(el => {
					el.classList.remove('hidden');
				});
				
				const headerText = document.getElementById('headerModeText');
				if (headerText) {
					headerText.textContent = 'LIVE';
					headerText.classList.add('text-gray-500');
					headerText.classList.remove('text-neon');
				}
				
				console.log('‚úÖ Host mode - Full control');
			}
		}

        // ==================== SIMULATION ====================
        function runSim() {
			// Store last calculation time to prevent infinite loops
			const now = Date.now();
			if (window.lastRunSimTime && now - window.lastRunSimTime < 100) return;
			window.lastRunSimTime = now;
			
			const raceDur = parseFloat(document.getElementById('raceDuration').value);
			const reqStops = parseInt(document.getElementById('reqPitStops').value);
			const minStint = parseFloat(document.getElementById('minStint').value);
			const maxStint = parseFloat(document.getElementById('maxStint').value);
			const allowDouble = document.getElementById('allowDouble').checked;
			const useSquads = document.getElementById('useSquads').checked;
			const minPit = parseInt(document.getElementById('minPitTime').value) || 0;
			
			// Get weather condition
			const weatherRadio = document.querySelector('input[name="weatherCondition"]:checked');
			aiStrategyConfig.weatherCondition = weatherRadio ? weatherRadio.value : 'dry';
			aiStrategyConfig.instructions = document.getElementById('strategyInstructions')?.value || '';
			
			// Get starter driver
			const starterRadio = document.querySelector('.starter-radio:checked');
			const allRadios = document.querySelectorAll('.starter-radio');
			aiStrategyConfig.starterDriverIdx = Array.from(allRadios).indexOf(starterRadio);
			
			if (!raceDur || !reqStops || !minStint || !maxStint) {
				document.getElementById('simResult').innerText = '‚ö†Ô∏è Please fill all fields';
				return;
			}
			
			const raceMs = raceDur * 3600000;
			const minStintMs = minStint * 60000;
			const maxStintMs = maxStint * 60000;
			
			// Apply weather penalty
			const weatherPrefs = strategyPreferences[aiStrategyConfig.weatherCondition];
			const effectiveMaxStintMs = Math.max(minStintMs, maxStintMs - weatherPrefs.stintPenalty - 60000); // Always -1min for safety
			
			const pitTimeMs = (minPit * 1000) * reqStops;
			const drivingMs = raceMs - pitTimeMs;
			const totalStints = reqStops + 1;
			
			let avgStintMs = Math.floor(drivingMs / totalStints);
			avgStintMs = Math.max(minStintMs, Math.min(effectiveMaxStintMs, avgStintMs));
			
			const drivers = Array.from(document.querySelectorAll('.driver-input')).map((input, i) => {
				const squadToggle = document.querySelectorAll('.squad-toggle')[i];
				return {
					name: input.value,
					squad: squadToggle?.checked ? 'B' : 'A',
					isStarter: i === aiStrategyConfig.starterDriverIdx
				};
			});
			
			// Generate strategy with AI considerations
			const strategy = generateSmartStrategy({
				totalStints,
				avgStintMs,
				minStintMs,
				maxStintMs: effectiveMaxStintMs,
				drivers,
				allowDouble,
				useSquads,
				weatherCondition: aiStrategyConfig.weatherCondition,
				instructions: aiStrategyConfig.instructions
			});
			
			// Save for later use
			window.generatedStrategy = strategy;
			
			// Display results
			const avgStintMin = (avgStintMs / 60000).toFixed(1);
			const totalDriveMin = (drivingMs / 60000).toFixed(0);
			
			let result = `‚úÖ ${totalStints} stints √ó ~${avgStintMin}min = ${totalDriveMin}min drive\n`;
			result += `üèÅ Pit stops: ${reqStops} √ó ${minPit}s = ${(reqStops * minPit / 60).toFixed(1)}min\n`;
			result += `${weatherPrefs.description}\n`;
			
			if (strategy.doubleStints && strategy.doubleStints.length > 0) {
				result += `\nüí™ ${strategy.doubleStints.length} double stints planned`;
			}
			
			if (useSquads && strategy.nightShifts) {
				result += `\nüåô Night mode: ${strategy.nightShifts} shift rotations`;
			}
			
			document.getElementById('simResult').innerText = result;
			
			// Update preview if it's showing
			if (!document.getElementById('previewScreen').classList.contains('hidden')) {
				updatePreview();
			}
			
			saveHostState();
		}

		function generateSmartStrategy(params) {
			const {
				totalStints,
				avgStintMs,
				minStintMs,
				maxStintMs,
				drivers,
				allowDouble,
				useSquads,
				weatherCondition,
				instructions
			} = params;
			
			const stints = [];
			const doubleStints = [];
			let nightShifts = 0;
			
			// Find starter
			const starterIdx = drivers.findIndex(d => d.isStarter);
			let currentDriverIdx = starterIdx >= 0 ? starterIdx : 0;
			
			// Separate squads if needed
			const squadA = drivers.filter(d => d.squad === 'A');
			const squadB = drivers.filter(d => d.squad === 'B');
			
			// Calculate rough night period (assuming ~8-12 hours into race)
			const nightStartStint = Math.floor(totalStints * 0.4);
			const nightEndStint = Math.floor(totalStints * 0.7);
			
			let remainingMs = totalStints * avgStintMs;
			let stintNumber = 1;
			
			for (let i = 0; i < totalStints; i++) {
				const isNightPeriod = useSquads && i >= nightStartStint && i < nightEndStint;
				const isEndGame = i >= totalStints - 3; // Last 3 stints
				const isStarting = i === 0;
				
				let stintDuration = avgStintMs;
				let isDouble = false;
				
				// Strategy logic
				if (allowDouble && isNightPeriod && Math.random() > 0.5) {
					// Double stint during night to finish faster
					stintDuration = Math.min(maxStintMs, avgStintMs * 1.8);
					isDouble = true;
					doubleStints.push(i);
				} else if (isEndGame && allowDouble) {
					// Consider double in endgame
					stintDuration = Math.min(maxStintMs, avgStintMs * 1.5);
				} else if (weatherCondition === 'wet') {
					// Shorter, safer stints in wet
					stintDuration = Math.max(minStintMs, avgStintMs * 0.85);
				}
				
				// Select driver
				let driver;
				if (isStarting) {
					driver = drivers[currentDriverIdx];
				} else if (useSquads && isNightPeriod) {
					// Rotate within active squad
					const activeSquad = Math.floor((i - nightStartStint) / 2) % 2 === 0 ? squadA : squadB;
					if (i === nightStartStint || i === nightEndStint - Math.floor((nightEndStint - nightStartStint) / 2)) {
						nightShifts++;
					}
					const squadDrivers = activeSquad.map((d, idx) => drivers.findIndex(dr => dr.name === d.name));
					currentDriverIdx = squadDrivers[Math.floor(Math.random() * squadDrivers.length)];
					driver = drivers[currentDriverIdx];
				} else {
					// Normal rotation
					currentDriverIdx = (currentDriverIdx + 1) % drivers.length;
					driver = drivers[currentDriverIdx];
				}
				
				stints.push({
					number: stintNumber++,
					driver: driver.name,
					durationMs: stintDuration,
					isDouble: isDouble,
					isNight: isNightPeriod,
					squad: driver.squad
				});
				
				remainingMs -= stintDuration;
			}
			
			return {
				stints,
				avgStintMs,
				totalStints,
				doubleStints,
				nightShifts,
				weatherCondition,
				starterDriver: drivers[starterIdx >= 0 ? starterIdx : 0].name,
				timestamp: Date.now()
			};
		}

		async function generateAIStrategy() {
			const statusEl = document.getElementById('aiStrategyStatus');
			statusEl.classList.remove('hidden');
			statusEl.innerText = 'ü§ñ Analyzing strategy...';
			statusEl.className = 'text-[10px] text-yellow-500 text-center mt-2';
			
			const instructions = document.getElementById('strategyInstructions').value;
			
			if (!instructions || instructions.trim().length < 10) {
				statusEl.innerText = '‚ö†Ô∏è Please provide detailed instructions';
				statusEl.className = 'text-[10px] text-red-400 text-center mt-2';
				return;
			}
			
			// Gather current config
			const raceDur = parseFloat(document.getElementById('raceDuration').value);
			const reqStops = parseInt(document.getElementById('reqPitStops').value);
			const minStint = parseFloat(document.getElementById('minStint').value);
			const maxStint = parseFloat(document.getElementById('maxStint').value);
			const allowDouble = document.getElementById('allowDouble').checked;
			const useSquads = document.getElementById('useSquads').checked;
			const weatherCondition = document.querySelector('input[name="weatherCondition"]:checked')?.value || 'dry';
			
			const drivers = Array.from(document.querySelectorAll('.driver-input')).map((input, i) => {
				const starterRadio = document.querySelectorAll('.starter-radio')[i];
				const squadToggle = document.querySelectorAll('.squad-toggle')[i];
				return {
					name: input.value,
					isStarter: starterRadio?.checked || false,
					squad: squadToggle?.checked ? 'B' : 'A'
				};
			});
			
			const prompt = `You are an expert karting race strategist. Analyze this endurance race setup and provide optimal strategy recommendations.

		**Race Configuration:**
		- Duration: ${raceDur} hours
		- Required pit stops: ${reqStops}
		- Stint limits: ${minStint}-${maxStint} minutes
		- Weather: ${weatherCondition}
		- Double stints allowed: ${allowDouble ? 'Yes' : 'No'}
		- Squad system: ${useSquads ? 'Yes (A/B rotation for night shifts)' : 'No'}
		- Starting driver: ${drivers.find(d => d.isStarter)?.name || drivers[0].name}

		**Drivers:**
		${drivers.map(d => `- ${d.name} (Squad ${d.squad})${d.isStarter ? ' [STARTER]' : ''}`).join('\n')}

		**User Instructions:**
		${instructions}

		**Please provide:**
		1. Recommended stint durations considering max-1min safety buffer
		2. Driver rotation strategy (starting with the designated starter)
		3. If squads enabled: optimal night shift strategy with double stints
		4. Weather-based adjustments
		5. Endgame strategy (last 2-3 stints)
		6. Any special considerations based on user instructions

		Format your response as specific, actionable recommendations in JSON format:
		{
		"stintTargetMinutes": number,
		"starterNote": "string",
		"driverRotation": ["driver1", "driver2", ...],
		"doubleStintRecommendations": ["stint 5-6 for Squad A in night", ...],
		"weatherNotes": "string",
		"endgameStrategy": "string",
		"specialConsiderations": ["note1", "note2", ...]
		}`;

			try {
				const response = await fetch("https://api.anthropic.com/v1/messages", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({
						model: "claude-sonnet-4-20250514",
						max_tokens: 1000,
						messages: [
							{ role: "user", content: prompt }
						],
					})
				});
				
				const data = await response.json();
				
				if (data.content && data.content[0]) {
					const aiResponse = data.content[0].text;
					
					// Try to parse JSON from response
					const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
					if (jsonMatch) {
						const recommendations = JSON.parse(jsonMatch[0]);
						applyAIRecommendations(recommendations);
						statusEl.innerText = '‚úÖ AI strategy applied!';
						statusEl.className = 'text-[10px] text-green-400 text-center mt-2';
					} else {
						// Show text response
						statusEl.innerText = '‚úÖ Strategy generated - check console for details';
						console.log('AI Strategy Recommendations:', aiResponse);
						statusEl.className = 'text-[10px] text-green-400 text-center mt-2';
					}
				}
			} catch (error) {
				console.error('AI Strategy Error:', error);
				statusEl.innerText = '‚ùå Error generating strategy';
				statusEl.className = 'text-[10px] text-red-400 text-center mt-2';
			}
			
			// Hide status after 5 seconds
			setTimeout(() => {
				statusEl.classList.add('hidden');
			}, 5000);
		}

		function applyAIRecommendations(recommendations) {
			console.log('Applying AI recommendations:', recommendations);
			
			// Update target stint if provided
			if (recommendations.stintTargetMinutes) {
				const currentMax = parseFloat(document.getElementById('maxStint').value);
				const suggested = Math.min(currentMax - 1, recommendations.stintTargetMinutes);
				// Store for use in strategy generation
				aiStrategyConfig.targetStintMin = suggested;
			}
			
			// Store AI recommendations for strategy generation
			aiStrategyConfig.useAI = true;
			aiStrategyConfig.recommendations = recommendations;
			
			// Re-run simulation with AI insights
			runSim();
			
			// Show recommendations in a readable format
			let summary = 'ü§ñ AI Recommendations:\n\n';
			if (recommendations.starterNote) summary += `üèÅ ${recommendations.starterNote}\n`;
			if (recommendations.weatherNotes) summary += `üå§Ô∏è ${recommendations.weatherNotes}\n`;
			if (recommendations.endgameStrategy) summary += `üèÜ ${recommendations.endgameStrategy}\n`;
			
			if (recommendations.specialConsiderations) {
				summary += '\nüí° Key Points:\n';
				recommendations.specialConsiderations.forEach(note => {
					summary += `  ‚Ä¢ ${note}\n`;
				});
			}
			
			document.getElementById('simResult').innerText = summary;
		}

        function toggleConfigPanel(event) {
			// ◊ê◊ù ◊ñ◊î ◊ú◊ó◊ô◊¶◊î ◊¢◊ú ◊†◊î◊í, ◊î◊™◊¢◊ú◊ù
			if (event && event.target.closest('.starter-indicator, .starter-radio, .driver-input')) {
				console.log('üõ°Ô∏è Blocked toggle from driver interaction');
				return;
			}
			
			const panel = document.getElementById('configPanel');
			const arrow = document.getElementById('configArrow');
			panel.classList.toggle('hidden');
			arrow.innerText = panel.classList.contains('hidden') ? '‚ñº' : '‚ñ≤';
		}
		
		// ==================== LIVE TIMING ====================
		function updateSearchConfig() {
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			const searchValue = document.getElementById('searchValue')?.value || '';
			
			searchConfig.teamName = '';
			searchConfig.driverName = '';
			searchConfig.kartNumber = '';
			
			if (searchType === 'team') {
				searchConfig.teamName = searchValue;
			} else if (searchType === 'kart') {
				searchConfig.kartNumber = searchValue;
			} else if (searchType === 'driver') {
				searchConfig.driverName = searchValue;
			}
		}
		
		function testLiveTiming() {
			const url = document.getElementById('liveTimingUrl').value;
			const searchValue = document.getElementById('searchValue')?.value || '';
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			
			const statusEl = document.getElementById('liveTimingStatus');
			
			if (!url) {
				statusEl.innerText = t('enterUrl');
				statusEl.className = "text-[10px] text-red-500 text-center";
				return;
			}
			
			if (!searchValue) {
				const typeNames = { team: t('team'), kart: t('kart'), driver: t('driver') };
				statusEl.innerText = `${t('enterValue')} ${typeNames[searchType]}`;
				statusEl.className = "text-[10px] text-red-500 text-center";
				return;
			}
			
			liveTimingConfig.url = url;
			liveTimingConfig.enabled = true;
			updateSearchConfig();
			
			statusEl.innerText = t('testing');
			statusEl.className = "text-[10px] text-yellow-500 text-center";
			
			fetchLiveTimingFromProxy().then(() => {
				if (liveData.position) {
					statusEl.innerText = `${t('found')} ${liveData.position}`;
					statusEl.className = "text-[10px] text-green-500 text-center font-bold";
				} else {
					statusEl.innerText = t('notFound');
					statusEl.className = "text-[10px] text-yellow-500 text-center";
				}
			}).catch(e => {
				statusEl.innerText = `${t('error')} ${e.message}`;
				statusEl.className = "text-[10px] text-red-500 text-center";
			});
		}
		
		async function fetchLiveTimingFromProxy() {
			if (!liveTimingConfig.url) {
				console.log('No live timing URL configured');
				return;
			}
			
			// ◊¢◊ì◊õ◊ü ◊ê◊™ ◊î-search config
			updateSearchConfig();
			
			// ◊¢◊ì◊õ◊ü ◊°◊ò◊ò◊ï◊°
			updateProxyStatus("üîÑ " + t('connecting'));
			
			const url = liveTimingConfig.url;
			const searchTerm = searchConfig.driverName || searchConfig.teamName || searchConfig.kartNumber || '';
			
			console.log(`[Strateger] Starting live timing with URL: ${url}`);
			console.log(`[Strateger] Search term: "${searchTerm}"`);
			
			// ◊¶◊ï◊® ◊û◊†◊î◊ú ◊ó◊ì◊© ◊ê◊ù ◊ú◊ê ◊ß◊ô◊ô◊ù
			if (!liveTimingManager) {
				liveTimingManager = new LiveTimingManager();
			}
			
			// ◊î◊™◊ó◊ú ◊ê◊™ ◊î-scraper
			liveTimingManager.start(url, searchTerm, {
				updateInterval: 5000, // 5 ◊©◊†◊ô◊ï◊™ ◊ë◊ô◊ü ◊¢◊ì◊õ◊ï◊†◊ô◊ù
				
				/**
				 * ◊†◊ß◊®◊ê ◊ë◊õ◊ú ◊§◊¢◊ù ◊©◊ô◊© ◊¢◊ì◊õ◊ï◊ü ◊û◊î◊°◊ß◊®◊ô◊ô◊§◊®
				 */
				onUpdate: (data) => {
					console.log(`[Strateger] Live timing update #${data.updateNumber} received`);
					
					// ◊¢◊ì◊õ◊ü ◊ê◊™ ◊î◊û◊¶◊ë ◊î◊í◊ú◊ï◊ë◊ú◊ô ◊©◊ú Strateger
					if (data.ourTeam) {
						// ◊©◊û◊ï◊® ◊û◊ô◊ß◊ï◊ù ◊ß◊ï◊ì◊ù
						liveData.previousPosition = liveData.position;
						
						// ◊¢◊ì◊õ◊ü ◊†◊™◊ï◊†◊ô◊ù
						liveData.position = data.ourTeam.position;
						liveData.lastLap = data.ourTeam.lastLap;
						liveData.bestLap = data.ourTeam.bestLap;
						liveData.laps = data.ourTeam.totalLaps;
						liveData.gapToLeader = data.ourTeam.gap;
						
						console.log(`[Strateger] Our team: P${data.ourTeam.position}, ${data.ourTeam.totalLaps} laps, Gap: ${data.ourTeam.gap}s`);
					} else {
						console.warn('[Strateger] Our team not found in results');
					}
					
					// ◊¢◊ì◊õ◊ü ◊®◊©◊ô◊û◊™ ◊û◊™◊ó◊®◊ô◊ù
					liveData.competitors = data.competitors;
					
					// ◊¢◊ì◊õ◊ü UI
					updateLiveTimingUI();
					
					// ◊¢◊ì◊õ◊ü ◊°◊ò◊ò◊ï◊° ◊¢◊ù ◊©◊ù ◊î◊°◊§◊ß
					const statusText = data.found 
						? `‚úÖ ${t('connected')} - ${data.provider}` 
						: `‚ö†Ô∏è ${t('connected')} - ${t('teamNotFound')}`;
					updateProxyStatus(statusText);
					
					// ◊°◊†◊õ◊®◊ü ◊¢◊ù WebRTC ◊ê◊ù ◊ô◊© peer
					if (typeof syncDataToPeer === 'function') {
						syncDataToPeer();
					}
				},
				
				/**
				 * ◊†◊ß◊®◊ê ◊õ◊©◊ô◊© ◊©◊í◊ô◊ê◊î
				 */
				onError: (error, consecutiveErrors) => {
					console.error(`[Strateger] Live timing error (${consecutiveErrors || 0} consecutive):`, error.message);
					
					// ◊î◊¶◊í ◊©◊í◊ô◊ê◊î ◊ú◊û◊©◊™◊û◊©
					const errorMsg = consecutiveErrors >= 3 
						? `‚ö†Ô∏è ${t('connectionIssues')}` 
						: `‚ö†Ô∏è ${error.message}`;
					updateProxyStatus(errorMsg);
					
					// ◊ê◊ù ◊ô◊© ◊î◊®◊ë◊î ◊©◊í◊ô◊ê◊ï◊™ ◊ë◊®◊¶◊ô◊§◊ï◊™, ◊†◊°◊î iframe ◊õ◊í◊ô◊ë◊ï◊ô
					if (consecutiveErrors >= 3 && !liveData.position) {
						console.log('[Strateger] Too many errors, falling back to iframe');
						setTimeout(() => {
							if (!liveData.position) {
								updateProxyStatus("‚ö†Ô∏è " + t('usingIframe'));
								openLiveTimingEmbed();
							}
						}, 3000);
					}
				},
				
				/**
				 * ◊†◊ß◊®◊ê ◊õ◊©◊ô◊© ◊©◊í◊ô◊ê◊î ◊ó◊û◊ï◊®◊î (5 ◊©◊í◊ô◊ê◊ï◊™ ◊ë◊®◊¶◊ô◊§◊ï◊™)
				 */
				onFatalError: (error) => {
					console.error('[Strateger] Fatal error, scraper stopped:', error.message);
					updateProxyStatus("‚ùå " + t('connectionFailed'));
					
					// ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô: ◊§◊™◊ó iframe ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™
					setTimeout(() => {
						openLiveTimingEmbed();
					}, 2000);
				}
			});
		}
		
		function parseTimeToMs(timeStr) {
			if (!timeStr) return null;
			if (typeof timeStr === 'number') return timeStr;
			
			const match = String(timeStr).match(/(?:(\d{1,2}):)?(\d{1,2}):?(\d{2})\.(\d{2,3})/);
			if (match) {
				const hours = match[1] ? parseInt(match[1]) : 0;
				const mins = parseInt(match[2]) || 0;
				const secs = parseInt(match[3]) || 0;
				let ms = parseInt(match[4]) || 0;
				if (match[4].length === 2) ms *= 10;
				return (hours * 3600 + mins * 60 + secs) * 1000 + ms;
			}
			
			const secMatch = String(timeStr).match(/(\d+)\.(\d{2,3})/);
			if (secMatch) {
				let ms = parseInt(secMatch[2]);
				if (secMatch[2].length === 2) ms *= 10;
				return parseInt(secMatch[1]) * 1000 + ms;
			}
			
			return null;
		}
		
		function updateProxyStatus(msg) {
			const el = document.getElementById('liveTimingStatus');
			if (el) el.innerText = msg;
		}
		
		function startProxyLiveTiming() {
			if (proxyFetchInterval) clearInterval(proxyFetchInterval);
			
			fetchLiveTimingFromProxy();
			proxyFetchInterval = setInterval(fetchLiveTimingFromProxy, 5000);
		}
		
		function stopProxyLiveTiming() {
			if (proxyFetchInterval) {
				clearInterval(proxyFetchInterval);
				proxyFetchInterval = null;
			}
		}
		
		// ==================== MANUAL INPUT ====================
		function openManualInput() {
			document.getElementById('manualInputModal').classList.remove('hidden');
			
			// Pre-fill with current values
			if (liveData.position) document.getElementById('manualPosition').value = liveData.position;
			if (liveData.laps) document.getElementById('manualLaps').value = liveData.laps;
			if (liveData.lastLap) document.getElementById('manualLastLap').value = formatLapTime(liveData.lastLap);
			if (liveData.bestLap) document.getElementById('manualBestLap').value = formatLapTime(liveData.bestLap);
		}
		
		function closeManualInput() {
			document.getElementById('manualInputModal').classList.add('hidden');
		}
		
		function applyManualInput() {
			const pos = parseInt(document.getElementById('manualPosition').value);
			const laps = parseInt(document.getElementById('manualLaps').value);
			const lastLap = parseTimeToMs(document.getElementById('manualLastLap').value);
			const bestLap = parseTimeToMs(document.getElementById('manualBestLap').value);
			const gap = document.getElementById('manualGap').value;
			const inPit = document.getElementById('manualInPit').checked;
			
			if (pos) {
				liveData.previousPosition = liveData.position;
				liveData.position = pos;
			}
			if (laps) liveData.laps = laps;
			if (lastLap) liveData.lastLap = lastLap;
			if (bestLap) liveData.bestLap = bestLap;
			if (gap) liveData.gapToLeader = parseTimeToMs(gap);
			
			// Enable live timing display
			liveTimingConfig.enabled = true;
			document.getElementById('liveTimingPanel').classList.remove('hidden');
			document.getElementById('liveIndicator').classList.remove('hidden');
			
			updateLiveTimingUI();
			closeManualInput();
			broadcast();
		}
		
		// ==================== LIVE TIMING EMBED ====================
		function openLiveTimingEmbed() {
			const url = liveTimingConfig.url;
			if (!url) return;
			
			document.getElementById('liveTimingEmbed').classList.remove('hidden');
			document.getElementById('liveTimingIframe').src = url;
		}
		
		function closeLiveTimingEmbed() {
			document.getElementById('liveTimingEmbed').classList.add('hidden');
			document.getElementById('liveTimingIframe').src = 'about:blank';
		}
		
		function toggleLiveTimingEmbed() {
			const embed = document.getElementById('liveTimingEmbed');
			if (embed.classList.contains('hidden')) {
				openLiveTimingEmbed();
			} else {
				closeLiveTimingEmbed();
			}
		}
		
		function refreshLiveTiming() {
			fetchLiveTimingFromProxy();
		}
		
		// ==================== PRE-RACE SIMULATION ====================
		let previewData = null;

		function generatePreview() {
			const inputs = document.querySelectorAll('.driver-input');
			
			if (inputs.length < 2) {
				alert('Minimum 2 drivers required');
				return;
			}
			
			// Read from form
			config = {
				raceMs: parseFloat(document.getElementById('raceDuration').value) * 3600000,
				reqStops: parseInt(document.getElementById('reqPitStops').value) || 0,
				minPitSec: parseInt(document.getElementById('minPitTime').value) || 120,
				minStintMs: parseFloat(document.getElementById('minStint').value) * 60000,
				maxStintMs: parseFloat(document.getElementById('maxStint').value) * 60000,
				trackFuel: document.getElementById('trackFuel').checked,
				useSquads: document.getElementById('useSquads').checked,
				pitClosedStartMs: (parseInt(document.getElementById('pitClosedStart').value) || 0) * 60000,
				pitClosedEndMs: (parseInt(document.getElementById('pitClosedEnd').value) || 0) * 60000
			};
			
			// ‚úÖ Debug: verify what was read
			console.log('Config reqStops:', config.reqStops);
			console.log('Form value:', document.getElementById('reqPitStops').value);
			
			// Build drivers from form
			const squads = document.querySelectorAll('.squad-toggle');
			drivers = Array.from(inputs).map((d, i) => ({ 
				name: d.value, 
				totalMs: 0, 
				stints: 0, 
				squad: squads[i]?.checked ? 'B' : 'A',
				color: `hsl(${(i * 360 / inputs.length)}, 70%, 50%)`,
				logs: []
			}));
			
			// Calculate preview data
			previewData = {
				startTime: null,
				drivers: [],
				totalRaceTime: config.raceMs,
				totalStops: config.reqStops,
				stints: []
			};
			
			// Set default start time to now
			const now = new Date();
			document.getElementById('raceStartTime').value = 
				now.getHours().toString().padStart(2, '0') + ':' + 
				now.getMinutes().toString().padStart(2, '0');
			
			updatePreview();
			
			// Show preview screen
			document.getElementById('setupScreen').classList.add('hidden');
			document.getElementById('previewScreen').classList.remove('hidden');
		}

		function showStrategyModal(strategies) {
			const list = document.getElementById('strategyList');
			
			if (!strategies || strategies.length === 0) {
				list.innerHTML = '<p class="text-gray-500 text-center py-8">No saved strategies yet</p>';
			} else {
				list.innerHTML = strategies.map(s => `
					<div class="bg-navy-800 p-3 rounded-lg border border-gray-700 hover:border-ice cursor-pointer transition"
						onclick="loadStrategy(${s.id})">
						<div class="flex justify-between items-start mb-2">
							<span class="font-bold text-white">${s.name}</span>
							<span class="text-xs text-gray-500">${new Date(s.createdAt).toLocaleDateString()}</span>
						</div>
						<div class="flex gap-4 text-xs text-gray-400">
							<span>‚è±Ô∏è ${formatTime(s.raceDuration)}</span>
							<span>üîß ${s.requiredStops} stops</span>
							<span>üë• ${s.drivers?.length || '?'} drivers</span>
						</div>
						<div class="mt-2 text-xs text-gray-500">
							${s.drivers?.map(d => d.name).join(', ') || ''}
						</div>
					</div>
				`).join('');
			}
			
			document.getElementById('strategyModal').classList.remove('hidden');
		}

		function closeStrategyModal() {
			document.getElementById('strategyModal').classList.add('hidden');
		}

		function updatePreview() {
			const startTimeInput = document.getElementById('raceStartTime').value;
			if (!startTimeInput) return;
			
			const [hours, minutes] = startTimeInput.split(':').map(Number);
			const startDate = new Date();
			startDate.setHours(hours, minutes, 0, 0);
			
			previewData.startTime = startDate;
			
			// 1. Calculate the TOTAL "Budget" for driving
			const totalRaceMs = config.raceMs;
			const pitTimeMs = config.minPitSec * 1000;
			const stopsRequired = config.reqStops;
			const stintsRequired = stopsRequired + 1;
			
			// Pit stops happen between stints, so Total Pits = Stints - 1
			// Note: If stopsRequired is strictly enforced, ensure logic aligns. 
			// Usually N stops means N+1 stints.
			const totalPitTime = stopsRequired * pitTimeMs; 
			const totalDrivingBudget = totalRaceMs - totalPitTime;
			
			if (totalDrivingBudget <= 0) {
				alert('Error: Pit time exceeds race duration!');
				return;
			}

			// Constraints
			const safeMaxStintMs = config.maxStintMs - 60000; // Max - 1 min
			const minStintMs = config.minStintMs;
			const pitClosedStartMs = config.pitClosedStartMs || 0;
			const pitClosedEndMs = config.pitClosedEndMs || 0;

			// 2. Initialize all stints with EQUAL duration (Average)
			// This guarantees mathematically that Sum(Stints) + Sum(Pits) = RaceDuration
			let durations = new Array(stintsRequired).fill(Math.floor(totalDrivingBudget / stintsRequired));
			
			// Distribute remainder ms to make it exact
			let remainder = totalDrivingBudget % stintsRequired;
			for(let i=0; i<remainder; i++) durations[i]++;

			// 3. APPLY LOGIC: Front-Load early stints, shorten later ones
			// We try to push early stints to SafeMax, taking time from later stints
			
			const frontLoadCount = Math.ceil(stintsRequired * 0.4); // Push first 40% of stints
			
			for (let i = 0; i < stintsRequired; i++) {
				// Don't touch the very last stint yet (it has special constraints)
				if (i === stintsRequired - 1) continue;

				let targetDur = durations[i];
				
				// If it's an early stint, aim for SafeMax
				if (i < frontLoadCount) {
					targetDur = safeMaxStintMs;
				}
				
				// Handle Pit Closed Start constraint for first stint
				if (i === 0) {
					targetDur = Math.max(targetDur, pitClosedStartMs);
				}
				
				// How much do we want to add?
				let wantedToAdd = targetDur - durations[i];
				
				if (wantedToAdd > 0) {
					// Try to "steal" this time from future stints (starting from the end backwards)
					// We leave the last stint alone for now unless necessary, to keep it flexible for PitClosedEnd
					let stolenAmount = 0;
					
					// Iterate backwards from second-to-last down to i+1
					for (let j = stintsRequired - 2; j > i; j--) {
						if (wantedToAdd <= 0) break;
						
						let available = durations[j] - minStintMs;
						if (available > 0) {
							let take = Math.min(available, wantedToAdd);
							durations[j] -= take;
							stolenAmount += take;
							wantedToAdd -= take;
						}
					}
					
					// Add what we managed to steal to the current stint
					durations[i] += stolenAmount;
				}
			}

			// 4. Validate Last Stint (Pit Closed End)
			// The last stint MUST be >= PitClosedEnd
			const lastIdx = stintsRequired - 1;
			if (durations[lastIdx] < pitClosedEndMs) {
				const deficit = pitClosedEndMs - durations[lastIdx];
				
				// We need to find 'deficit' time from previous stints (starting from the beginning this time)
				// to give to the last stint
				let collected = 0;
				for (let i = 0; i < lastIdx; i++) {
					if (deficit <= 0) break;
					
					// If first stint, respect PitClosedStart
					let limit = (i === 0) ? Math.max(minStintMs, pitClosedStartMs) : minStintMs;
					
					let available = durations[i] - limit;
					if (available > 0) {
						let take = Math.min(available, deficit);
						durations[i] -= take;
						collected += take;
						deficit -= take;
					}
				}
				durations[lastIdx] += collected;
			}

			// 5. Final check for AI overrides (optional, applies mostly to driver selection, not timing in this fix)
			// If you want AI to override durations, apply it here, but verify total sum matches budget.

			// ========== RENDER DATA ==========
			const driversCount = drivers.length;
			let driverSchedule = drivers.map((d, idx) => ({
				name: d.name,
				color: d.color || `hsl(${(idx * 360 / driversCount)}, 70%, 50%)`,
				stints: [],
				totalTime: 0
			}));

			const timeline = [];
			let currentTime = 0;
			
			// Get starter driver index
			const starterRadio = document.querySelector('.starter-radio:checked');
			const allRadios = document.querySelectorAll('.starter-radio');
			window.previewStarterIdx = starterRadio ? Array.from(allRadios).indexOf(starterRadio) : 0;
			
			for (let s = 0; s < stintsRequired; s++) {
				const driverIdx = (window.previewStarterIdx + s) % driversCount;
				const isLastStint = s === stintsRequired - 1;
				let stintDuration = durations[s];
				
				// Add stint to timeline
				timeline.push({
					type: 'stint',
					stintNumber: s + 1,
					driverIdx,
					driverName: drivers[driverIdx].name,
					color: driverSchedule[driverIdx].color,
					start: currentTime,
					duration: stintDuration,
					startTime: new Date(startDate.getTime() + currentTime),
					endTime: new Date(startDate.getTime() + currentTime + stintDuration)
				});
				
				// Update driver stats
				driverSchedule[driverIdx].stints.push({
					number: driverSchedule[driverIdx].stints.length + 1,
					globalNumber: s + 1,
					start: currentTime,
					duration: stintDuration,
					startTime: new Date(startDate.getTime() + currentTime),
					endTime: new Date(startDate.getTime() + currentTime + stintDuration)
				});
				driverSchedule[driverIdx].totalTime += stintDuration;
				
				currentTime += stintDuration;
				
				// Add pit stop (except after last stint)
				if (!isLastStint) {
					timeline.push({
						type: 'pit',
						pitNumber: s + 1,
						start: currentTime,
						duration: pitTimeMs,
						startTime: new Date(startDate.getTime() + currentTime)
					});
					currentTime += pitTimeMs;
				}
			}
			
			previewData.timeline = timeline;
			previewData.driverSchedule = driverSchedule;
			
			renderPreview();
		}

		function renderPreview() {
			if (!previewData || !previewData.timeline) return;

			const timeline = previewData.timeline;
			const totalTime = config.raceMs;
			
			// Calculate ACTUAL values from timeline
			const actualStints = timeline.filter(t => t.type === 'stint');
			const actualStops = timeline.filter(t => t.type === 'pit').length;
			const actualDrivingTime = actualStints.reduce((sum, s) => sum + s.duration, 0);
			const actualAvgStint = actualDrivingTime / actualStints.length;
			
			// Get elements (with safety check)
			const scheduleEl = document.getElementById('driverScheduleList');
			const summaryEl = document.getElementById('strategySummary');
			const timeStartEl = document.getElementById('timelineStart');
			const timeEndEl = document.getElementById('timelineEnd');
			
			// Safety check - if elements don't exist, return
			if ( !scheduleEl || !summaryEl || !timeStartEl || !timeEndEl) {
				console.error('Missing preview elements:', {
					scheduleEl: !!scheduleEl,
					summaryEl: !!summaryEl,
					timeStartEl: !!timeStartEl,
					timeEndEl: !!timeEndEl
				});
				return;
			}
			
			timeline.forEach((item, index) => {
				const el = document.createElement('div');
				const widthPercent = (item.duration / totalTime) * 100;
				const leftPercent = (item.start / totalTime) * 100;
				
				if (item.type === 'stint') {
					el.className = 'stint-block';
					el.style.cssText = `
						left: ${leftPercent}%;
						width: ${widthPercent}%;
						background: ${item.color};
					`;
					el.innerHTML = `<span class="text-[10px] truncate px-1">${item.driverName.split(' ')[0]}</span>`;
					el.title = `${item.driverName}: ${formatTime(item.duration)}`;
				} else {
					el.style.cssText = `
						position: absolute;
						left: ${leftPercent}%;
						width: 3px;
						height: 100%;
						background: linear-gradient(0deg, #fbbf24 50%, #000 50%);
						background-size: 100% 6px;
						z-index: 20;
					`;
					el.title = `Pit Stop: ${config.minPitSec}s`;
				}
				
			});
			
			// Time markers - fix Date parsing
			const startTime = previewData.startTime instanceof Date 
				? previewData.startTime 
				: new Date(previewData.startTime);
			const endTime = new Date(startTime.getTime() + totalTime);
			
			timeStartEl.innerText = formatTimeOfDay(startTime);
			timeEndEl.innerText = formatTimeOfDay(endTime);
			
			// Stint-by-stint schedule
			scheduleEl.innerHTML = `
				<div class="mb-6">
					<h4 class="text-sm font-bold text-gray-400 mb-2 flex items-center gap-2">
						<i class="fas fa-list-ol"></i> Stint-by-Stint Schedule
					</h4>
					<div class="space-y-1">
						${actualStints.map((stint) => {
							const pitAfter = timeline.find(t => t.type === 'pit' && t.pitNumber === stint.stintNumber);
							const stintStart = stint.startTime instanceof Date ? stint.startTime : new Date(stint.startTime);
							const stintEnd = stint.endTime instanceof Date ? stint.endTime : new Date(stint.endTime);
							return `
								<div class="flex items-center gap-2 bg-navy-950 p-2 rounded border-l-4" style="border-color: ${stint.color}">
									<span class="text-xs text-gray-500 w-8">#${stint.stintNumber}</span>
									<span class="font-bold text-white flex-1">${stint.driverName}</span>
									<span class="text-xs text-gray-400">${formatTimeOfDay(stintStart)}</span>
									<span class="text-xs text-gray-600">‚Üí</span>
									<span class="text-xs text-gray-400">${formatTimeOfDay(stintEnd)}</span>
									<span class="text-xs text-neon font-mono w-16 text-right">${formatTime(stint.duration)}</span>
									${pitAfter ? '<span class="text-xs text-gold">üîß</span>' : '<span class="text-xs text-gray-600">üèÅ</span>'}
								</div>
							`;
						}).join('')}
					</div>
				</div>
				<div>
					<h4 class="text-sm font-bold text-gray-400 mb-2 flex items-center gap-2">
						<i class="fas fa-users"></i> Driver Summary
					</h4>
					<div class="grid grid-cols-2 gap-2">
						${previewData.driverSchedule.map((driver) => `
							<div class="bg-navy-800 p-3 rounded-lg border-l-4" style="border-color: ${driver.color}">
								<div class="font-bold text-white text-sm mb-1">${driver.name}</div>
								<div class="text-xs text-gray-400 space-y-1">
									<div class="flex justify-between">
										<span>Stints:</span>
										<span class="text-white">${driver.stints.length}</span>
									</div>
									<div class="flex justify-between">
										<span>Total:</span>
										<span class="text-ice font-mono">${formatTime(driver.totalTime)}</span>
									</div>
									<div class="flex justify-between">
										<span>Avg:</span>
										<span class="text-gray-300 font-mono">${formatTime(driver.totalTime / driver.stints.length)}</span>
									</div>
								</div>
								<div class="mt-2 text-[10px] text-gray-500">
									${driver.stints.map(s => `#${s.globalNumber}`).join(', ')}
								</div>
							</div>
						`).join('')}
					</div>
				</div>
			`;
			
			// Strategy summary
			summaryEl.innerHTML = `
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Race Duration</div>
					<div class="text-xl font-bold text-ice">${formatTime(config.raceMs)}</div>
				</div>
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Pit Stops</div>
					<div class="text-xl font-bold text-neon">${actualStops}</div>
				</div>
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Total Stints</div>
					<div class="text-xl font-bold text-gold">${actualStints.length}</div>
				</div>
				<div class="bg-navy-800 rounded p-3">
					<div class="text-xs text-gray-400 mb-1">Avg Stint</div>
					<div class="text-xl font-bold text-white">${formatTime(actualAvgStint)}</div>
				</div>
			`;
		}

		function formatTimeOfDay(date) {
			return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
		}
		
		function formatTime(ms) {
			if (!ms) return '--:--';
			const totalSec = Math.floor(ms / 1000);
			const hours = Math.floor(totalSec / 3600);
			const mins = Math.floor((totalSec % 3600) / 60);
			const secs = totalSec % 60;
			
			if (hours > 0) {
				return `${hours}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
			}
			return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
		}

		function closePreview() {
			document.getElementById('previewScreen').classList.add('hidden');
			document.getElementById('setupScreen').classList.remove('hidden');
		}

		function editStrategy() {
			closePreview();
		}
		
		// ==================== DEMO MODE ====================
		function startDemoMode() {
			liveTimingConfig.demoMode = true;
			liveTimingConfig.enabled = true;
			
			initializeDemoCompetitors();
			
			document.getElementById('liveTimingStatus').innerText = "üéÆ Demo Mode Active";
			document.getElementById('liveTimingStatus').className = "text-[10px] text-neon text-center font-bold";
		}
		
		function initializeDemoCompetitors() {
			const teamNames = [
				'Your Team', 'Racing Stars', 'Speed Demons', 'Track Masters', 
				'Nitro Force', 'Apex Racing', 'Thunder Karts', 'Pro Racers',
				'Fast Lane', 'Grid Warriors'
			];
			
			demoState.competitors = teamNames.map((name, idx) => ({
				name: name,
				position: idx + 1,
				previousPosition: idx + 1,
				laps: 0,
				lastLap: null,
				bestLap: null,
				baseLapTime: null,
				totalRaceTime: 0,
				pitStops: 0,
				inPit: false,
				isOurTeam: idx === 0
			}));
			
			demoState.competitors.sort(() => Math.random() - 0.5);
			demoState.competitors.forEach((c, i) => {
				c.position = i + 1;
				c.previousPosition = i + 1;
			});
		}
		
		function updateDemoData() {
			if (!liveTimingConfig.demoMode || !state.isRunning) return;
			
			const raceElapsed = Date.now() - state.startTime;
			
			demoState.competitors.forEach((comp, idx) => {
				if (!comp.baseLapTime) {
					comp.baseLapTime = 61000 + (idx * 400) + (Math.random() * 500);
				}
				
				const expectedLaps = Math.floor(raceElapsed / comp.baseLapTime);
				
				if (expectedLaps > comp.laps) {
					comp.laps = expectedLaps;
					comp.lastLap = comp.baseLapTime + (Math.random() - 0.5) * 1000;
					
					if (!comp.bestLap || comp.lastLap < comp.bestLap) {
						comp.bestLap = comp.lastLap;
					}
				}
				
				const pitInterval = 50 * 60 * 1000 + (idx * 2 * 60 * 1000);
				const expectedPits = Math.floor(raceElapsed / pitInterval);
				if (expectedPits > comp.pitStops) {
					comp.pitStops = expectedPits;
				}
				
				const pitTimePenalty = 120000;
				const timeSinceLastPit = raceElapsed - (comp.pitStops * pitInterval);
				comp.inPit = timeSinceLastPit >= 0 && timeSinceLastPit < pitTimePenalty && comp.pitStops > 0;
				
				let currentPitPenalty = comp.pitStops * pitTimePenalty;
				if (comp.inPit) {
					currentPitPenalty = ((comp.pitStops - 1) * pitTimePenalty) + timeSinceLastPit;
				}
				
				comp.totalRaceTime = (comp.laps * comp.baseLapTime) + currentPitPenalty;
			});
			
			demoState.competitors.sort((a, b) => {
				if (b.laps !== a.laps) return b.laps - a.laps;
				return a.totalRaceTime - b.totalRaceTime;
			});
			
			const leader = demoState.competitors[0];
			demoState.competitors.forEach((c, i) => {
				c.previousPosition = c.position;
				c.position = i + 1;
				
				if (i === 0) {
					c.gapToLeader = 0;
				} else {
					c.gapToLeader = c.totalRaceTime - leader.totalRaceTime;
				}
			});
			
			// Update liveData with our team
			const ourTeam = demoState.competitors.find(c => c.isOurTeam);
			if (ourTeam) {
				liveData.previousPosition = liveData.position;
				liveData.position = ourTeam.position;
				liveData.lastLap = ourTeam.lastLap;
				liveData.bestLap = ourTeam.bestLap;
				liveData.laps = ourTeam.laps;
				liveData.gapToLeader = ourTeam.gapToLeader;
			}
			
			liveData.competitors = demoState.competitors;
			updateLiveTimingUI();
		}
		
		function formatLapTime(ms) {
			if (!ms) return '--';
			const totalSec = ms / 1000;
			const min = Math.floor(totalSec / 60);
			const sec = (totalSec % 60).toFixed(3);
			return `${min}:${sec.padStart(6, '0')}`;
		}
		
        function updateLiveTimingUI() {
			if (!liveTimingConfig.enabled) return;
			
			const panel = document.getElementById('liveTimingPanel');
			const indicator = document.getElementById('liveIndicator');
			if (panel) panel.classList.remove('hidden');
			if (indicator) indicator.classList.remove('hidden');
			
			const posEl = document.getElementById('livePosition');
			if (posEl) posEl.innerText = liveData.position || '-';
			
			const changeEl = document.getElementById('livePositionChange');
			if (changeEl && liveData.previousPosition && liveData.position) {
				const diff = liveData.previousPosition - liveData.position;
				if (diff > 0) {
					changeEl.innerText = `‚ñ≤ ${diff}`;
					changeEl.className = 'text-[10px] position-up';
				} else if (diff < 0) {
					changeEl.innerText = `‚ñº ${Math.abs(diff)}`;
					changeEl.className = 'text-[10px] position-down';
				} else {
					changeEl.innerText = '‚Äî';
					changeEl.className = 'text-[10px] position-same';
				}
			}
			
			const lastLapEl = document.getElementById('liveLastLap');
			if (lastLapEl && liveData.lastLap) lastLapEl.innerText = formatLapTime(liveData.lastLap);
			
			const bestLapEl = document.getElementById('liveBestLap');
			if (bestLapEl && liveData.bestLap) bestLapEl.innerText = formatLapTime(liveData.bestLap);
			
			updateCompetitorsTable();
		}
		
		function updateCompetitorsTable() {
			const tableEl = document.getElementById('competitorsTable');
			if (!tableEl) return;
			
			if (!liveData.competitors || liveData.competitors.length === 0) {
				tableEl.innerHTML = `<div class="text-gray-500 text-center py-2">${t('waitingData')}</div>`;
				return;
			}
			
			// Find our team for gap calculations
			const ourTeam = liveData.competitors.find(c => c.isOurTeam);
			
			let html = '';
			liveData.competitors.slice(0, 10).forEach((comp, idx) => {
				const isUs = comp.isOurTeam;
				const isDanger = !isUs && liveData.position && Math.abs(comp.position - liveData.position) <= 2;
				
				let posClass = 'text-gray-400';
				if (comp.position === 1) posClass = 'text-gold';
				else if (comp.position === 2) posClass = 'text-silver';
				else if (comp.position === 3) posClass = 'text-bronze';
				
				let rowClass = 'competitor-row py-1 px-2 rounded flex justify-between items-center mb-1';
				if (isUs) rowClass += ' our-team';
				else if (isDanger) rowClass += ' danger-zone';
				
				const pitIndicator = comp.inPit ? '<span class="text-fuel animate-pulse">üîß</span>' : '';
				
				// Calculate gap display
				let gapDisplay = '';
				if (comp.position === 1) {
					gapDisplay = '<span class="text-gold">Leader</span>';
				} else if (comp.gapToLeader) {
					// If gap is more than a lap worth (~65 sec), show laps + seconds
					if (ourTeam && !isUs) {
						const gapToUs = comp.totalRaceTime - ourTeam.totalRaceTime;
						if (Math.abs(gapToUs) < 120000) {
							const gapSec = (gapToUs / 1000).toFixed(1);
							gapDisplay = gapToUs > 0 
								? `<span class="text-green-400">+${gapSec}s</span>` 
								: `<span class="text-red-400">${gapSec}s</span>`;
						} else {
							const lapDiff = ourTeam.laps - comp.laps;
							if (lapDiff !== 0) {
								gapDisplay = lapDiff > 0 
									? `<span class="text-green-400">+${lapDiff} lap${lapDiff > 1 ? 's' : ''}</span>`
									: `<span class="text-red-400">${lapDiff} lap${Math.abs(lapDiff) > 1 ? 's' : ''}</span>`;
							}
						}
					} else if (!isUs) {
						const gapSec = (comp.gapToLeader / 1000).toFixed(1);
						gapDisplay = `<span class="text-gray-500">+${gapSec}s</span>`;
					}
				}
				
				// Last lap time
				const lastLapDisplay = comp.lastLap ? `<span class="text-gray-400">${formatLapTime(comp.lastLap)}</span>` : '';
				
				html += `
					<div class="${rowClass}">
						<div class="flex items-center gap-2">
							<span class="${posClass} font-bold w-5">${comp.position}</span>
							<span class="text-white text-[11px]">${comp.name}</span>
							${pitIndicator}
						</div>
						<div class="flex items-center gap-2 text-[10px]">
							${lastLapDisplay}
							<span class="w-16 text-right">${gapDisplay}</span>
						</div>
					</div>
				`;
			});
			
			tableEl.innerHTML = html;

			// ‚úÖ ◊í◊ú◊ï◊ú ◊ú◊ß◊ë◊ï◊¶◊î ◊©◊ú◊†◊ï
			if (liveData.competitors.some(c => c.isOurTeam)) {
				setTimeout(scrollToOurTeam, 500);
			}
		}

		function scrollToOurTeam() {
			const rows = document.querySelectorAll('.competitor-row');
			let ourRow = null;
			
			rows.forEach(row => {
				if (row.classList.contains('our-team')) {
					ourRow = row;
				}
			});
			
			if (ourRow) {
				ourRow.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'nearest'
				});
				
				ourRow.classList.add('flash-alert');
				setTimeout(() => {
					ourRow.classList.remove('flash-alert');
				}, 2000);
				
				console.log('‚úÖ Auto-scrolled to our team');
			}
		}
		
		function startLiveTimingUpdates() {
			if (liveTimingConfig.demoMode) {
				liveTimingInterval = setInterval(updateDemoData, 1000);
			} else if (liveTimingConfig.url) {
				startProxyLiveTiming();
			}
		}
		
		function stopLiveTiming() {
			// ◊¢◊¶◊ï◊® scraper
			if (liveTimingManager) {
				console.log('[Strateger] Stopping live timing scraper');
				liveTimingManager.stop();
				liveTimingManager = null;
			}
			
			// ◊†◊ß◊î ◊†◊™◊ï◊†◊ô◊ù
			liveData.position = null;
			liveData.lastLap = null;
			liveData.bestLap = null;
			liveData.laps = 0;
			liveData.gapToLeader = 0;
			liveData.competitors = [];
			liveData.previousPosition = null;
			
			// ‚úÖ ◊î◊°◊™◊® ◊§◊ê◊†◊ú
			const panel = document.getElementById('liveTimingPanel');
			if (panel) {
				panel.classList.add('hidden');
			}
			
			// ‚úÖ ◊î◊°◊™◊® live indicator
			const liveIndicator = document.getElementById('liveIndicator');
			if (liveIndicator) {
				liveIndicator.classList.add('hidden');
			}
			
			// ◊†◊ß◊î UI
			updateLiveTimingUI();
			updateCompetitorsTable();
			updateProxyStatus("‚èπÔ∏è " + t('stopped'));
			
			// ◊ê◊§◊° config
			liveTimingConfig.enabled = false;
			
			console.log('‚úÖ Live Timing fully stopped');
		}
		
		/**
		 * ◊ß◊ë◊ú◊™ ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊©◊ú ◊î-scraper
		 * ◊©◊ô◊û◊ï◊©◊ô ◊ú◊ì◊ô◊ë◊ï◊í
		 */
		function getLiveTimingStats() {
			if (liveTimingManager) {
				const stats = liveTimingManager.getStats();
				console.log('[Strateger] Live timing stats:', stats);
				return stats;
			}
			return null;
		}

		
		function stopLiveTimingUpdates() {
			if (liveTimingInterval) {
				clearInterval(liveTimingInterval);
				liveTimingInterval = null;
			}
			stopProxyLiveTiming();
		}

		// ==================== STRATEGY PERSISTENCE ====================
		async function saveStrategy() {
			if (!previewData || !config) {
				alert('Generate a preview first!');
				return;
			}
			
			const name = prompt('Strategy name:', `${formatTime(config.raceMs)} - ${drivers.length} drivers`);
			if (!name) return;
			
			try {
				const response = await fetch('/.netlify/functions/save-strategy', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						name,
						config,
						drivers: drivers.map(d => ({ name: d.name, squad: d.squad, color: d.color })),
						timeline: previewData.timeline,
						driverSchedule: previewData.driverSchedule
					})
				});
				
				const result = await response.json();
				if (result.success) {
					alert(`‚úÖ Strategy saved: ${result.name}`);
				} else {
					alert(`‚ùå Error: ${result.error}`);
				}
			} catch (e) {
				alert(`‚ùå Failed to save: ${e.message}`);
			}
		}

		async function loadStrategyLibrary() {
			try {
				const response = await fetch('/.netlify/functions/get-strategies');
				const result = await response.json();
				
				if (!result.success) {
					alert('Failed to load strategies');
					return;
				}
				
				showStrategyModal(result.strategies);
			} catch (e) {
				alert(`Error: ${e.message}`);
			}
		}

		async function loadStrategy(id) {
			try {
				const response = await fetch(`/.netlify/functions/load-strategy?id=${id}`);
				const result = await response.json();
				
				if (!result.success) {
					alert('Failed to load strategy');
					return;
				}
				
				const s = result.strategy;
				config = s.config;
				drivers = s.drivers.map(d => ({ ...d, totalMs: 0, stints: 0, logs: [] }));
				previewData = { timeline: s.timeline, driverSchedule: s.driverSchedule, startTime: new Date() };
				
				document.getElementById('strategyModal').classList.add('hidden');
				document.getElementById('setupScreen').classList.add('hidden');
				document.getElementById('previewScreen').classList.remove('hidden');
				
				// Set start time to now
				const now = new Date();
				document.getElementById('raceStartTime').value = 
					`${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
				
				renderPreview();
			} catch (e) {
				alert(`Error: ${e.message}`);
			}
		}
		
		// ==================== RACE STATE PERSISTENCE ====================
		function saveRaceState() {
			if (role !== 'host' || !state.isRunning) return;
			
			const raceState = {
				config,
				state,
				drivers,
				liveTimingConfig,
				myId,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem(RACE_STATE_KEY, JSON.stringify(raceState));
			} catch (e) {
				console.error("Failed to save race state:", e);
			}
		}

		async function saveRaceToDatabase() {
			if (role !== 'host') return;
			
			console.log('üíæ Saving race to Neon DB...');
			
			try {
				// ◊î◊õ◊ü ◊†◊™◊ï◊†◊ô◊ù
				const raceData = {
					raceDuration: config.raceMs,
					totalStints: state.pitCount + 1,
					totalPitStops: state.pitCount,
					drivers: drivers.map(d => ({
						name: d.name,
						totalTime: d.totalMs,
						stints: d.stints,
						avgStint: d.totalMs / d.stints,
						squad: d.squad
					})),
					strategyData: {
						targetStintMs: config.maxStintMs,
						actualAvgStint: drivers.reduce((sum, d) => sum + (d.totalMs / d.stints), 0) / drivers.length,
						fuelTracking: config.trackFuel,
						squadsUsed: config.useSquads
					},
					config: {
						raceMs: config.raceMs,
						reqStops: config.reqStops,
						minStintMs: config.minStintMs,
						maxStintMs: config.maxStintMs,
						minDriverMs: config.minDriverMs,
						maxDriverMs: config.maxDriverMs,
						useSquads: config.useSquads,
						trackFuel: config.trackFuel
					}
				};
				
				// ◊©◊ú◊ó ◊ú-Netlify Function
				const response = await fetch('/.netlify/functions/save-race', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify(raceData)
				});
				
				const result = await response.json();
				
				if (result.success) {
					console.log('‚úÖ Race saved! ID:', result.raceId);
					alert(`üèÅ Race Finished!\n‚úÖ Strategy saved to database (ID: ${result.raceId})`);
				} else {
					console.error('‚ùå Failed to save:', result.error);
				}
				
			} catch (error) {
				console.error('‚ùå Error saving to Neon:', error);
			}
		}

		function checkForSavedRace() {
			try {
				const saved = localStorage.getItem(RACE_STATE_KEY);
				if (!saved) return;
				
				const raceState = JSON.parse(saved);
				
				if (Date.now() - raceState.timestamp > 24 * 60 * 60 * 1000) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				if (!raceState.state || !raceState.state.isRunning) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				const elapsed = Date.now() - raceState.timestamp;
				const raceElapsedTotal = raceState.timestamp - raceState.state.startTime;
				const raceRemaining = raceState.config.raceMs - raceElapsedTotal - elapsed;
				
				if (raceRemaining <= 0) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				window.savedRaceData = { raceState, elapsed };
				
				document.getElementById('savedRaceDriver').innerText = raceState.drivers[raceState.state.currentDriverIdx].name;
				document.getElementById('savedRaceTime').innerText = fmtHMS(raceRemaining);
				document.getElementById('savedRacePits').innerHTML = `<span class="text-neon">${raceState.state.pitCount}</span> / <span>${raceState.config.reqStops}</span>`;
				document.getElementById('savedRaceModal').classList.remove('hidden');
				
			} catch (e) {
				console.error("Failed to check saved race:", e);
				localStorage.removeItem(RACE_STATE_KEY);
			}
		}

		function restoreRaceState(raceState, elapsed) {
			config = raceState.config;
			state = raceState.state;
			drivers = raceState.drivers;
			liveTimingConfig = raceState.liveTimingConfig || {};
			
			if (!state.isInPit) {
				state.stintOffset += elapsed;
			}
			
			role = 'host';
			selectRole('host');
			
			const checkPeer = setInterval(() => {
				if (peer && peer.open) {
					clearInterval(checkPeer);
					startHostUI();
					startLiveTimingUpdates();
				}
			}, 100);
		}

		function continueRace() {
			if (!window.savedRaceData) return;
			const { raceState, elapsed } = window.savedRaceData;
			document.getElementById('savedRaceModal').classList.add('hidden');
			restoreRaceState(raceState, elapsed);
			delete window.savedRaceData;
		}

		function confirmDiscardRace() {
			document.getElementById('confirmDiscardModal').classList.remove('hidden');
		}

		function cancelDiscard() {
			document.getElementById('confirmDiscardModal').classList.add('hidden');
		}

		function finalDiscardRace() {
			localStorage.removeItem(RACE_STATE_KEY);
			document.getElementById('savedRaceModal').classList.add('hidden');
			document.getElementById('confirmDiscardModal').classList.add('hidden');
			delete window.savedRaceData;
			console.log('Race discarded - ready for new race');
		}

        // ==================== AUDIO ====================
        function beep(freq = 800, type = 'sine', dur = 0.2) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.value = 0.3;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                o.stop(ctx.currentTime + dur);
            } catch (e) {}
        }

        function keepScreenAwake() {
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => {});
            }
        }

        // ==================== FORMAT HELPERS ====================
        function fmtHMS(ms) {
            const s = Math.floor(ms / 1000);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            return h > 0 
                ? `${h}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`
                : `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        }
		
		function copyCode(elementId) {
			const code = document.getElementById(elementId).innerText;
			if (!code || code === '---') return;
			navigator.clipboard.writeText(code);
		}
		
		function copyHostCode() {
			copyCode('dashboardHostId');
		}

        // ==================== STATE PERSISTENCE ====================
		const SESSION_KEY = 'strateger_session';
		const HOST_ID_KEY = 'strateger_host_id';
		
		function saveHostState() {
			if (role !== 'host') return;
			
			const inputs = document.querySelectorAll('.driver-input');
			const radios = document.querySelectorAll('.starter-radio');
			const squads = document.querySelectorAll('.squad-toggle');
			
			let starterIdx = 0;
			radios.forEach((r, i) => { if (r.checked) starterIdx = i; });
			
			const driversData = Array.from(inputs).map((input, i) => ({
				name: input.value,
				isStarter: i === starterIdx,
				squad: squads[i]?.checked ? 'B' : 'A'
			}));
			
			const cfg = {
				raceDuration: document.getElementById('raceDuration').value,
				reqPitStops: document.getElementById('reqPitStops').value,
				minStint: document.getElementById('minStint').value,
				maxStint: document.getElementById('maxStint').value,
				minDriverTime: document.getElementById('minDriverTime').value,
				maxDriverTime: document.getElementById('maxDriverTime').value,
				minPitTime: document.getElementById('minPitTime').value,
				releaseBuffer: document.getElementById('releaseBuffer').value,
				allowDouble: document.getElementById('allowDouble').checked,
				trackFuel: document.getElementById('trackFuel').checked,
				maxFuelTime: document.getElementById('maxFuelTime').value,
				useSquads: document.getElementById('useSquads').checked,
				liveTimingUrl: document.getElementById('liveTimingUrl').value,
				searchType: document.querySelector('input[name="searchType"]:checked')?.value || 'team',
				searchValue: document.getElementById('searchValue')?.value || '',
				drivers: driversData,
				simResult: document.getElementById('simResult').innerText,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem('strateger_host_config', JSON.stringify(cfg));
			} catch (e) {
				console.error("Failed to save config:", e);
			}
		}
		
		function restoreHostState() {
			try {
				const saved = localStorage.getItem('strateger_host_config');
				if (!saved) return;
				
				const cfg = JSON.parse(saved);
				
				// Only restore if less than 24 hours old
				if (Date.now() - cfg.timestamp > 24 * 60 * 60 * 1000) {
					localStorage.removeItem('strateger_host_config');
					return;
				}
				
				// Restore values
				if (cfg.raceDuration) document.getElementById('raceDuration').value = cfg.raceDuration;
				if (cfg.reqPitStops) document.getElementById('reqPitStops').value = cfg.reqPitStops;
				if (cfg.minStint) document.getElementById('minStint').value = cfg.minStint;
				if (cfg.maxStint) document.getElementById('maxStint').value = cfg.maxStint;
				if (cfg.minDriverTime) document.getElementById('minDriverTime').value = cfg.minDriverTime;
				if (cfg.maxDriverTime) document.getElementById('maxDriverTime').value = cfg.maxDriverTime;
				if (cfg.minPitTime) document.getElementById('minPitTime').value = cfg.minPitTime;
				if (cfg.releaseBuffer) document.getElementById('releaseBuffer').value = cfg.releaseBuffer;
				document.getElementById('allowDouble').checked = cfg.allowDouble || false;
				document.getElementById('trackFuel').checked = cfg.trackFuel || false;
				if (cfg.maxFuelTime) document.getElementById('maxFuelTime').value = cfg.maxFuelTime;
				document.getElementById('useSquads').checked = cfg.useSquads || false;
				document.getElementById('liveTimingUrl').value = cfg.liveTimingUrl || '';
				document.getElementById('searchValue').value = cfg.searchValue || '';
				
				if (cfg.searchType) {
					const radio = document.querySelector(`input[name="searchType"][value="${cfg.searchType}"]`);
					if (radio) radio.checked = true;
				}
				
				// Restore drivers
				const list = document.getElementById('driversList');
				list.innerHTML = '';
				
				if (cfg.drivers && cfg.drivers.length > 0) {
					cfg.drivers.forEach((driver) => {
						createDriverInput(driver.name, driver.isStarter, driver.squad);
					});
				} else {
					generateDrivers();
				}
				
				toggleFuelInput();
				toggleSquadsInput();
				updateSearchPlaceholder();
				
				if (cfg.simResult) {
					document.getElementById('simResult').innerText = cfg.simResult;
				}
				
				runSim();
			
			// Add event listeners to auto-recalculate on changes
			attachConfigListeners();
			} catch (e) {
				console.error("Failed to restore config:", e);
			}
		}
		
		function attachConfigListeners() {
			// Attach listeners to all config inputs
			const configInputs = [
				'raceDuration', 'reqPitStops', 'minStint', 'maxStint',
				'minDriverTime', 'maxDriverTime', 'minPitTime', 'releaseBuffer',
				'maxFuelTime', 'allowDouble', 'trackFuel', 'useSquads'
			];
			
			configInputs.forEach(id => {
				const el = document.getElementById(id);
				if (el && !el.dataset.listenerAttached) {
					el.addEventListener('change', () => runSim());
					el.dataset.listenerAttached = 'true';
				}
			});
			
			// Weather condition radios
			document.querySelectorAll('input[name="weatherCondition"]').forEach(radio => {
				if (!radio.dataset.listenerAttached) {
					radio.addEventListener('change', () => runSim());
					radio.dataset.listenerAttached = 'true';
				}
			});
			
			// Starter driver radios
			document.querySelectorAll('.starter-radio').forEach(radio => {
				if (!radio.dataset.listenerAttached) {
					radio.addEventListener('change', () => runSim());
					radio.dataset.listenerAttached = 'true';
				}
			});
			
			// Squad toggles
			document.querySelectorAll('.squad-toggle').forEach(toggle => {
				if (!toggle.dataset.listenerAttached) {
					toggle.addEventListener('change', () => runSim());
					toggle.dataset.listenerAttached = 'true';
				}
			});
			
			console.log('‚úÖ Config change listeners attached');
		}

        // ==================== HOST PEER ====================
        function initHostPeer() {
            const statusText = document.getElementById('netStatusText');
            const retryBtn = document.getElementById('retryBtn');
            
            statusText.innerText = t('connecting');
            statusText.className = "text-[10px] text-yellow-500 mt-2";
            retryBtn.classList.add('hidden');
            
            try {
                myId = String(Math.floor(1000000 + Math.random() * 9000000));
                
                if (peer) {
                    peer.destroy();
					peer = null;
                }
                
                console.log("Creating peer with ID:", myId);
                peer = new Peer(myId, peerConfig);
                
                peer.on('open', (id) => {
					console.log("Peer connected with ID:", id);
					document.getElementById('myHostId').innerText = id;
					statusText.innerText = "‚úÖ " + t('connected');
					statusText.className = "text-[10px] text-green-500 font-bold mt-2";
					connectionRetries = 0;
					
					// Show load strategy button for host
					document.getElementById('loadStrategyBtn').classList.remove('hidden');
				});
                
                peer.on('connection', (c) => {
                    console.log("New client connected:", c.peer);
                    connections.push(c);
                    updateClientCount();
                    
                    c.on('open', () => {
						console.log("Connection opened with:", c.peer);
						if (state.isRunning) {
							c.send({ type: 'INIT', config, state, drivers, liveData, liveTimingConfig });
						}
					});
                    
                    c.on('data', (d) => {
                        if (d === 'REQUEST_INIT' && state.isRunning) {
                            c.send({ type: 'INIT', config, state, drivers, liveData, liveTimingConfig });
                        }
                    });
                    
                    c.on('close', () => {
                        connections = connections.filter(x => x !== c);
                        updateClientCount();
                    });
                });
                
                peer.on('error', (err) => {
                    console.error("Peer error:", err);
                    statusText.innerText = `‚ùå ${t('error')} ${err.type}`;
                    statusText.className = "text-[10px] text-red-500 mt-2";
                    retryBtn.classList.remove('hidden');
                });
                
                peer.on('disconnected', () => {
                    if (connectionRetries < MAX_RETRIES) {
                        connectionRetries++;
                        setTimeout(() => peer.reconnect(), 2000);
                    }
                });
            } catch (e) {
                statusText.innerText = `‚ùå ${t('error')} ${e.message}`;
                retryBtn.classList.remove('hidden');
            }
        }
        
        function updateClientCount() {
			const count = connections.filter(c => c.open).length;
			const syncText = document.getElementById('syncText');
			if (syncText) {
				const viewerText = {
					en: count > 1 ? 'viewers' : 'viewer',
					he: count > 1 ? '◊¶◊ï◊§◊ô◊ù' : '◊¶◊ï◊§◊î',
					fr: count > 1 ? 'spectateurs' : 'spectateur',
					pt: count > 1 ? 'espectadores' : 'espectador'
				};
				syncText.innerText = count > 0 ? `${count} ${viewerText[currentLang] || viewerText.en}` : t('synced');
			}
		}

        // ==================== CLIENT PEER ====================
		function initClientPeer() {
			return new Promise((resolve, reject) => {
				if (peer && !peer.destroyed) {
					if (peer.open) {
						resolve(peer.id);
						return;
					}
					peer.destroy();
				}
				
				const clientId = 'viewer_' + Math.random().toString(36).substr(2, 9);
				peer = new Peer(clientId, peerConfig);
				
				peer.on('open', (id) => {
					console.log("Client peer ready:", id);
					resolve(id);
				});
				
				peer.on('error', (err) => {
					console.error("Client peer error:", err);
					const msg = document.getElementById('clientConnMsg');
					if (msg) {
						msg.innerText = `${t('error')} ${err.type}`;
						msg.className = "text-xs text-red-500 mt-2";
					}
				});
				
				peer.on('disconnected', () => {
					if (peer && !peer.destroyed) {
						peer.reconnect();
					}
				});
			});
		}
		
		function disconnectClient() {
			if (conn) {
				conn.close();
				conn = null;
			}
			
			const msg = document.getElementById('clientConnMsg');
			msg.innerText = t('disconnected');
			msg.className = "text-xs text-gray-500 mt-2";
			
			document.getElementById('disconnectBtn').classList.add('hidden');
			
			const dashboardVisible = !document.getElementById('raceDashboard').classList.contains('hidden');
			if (dashboardVisible) {
				document.getElementById('raceDashboard').classList.add('hidden');
				document.getElementById('setupScreen').classList.remove('hidden');
			}
		}

        function connectToHost() {
			const hostId = document.getElementById('remoteIdInput').value.trim();
			if (!hostId) return;
			
			const msg = document.getElementById('clientConnMsg');
			msg.innerText = t('connecting');
			msg.className = "text-xs text-yellow-500 mt-2";
			
			if (conn) {
				conn.close();
				conn = null;
			}
			
			if (!peer || peer.destroyed) {
				initClientPeer().then(() => {
					doConnect(hostId, msg);
				});
				return;
			}
			
			if (peer.disconnected) {
				peer.reconnect();
				peer.once('open', () => {
					doConnect(hostId, msg);
				});
				return;
			}
			
			doConnect(hostId, msg);
		}

		function doConnect(hostId, msg) {
			console.log("Connecting to host:", hostId);
			
			conn = peer.connect(hostId, { reliable: true });
			
			if (!conn) {
				msg.innerText = `${t('error')} Connection failed`;
				msg.className = "text-xs text-red-500 mt-2";
				return;
			}
			
			conn.on('open', () => {
				console.log("Connected to host:", hostId);
				msg.innerText = t('waitingRace');
				msg.className = "text-xs text-green-500 mt-2";
				document.getElementById('disconnectBtn').classList.remove('hidden');
				conn.send('REQUEST_INIT');
			});

			conn.on('data', (d) => {
				console.log("Received data:", d.type);
				
				if (d.type === 'INIT' || d.type === 'UPDATE') { 
					if (d.config) config = d.config; 
					if (d.drivers) drivers = d.drivers; 
					if (d.state) state = d.state;
					if (d.liveTimingConfig) liveTimingConfig = d.liveTimingConfig;
					if (d.liveData) liveData = d.liveData;
					if (d.calculatedTimes) syncedTimes = d.calculatedTimes;
					
					const dashboardHidden = document.getElementById('raceDashboard').classList.contains('hidden');
					
					if (state && state.isRunning && dashboardHidden) {
						startClientUI();
					} else if (state && state.isRunning && !dashboardHidden) {
						renderFrame(); 
						updateStats(syncedTimes ? syncedTimes.stintElapsed : 0); 
						if (liveData) updateLiveTimingUI();
					} else if (!state || !state.isRunning) {
						msg.innerText = t('waitingRace');
						msg.className = "text-xs text-yellow-500 mt-2";
					}
				}
			});
			
			conn.on('close', () => {
				console.log("Disconnected from host");
				msg.innerText = t('disconnected');
				msg.className = "text-xs text-red-500 mt-2";
				
				document.getElementById('disconnectBtn').classList.add('hidden');
				
				const dashboardVisible = !document.getElementById('raceDashboard').classList.contains('hidden');
				if (dashboardVisible) {
					document.getElementById('raceDashboard').classList.add('hidden');
					document.getElementById('setupScreen').classList.remove('hidden');
				}
				
				conn = null;
			});
			
			conn.on('error', (err) => {
				console.error("Connection error:", err);
				msg.innerText = `${t('error')} ${err.type || err}`;
				msg.className = "text-xs text-red-500 mt-2";
			});
		}

        // ==================== BROADCAST ====================
        function broadcast() {
			if (role !== 'host' || !peer || connections.length === 0) return;
			const now = Date.now();
			
			// Calculate total pit time
			let totalPitTime = 0;
			drivers.forEach(d => {
				d.logs.forEach(log => {
					if (log.pit) totalPitTime += log.pit;
				});
			});
			
			// Add current pit time if in pit
			if (state.isInPit) {
				totalPitTime += (now - state.pitStart);
			}
			
			const msg = {
				config: config,
				drivers: drivers,
				state: state,
				liveTimingConfig: liveTimingConfig,
				syncedTimes: {
					raceElapsed: now - state.startTime,
					stintElapsed: state.isInPit ? 0 : (now - state.stintStart + state.stintOffset),
					pitElapsed: state.isInPit ? (now - state.pitStart) : 0,
					totalPitTime: totalPitTime,
					timestamp: now
				}
			};
			connections.forEach(c => {
				if (c.open) c.send(msg);
			});
			updateClientCount();
		}

        // ==================== UI TOGGLES ====================
        function toggleFuelInput() { 
            document.getElementById('fuelInputDiv').classList.toggle('hidden', !document.getElementById('trackFuel').checked); 
        }
        
        function toggleSquadsInput() { 
            document.querySelectorAll('.squad-toggle-container').forEach(el => 
                el.classList.toggle('hidden', !document.getElementById('useSquads').checked)
            ); 
        }

        // ==================== DRIVER MANAGEMENT ====================
        function generateDrivers() {
			const list = document.getElementById('driversList'); 
			list.innerHTML = '';
			["Driver 1", "Driver 2", "Driver 3", "Driver 4"].forEach((n, i) => createDriverInput(n, i === 0, i < 2 ? 'A' : 'B'));
			toggleSquadsInput();
		}
        
        function createDriverInput(val, checked, squad) {
			const div = document.createElement('div');
			div.className = "flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700";
			const radioId = 'starter_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
			
			// ‚úÖ ◊ô◊¶◊ô◊®◊™ ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊ô◊©◊ô◊®◊ï◊™
			const label = document.createElement('label');
			label.className = "flex items-center cursor-pointer";
			
			const radio = document.createElement('input');
			radio.type = 'radio';
			radio.name = 'starter';
			radio.id = radioId;
			radio.className = 'starter-radio sr-only';
			radio.checked = checked;
			
			const indicator = document.createElement('div');
			indicator.className = checked 
				? 'starter-indicator w-8 h-8 rounded-full border-2 border-ice bg-ice/30 shadow-[0_0_8px_rgba(34,211,238,0.5)] flex items-center justify-center text-sm'
				: 'starter-indicator w-8 h-8 rounded-full border-2 border-gray-500 flex items-center justify-center text-sm hover:border-ice transition';
			indicator.textContent = 'üèÅ';
			
			// ‚úÖ Event handler ◊ê◊û◊ô◊™◊ô ◊¢◊ù stopPropagation
			label.addEventListener('click', function(e) {
				e.stopPropagation();
				e.preventDefault();          // ‚úÖ ◊ó◊ì◊©
				e.stopImmediatePropagation(); // ‚úÖ ◊ó◊ì◊©
				
				radio.checked = true;
				updateStarterVisuals(e);
			}, true);  // ‚úÖ capture phase
			
			label.appendChild(radio);
			label.appendChild(indicator);
			
			// Driver input
			const driverInput = document.createElement('input');
			driverInput.type = 'text';
			driverInput.value = val;
			driverInput.className = 'driver-input bg-transparent text-white w-full outline-none font-bold';
			
			// Squad toggle
			const squadLabel = document.createElement('label');
			squadLabel.className = 'squad-toggle-container flex items-center cursor-pointer ml-auto bg-navy-800 rounded px-2 py-1 border border-gray-600 hidden';
			squadLabel.innerHTML = `
				<span class="text-[10px] mr-1 text-gray-400">${t('squads')}</span>
				<input type="checkbox" class="squad-toggle hidden" ${squad === 'B' ? 'checked' : ''} onchange="this.nextElementSibling.innerText = this.checked ? 'B' : 'A'; this.nextElementSibling.className = this.checked ? 'w-6 h-4 rounded bg-squadB text-[8px] flex items-center justify-center font-bold text-white' : 'w-6 h-4 rounded bg-squadA text-[8px] flex items-center justify-center font-bold text-white'">
				<div class="w-6 h-4 rounded ${squad === 'B' ? 'bg-squadB' : 'bg-squadA'} text-[8px] flex items-center justify-center font-bold text-white">${squad}</div>
			`;
			
			div.appendChild(label);
			div.appendChild(driverInput);
			div.appendChild(squadLabel);
			document.getElementById('driversList').appendChild(div);
		}
		
		function updateStarterVisuals(event) {
			if (event) {
				event.stopPropagation();
				event.preventDefault();
			}
			
			// ◊©◊û◊ï◊® scroll position
			const scrollPos = window.scrollY || document.documentElement.scrollTop;
			const configPanel = document.getElementById('configPanel');
			const panelScrollPos = configPanel ? configPanel.scrollTop : 0;
			
			// ◊¢◊ì◊õ◊ü ◊ê◊ô◊†◊ì◊ô◊ß◊ò◊ï◊®◊ô◊ù
			document.querySelectorAll('.starter-indicator').forEach(ind => {
				const radio = ind.previousElementSibling;
				if (radio && radio.checked) {
					ind.className = 'starter-indicator w-8 h-8 rounded-full border-2 border-ice bg-ice/30 shadow-[0_0_8px_rgba(34,211,238,0.5)] flex items-center justify-center text-sm';
				} else {
					ind.className = 'starter-indicator w-8 h-8 rounded-full border-2 border-gray-500 flex items-center justify-center text-sm hover:border-ice transition';
				}
			});
			
			// ◊î◊ó◊ñ◊® scroll position
			window.scrollTo(0, scrollPos);
			if (configPanel) {
				configPanel.scrollTop = panelScrollPos;
			}
		}

		function addDriverField() { 
			createDriverInput(`Driver ${document.getElementById('driversList').children.length + 1}`, false, 'A'); 
			toggleSquadsInput();
		}

		function removeDriverField() { 
			const l = document.getElementById('driversList'); 
			if (l.children.length > 2) {
				l.removeChild(l.lastChild);
			}
		}

        // ==================== RACE INITIALIZATION ====================
        function initRace() {
            if (role === 'client') return;
            
            const inputs = document.querySelectorAll('.driver-input');
            const radios = document.querySelectorAll('.starter-radio');
            const squads = document.querySelectorAll('.squad-toggle');
            let startIdx = 0; 
            radios.forEach((r, i) => { if (r.checked) startIdx = i; });
            
            if (inputs.length < 2) return alert("Minimum 2 drivers required");
            
			config = {
                raceMs: parseFloat(document.getElementById('raceDuration').value) * 3600000,
                reqStops: parseInt(document.getElementById('reqPitStops').value) || 0,
                minPitSec: parseInt(document.getElementById('minPitTime').value) || 0,
                releaseBufferSec: parseInt(document.getElementById('releaseBuffer').value) || 0,
                minStintMs: parseFloat(document.getElementById('minStint').value) * 60000,
                maxStintMs: parseFloat(document.getElementById('maxStint').value) * 60000,
                minDriverMs: parseFloat(document.getElementById('minDriverTime').value) * 60000,
                maxDriverMs: parseFloat(document.getElementById('maxDriverTime').value) * 60000,
                allowDouble: document.getElementById('allowDouble').checked,
                trackFuel: document.getElementById('trackFuel').checked,
                maxFuelMs: parseFloat(document.getElementById('maxFuelTime').value) * 60000,
                useSquads: document.getElementById('useSquads').checked
            };
            
            liveTimingConfig.url = document.getElementById('liveTimingUrl').value;
            updateSearchConfig();
            
            drivers = Array.from(inputs).map((d, i) => ({ 
                name: d.value, 
                totalMs: 0, 
                stints: 0, 
                squad: squads[i].checked ? 'B' : 'A', 
                logs: [], 
                isExpanded: false 
            }));
            
            state = { 
				isRunning: true, 
				startTime: Date.now(), 
				stintStart: Date.now(), 
				fuelStart: Date.now(), 
				currentDriverIdx: startIdx, 
				pitCount: 0, 
				isInPit: false, 
				mode: 'normal', 
				trackCondition: 'dry',
				stintOffset: 0, 
				activeSquad: 'A', 
				nextDriverIdx: (startIdx + 1) % drivers.length, 
				targetStintMs: config.raceMs / (config.reqStops + 1), 
				squadsActive: false,
				pendingPitEntry: false,
				globalStintNumber: 1
			};

			// Use generated strategy if available
			if (window.generatedStrategy && window.generatedStrategy.stints) {
				state.targetStintMs = window.generatedStrategy.avgStintMs || state.targetStintMs;
				state.plannedStrategy = window.generatedStrategy;
				
				// Find the starter driver index
				const starterIdx = drivers.findIndex(d => d.name === window.generatedStrategy.starterDriver);
				if (starterIdx >= 0) {
					state.currentDriverIdx = starterIdx;
					state.nextDriverIdx = (starterIdx + 1) % drivers.length;
				}
				
				console.log('Using generated strategy:', window.generatedStrategy);
				console.log(`Starting with driver: ${drivers[state.currentDriverIdx].name}`);
				
				// If strategy includes double stints, note them
				if (window.generatedStrategy.doubleStints && window.generatedStrategy.doubleStints.length > 0) {
					state.plannedDoubles = window.generatedStrategy.doubleStints;
				}
			}

			recalculateTargetStint();
			setTimeout(() => {
				broadcast();
			}, 100);
			saveHostState();
            broadcast(); 
            startHostUI();
            startLiveTimingUpdates();
        }

        // ==================== TICK ====================
        function tick() { 
            if (!state.isRunning) return;
            renderFrame();
			
			if (liveTimingConfig.demoMode) {
				updateDemoData();
			}
        }

        // ==================== RENDERING ====================
        function renderFrame() {
			try {
				const now = Date.now();
				
				let raceRemaining, stintTime;
				
				if (role === 'host') {
					raceRemaining = config.raceMs - (now - state.startTime);
					stintTime = state.isInPit ? 0 : (now - state.stintStart + state.stintOffset);
				} else if (syncedTimes) {
					// Viewer mode - more precise calculation
					const timeSinceLastSync = now - syncedTimes.timestamp;
					
					// Race time includes all time that passed
					raceRemaining = config.raceMs - (syncedTimes.raceElapsed + timeSinceLastSync);
					
					// Stint time - only if not in pit
					if (!state.isInPit) {
						stintTime = syncedTimes.stintElapsed + timeSinceLastSync;
					} else {
						stintTime = 0;
					}
				} else {
					raceRemaining = config.raceMs - (now - state.startTime);
					stintTime = state.isInPit ? 0 : (now - state.stintStart + state.stintOffset);
				}

				// Update viewer pit indicator
				if (role === 'client') {
					const viewerPitIndicator = document.getElementById('viewerPitIndicator');
					const viewerPitTimer = document.getElementById('viewerPitTimer');
					const viewerNextDriver = document.getElementById('viewerNextDriver');
					
					if (state.isInPit) {
						viewerPitIndicator.classList.remove('hidden');
						const pitElapsed = syncedTimes ? (now - (syncedTimes.timestamp - syncedTimes.pitElapsed)) : 0;
						viewerPitTimer.innerText = Math.floor(pitElapsed / 1000) + 's';
						viewerNextDriver.innerText = drivers[state.nextDriverIdx]?.name || '---';
					} else {
						viewerPitIndicator.classList.add('hidden');
					}
				}
				
				if (raceRemaining <= 0) { 
					document.getElementById('raceTimerDisplay').innerText = "Finish"; 
					stopLiveTimingUpdates();
					
					// ‚úÖ ◊©◊û◊ï◊® ◊ú-DB (◊®◊ß ◊§◊¢◊ù ◊ê◊ó◊™)
					if (role === 'host' && !state.raceSaved) {
						state.raceSaved = true;
						saveRaceToDatabase();
					}
					
					return; 
				}
				document.getElementById('raceTimerDisplay').innerText = fmtHMS(raceRemaining);

				if (!state.isInPit && !state.pendingPitEntry) {
					document.getElementById('stintTimerDisplay').innerText = fmtHMS(Math.max(0, stintTime));
					document.getElementById('stintProgressBar').style.width = Math.min(100, (stintTime / config.maxStintMs) * 100) + '%';
					updateStrategy(stintTime);
				}

                document.getElementById('currentDriverName').innerText = drivers[state.currentDriverIdx].name;
                document.getElementById('nextDriverName').innerText = drivers[state.nextDriverIdx].name;
                document.getElementById('modalNextDriverName').innerText = drivers[state.nextDriverIdx].name;
                document.getElementById('pitCountDisplay').innerText = `${state.pitCount} / ${config.reqStops}`;
                
                if (config.useSquads) {
					document.getElementById('btnNight').classList.remove('hidden');
					
					const nightBtn = document.getElementById('btnNight');
					if (state.squadsActive) {
						// Night mode active - Squad A starts, Squad B finishes
						document.getElementById('activeSquadDisplay').classList.remove('hidden');
						document.getElementById('sleepWidget').classList.remove('hidden');
						
						const activeSquadText = document.getElementById('activeSquadText');
						const sleepersLabel = document.getElementById('sleepWidget').querySelector('p:first-child');
						
						activeSquadText.innerText = state.activeSquad;
						activeSquadText.className = state.activeSquad === 'A' 
							? 'text-lg font-bold text-squadA ml-2' 
							: 'text-lg font-bold text-squadB ml-2';
						
						const sleepers = drivers.filter(d => d.squad !== state.activeSquad);
						document.getElementById('sleepersList').innerText = sleepers.map(d => d.name).join(', ') || "---";
						
						// Show info about squad rotation
						if (sleepersLabel) {
							const restingText = { en: 'Resting', he: '◊†◊ó◊ô◊ù', fr: 'Au repos', pt: 'Descansando' };
							const nextText = { en: '(up next)', he: '(◊î◊ë◊ê◊ô◊ù)', fr: '(suivants)', pt: '(pr√≥ximos)' };
							sleepersLabel.innerHTML = `${restingText[currentLang] || restingText.en} <span class="text-gray-500">${state.activeSquad === 'A' ? nextText[currentLang] || nextText.en : ''}</span>:`;
						}
						nightBtn.className = "btn-press bg-cyan-900 border-2 border-cyan-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(6,182,212,0.5)]";
						nightBtn.innerHTML = `<span class="block text-lg">üåô ${t('nightActive')}</span>`;
					} else {
						// Night mode not active - everyone is awake
						document.getElementById('activeSquadDisplay').classList.add('hidden');
						document.getElementById('sleepWidget').classList.add('hidden');
						
						nightBtn.className = "btn-press bg-navy-800 border border-cyan-500/50 rounded-lg p-2 group hover:bg-navy-700 text-cyan-300";
						nightBtn.innerHTML = `<span class="block text-lg">üåô ${t('night')}</span>`;
					}
				} else {
					document.getElementById('btnNight').classList.add('hidden');
					document.getElementById('activeSquadDisplay').classList.add('hidden');
					document.getElementById('sleepWidget').classList.add('hidden');
				}
				
				// Push/Problem button styling
				const btnPush = document.getElementById('btnPush');
				const btnBad = document.getElementById('btnBad');

				if (btnPush) {
					if (state.mode === 'push') {
						btnPush.className = "btn-press bg-green-900 border-2 border-green-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(34,197,94,0.5)]";
						btnPush.innerHTML = `<span class="block text-lg">üî• ${t('pushActive')}</span>`;
					} else {
						btnPush.className = "btn-press bg-navy-800 border border-green-900/50 rounded-lg p-2 group hover:bg-navy-700";
						btnPush.innerHTML = `<span class="block text-lg">üî• ${t('push')}</span>`;
					}
				}

				if (btnBad) {
					if (state.mode === 'bad') {
						btnBad.className = "btn-press bg-red-900 border-2 border-red-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(239,68,68,0.5)]";
						btnBad.innerHTML = `<span class="block text-lg">üê¢ ${t('problemActive')}</span>`;
					} else {
						btnBad.className = "btn-press bg-navy-800 border border-red-900/50 rounded-lg p-2 group hover:bg-navy-700";
						btnBad.innerHTML = `<span class="block text-lg">üê¢ ${t('problem')}</span>`;
					}
				}

				// Weather display
				const rIcon = document.getElementById('rainIcon');
				const rText = document.getElementById('rainText');
				const stratBox = document.getElementById('strategyBox');

				stratBox.className = "p-3 text-center border-b-2 flex flex-col items-center justify-center rounded-lg shadow-lg shrink-0 transition-colors duration-500";

				if (state.trackCondition === 'wet') {
					rIcon.innerHTML = "‚òÅÔ∏è";  // ◊¢◊†◊ü ◊ë◊ú◊ë◊ì
					rIcon.className = "text-lg text-ice";
					rText.innerText = t('wet');
					rText.className = "text-xs font-bold text-ice";
					stratBox.classList.add("bg-blue-900/90", "border-ice");
				} else if (state.trackCondition === 'drying') {
					rIcon.innerHTML = "üå§Ô∏è";  // ◊©◊û◊© ◊¢◊ù ◊¢◊†◊ü
					rIcon.className = "text-lg";
					rText.innerText = t('drying');
					rText.className = "text-xs font-bold text-yellow-400";
					stratBox.classList.add("bg-yellow-900/50", "border-yellow-500");
				} else {
					rIcon.innerHTML = "‚òÄÔ∏è";
					rIcon.className = "text-lg";
					rText.innerText = t('dry');
					rText.className = "text-xs font-bold text-yellow-400";
					stratBox.classList.add("bg-navy-900", "border-neon");
				}

                // Sync status
                if (role === 'host') {
                    const syncDot = document.getElementById('syncDot');
                    const syncText = document.getElementById('syncText');
                    const activeConns = connections.filter(c => c.open).length;
                    
                    if (activeConns > 0) {
                        syncDot.className = "sync-dot bg-green-500 mr-1";
                        syncText.innerText = `${activeConns} viewer${activeConns > 1 ? 's' : ''}`;
                    } else {
                        syncDot.className = "sync-dot bg-yellow-500 mr-1";
                        syncText.innerText = t('synced');
                    }
                }
				// Update current stint time in logs
				if (!state.isInPit) {
					const stintEl = document.getElementById(`currentStintTime_${state.currentDriverIdx}`);
					if (stintEl) {
						stintEl.innerText = fmtHMS(Math.max(0, stintTime));
					}
				}
            } catch (e) { 
                console.error("Render Error", e); 
            }
        }

		function checkTimerSync() {
			if (role !== 'host') return;
			
			const now = Date.now();
			const raceElapsed = now - state.startTime;
			
			// Calculate total stint time (driving time)
			let totalStintTime = 0;
			drivers.forEach(d => {
				totalStintTime += d.totalMs;
			});
			
			// Add current stint if driving
			if (!state.isInPit) {
				const currentStintTime = now - state.stintStart + state.stintOffset;
				totalStintTime += currentStintTime;
			}
			
			// Calculate total pit time
			let totalPitTime = 0;
			drivers.forEach(d => {
				d.logs.forEach(log => {
					if (log.pit) totalPitTime += log.pit;
				});
			});
			
			// Add current pit time if in pit
			if (state.isInPit) {
				totalPitTime += (now - state.pitStart);
			}
			
			// Total accounted time should equal race elapsed
			const totalAccountedTime = totalStintTime + totalPitTime;
			const diff = Math.abs(raceElapsed - totalAccountedTime);
			const diffSeconds = (diff / 1000).toFixed(1);
			
			console.log('‚è±Ô∏è Timer Sync Check:');
			console.log(`  Race Elapsed: ${fmtHMS(raceElapsed)}`);
			console.log(`  Driving Time: ${fmtHMS(totalStintTime)}`);
			console.log(`  Pit Time: ${fmtHMS(totalPitTime)}`);
			console.log(`  Total Accounted: ${fmtHMS(totalAccountedTime)}`);
			console.log(`  Difference: ${diffSeconds}s`);
			
			if (diff > 5000) {
				console.warn(`‚ö†Ô∏è Timer sync issue! ${diffSeconds}s difference`);
				return { synced: false, difference: diff };
			} else {
				console.log('‚úÖ Timers synced!');
				return { synced: true, difference: diff };
			}
		}

		// ◊ë◊ì◊ô◊ß◊î ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊õ◊ú 30 ◊©◊†◊ô◊ï◊™
		if (typeof window !== 'undefined' && !window.timerSyncInterval) {
			window.timerSyncInterval = setInterval(() => {
				if (role === 'host' && state.isRunning) {
					checkTimerSync();
				}
			}, 30000);
		}

        function updateStrategy(sTime) {
			if (state.mode === 'normal') {
				recalculateTargetStint();
			}
			
			document.getElementById('strategyTargetStint').innerText = fmtHMS(state.targetStintMs);

			const diff = state.targetStintMs - sTime;
			const dEl = document.getElementById('strategyDelta');
			dEl.innerText = diff > 0 ? `-${Math.ceil(diff / 60000)}m` : `+${Math.floor(Math.abs(diff) / 60000)}m`;
			dEl.className = diff > 0 ? "text-lg font-bold text-gray-400" : "text-lg font-bold text-neon";
			
			const advice = document.getElementById('strategyAdvice');
			const timeToMax = config.maxStintMs - sTime;
			
			if (timeToMax < 0) { 
				advice.innerText = t('timeExceeded');
				advice.className = "text-xs text-red-500 animate-pulse font-bold"; 
			} 
			else if (state.mode === 'bad') {
				advice.innerText = t('problemQuick');
				advice.className = "text-xs text-red-400 font-bold";
			}
			else if (state.mode === 'push') {
				if (timeToMax < 120000) {
					advice.innerText = t('nearLimit');
					advice.className = "text-xs text-yellow-400 font-bold";
				} else {
					advice.innerText = t('pushExtend');
					advice.className = "text-xs text-green-400 font-bold";
				}
			}
			else if (diff < 300000 && diff > -300000) {
				advice.innerText = t('targetWindow');
				advice.className = "text-xs text-ice font-bold";
			} else if (diff > 0) {
				advice.innerText = t('buildTime');
				advice.className = "text-xs text-gray-400";
			} else {
				advice.innerText = t('overExtend');
				advice.className = "text-xs text-yellow-400 font-bold";
			}
		}

        function updateStats(stintMs) {
			const tb = document.getElementById('statsTable'); 
			tb.innerHTML = '';
			
			drivers.forEach((d, i) => {
				let tot = d.totalMs; 
				if (i === state.currentDriverIdx && !state.isInPit) tot += stintMs;
				
				let rowClass = "border-b border-gray-700";
				if (i === state.currentDriverIdx && !state.isInPit) {
					rowClass = "bg-white/10 font-bold text-white border-b border-gray-600";
				}
				
				let timeClass = "text-gray-300"; 
				let symbol = "";
				if (config.minDriverMs > 0 && tot < config.minDriverMs) { 
					timeClass = "text-yellow-500 font-bold"; 
					symbol = "‚ö†Ô∏è"; 
				} else if (config.maxDriverMs > 0 && tot > config.maxDriverMs) { 
					timeClass = "text-red-500 font-bold animate-pulse"; 
					symbol = "üõë"; 
				} else if (config.minDriverMs > 0) { 
					timeClass = "text-green-500 font-bold"; 
					symbol = "‚úÖ"; 
				}

				const mainRow = document.createElement('tr');
				mainRow.className = rowClass;
				mainRow.innerHTML = `
					<td class="text-center cursor-pointer p-2 hover:text-ice" onclick="toggleLog(${i})">${d.isExpanded ? '‚ñ≤' : '‚ñº'}</td>
					<td class="py-2 pr-2">${d.name} ${symbol}</td>
					<td class="py-2 text-center">${d.stints}${i === state.currentDriverIdx && !state.isInPit ? '+1' : ''}</td>
					<td class="py-2 ${timeClass}">${fmtHMS(tot)}</td>
				`;
				tb.appendChild(mainRow);

				let logContent = '';
				
				// Show past stints
				d.logs.forEach((l, idx) => {
					logContent += `
						<div class="flex justify-between items-center text-[10px] py-1 border-b border-gray-800">
							<span class="text-gray-500">#${l.globalStintNum || idx + 1}</span>
							<span class="text-ice">${fmtHMS(l.drive)}</span>
							<span class="text-fuel">${l.pit ? fmtHMS(l.pit) : '--'}</span>
						</div>
					`;
				});
				
				// Show current running stint for active driver
				if (i === state.currentDriverIdx && !state.isInPit && stintMs > 0) {
					logContent += `
						<div class="flex justify-between items-center text-[10px] py-1 border-b border-gray-800 bg-ice/10">
							<span class="text-ice font-bold">#${state.globalStintNumber} üèéÔ∏è</span>
							<span id="currentStintTime_${i}" class="text-ice font-bold">${fmtHMS(stintMs)}</span>
							<span class="text-gray-500">--</span>
						</div>
					`;
				}

				const logRow = document.createElement('tr');
				logRow.className = d.isExpanded ? '' : 'hidden';
				logRow.innerHTML = `
					<td colspan="4" class="bg-navy-950 p-2">
						<div class="flex justify-between text-[10px] text-gray-500 border-b border-gray-700 pb-1 mb-1">
							<span>Stint</span>
							<span>Drive</span>
							<span>Pit</span>
						</div>
						${logContent || '<div class="text-gray-600 text-[10px]">No stints yet</div>'}
					</td>
				`;
				tb.appendChild(logRow);
			});
		}

        // ==================== PIT STOP ====================
        function confirmPitEntry() {
			const now = Date.now();
			const sTime = (now - state.stintStart) + state.stintOffset;
			
			if (state.mode !== 'bad' && sTime < config.minStintMs) {
				if (!confirm(t('confirmEarlyPit'))) return;
			}

			state.isInPit = true;
			state.pendingPitEntry = false;
			state.pitStart = Date.now();
			
			const driveTime = (now - state.stintStart) + state.stintOffset;
			drivers[state.currentDriverIdx].totalMs += driveTime;
			drivers[state.currentDriverIdx].stints++;
			drivers[state.currentDriverIdx].logs.push({ 
				drive: driveTime, 
				pit: null,
				globalStintNum: state.globalStintNumber
			});
			state.globalStintNumber++;

			state.stintOffset = 0;
			if (state.squadsActive && drivers[state.nextDriverIdx].squad !== state.activeSquad) {
				state.activeSquad = drivers[state.nextDriverIdx].squad;
			}
			broadcast();

			document.getElementById('pitModal').classList.remove('hidden');
			document.getElementById('pitPhase2').classList.remove('hidden');
			document.getElementById('modalNextDriverName').innerText = drivers[state.nextDriverIdx].name;

			if (config.trackFuel) document.getElementById('fuelToggleContainer').classList.remove('hidden');
			else document.getElementById('fuelToggleContainer').classList.add('hidden');

			const notifyBtn = document.getElementById('notifyBtn');
			const notifiedMsg = document.getElementById('notifiedMsg');
			const confirmBtn = document.getElementById('confirmExitBtn');
			
			notifyBtn.classList.add('hidden');
			notifiedMsg.classList.add('hidden');
			confirmBtn.disabled = true;
			confirmBtn.innerText = t('wait');
			confirmBtn.className = "w-full bg-gray-800 text-gray-600 font-bold py-4 rounded-lg text-xl border border-gray-700 mb-4";
			
			let notified = false;
			let canExit = false;
			const releaseBuffer = config.releaseBufferSec || 0;

			notifyBtn.onclick = () => {
				notified = true;
				notifyBtn.classList.add('hidden');
				notifiedMsg.classList.remove('hidden');
				beep(800, 'sine', 0.3);
				setTimeout(() => beep(1000, 'sine', 0.2), 150);
			};

			confirmBtn.onclick = () => {
				if (!canExit) return;
				
				clearInterval(pitInterval);
				
				const pitTime = Date.now() - state.pitStart;
				const lastLog = drivers[state.currentDriverIdx].logs[drivers[state.currentDriverIdx].logs.length - 1];
				if (lastLog) lastLog.pit = pitTime;

				state.pitCount++; 
				state.currentDriverIdx = state.nextDriverIdx; 
				
				let nextCand = (state.currentDriverIdx + 1) % drivers.length;
				if (state.squadsActive) {
					let found = drivers.findIndex((d, i) => i !== state.currentDriverIdx && d.squad === state.activeSquad);
					if (found !== -1) nextCand = found;
				}
				state.nextDriverIdx = nextCand;

				state.stintStart = Date.now(); 
				state.isInPit = false; 
				state.mode = 'normal';
				
				const isRefuel = document.getElementById('isRefuelCheck')?.checked ?? true;
				if (!config.trackFuel || isRefuel) state.fuelStart = Date.now();

				document.getElementById('pitModal').classList.add('hidden');
				document.getElementById('pitPhase2').classList.add('hidden');
				document.getElementById('btnResetMode').classList.add('hidden');
				saveRaceState();
				broadcast();
			};

			if (pitInterval) clearInterval(pitInterval);
			
			pitInterval = setInterval(() => {
				const elapsed = (Date.now() - state.pitStart) / 1000;
				const remaining = config.minPitSec - elapsed;
				const timeToNotify = remaining - releaseBuffer;
				
				if (remaining > 0) {
					document.getElementById('pitTimerDisplay').innerText = Math.ceil(remaining);
					document.getElementById('pitTimerDisplay').className = "text-5xl font-bold big-digit text-red-500 font-mono";
				} else {
					document.getElementById('pitTimerDisplay').innerText = "0";
					document.getElementById('pitTimerDisplay').className = "text-5xl font-bold big-digit text-green-500 font-mono";
				}
				
				if (releaseBuffer > 0 && timeToNotify <= 0 && !notified && remaining > 0) {
					notifyBtn.classList.remove('hidden');
					notifyBtn.innerHTML = `üì¢ ${t('notifyDriver')} (${Math.ceil(remaining)}s)`;
					beep(600, 'sine', 0.2);
				}
				
				if (!notified && remaining > 0 && timeToNotify <= 0) {
					notifyBtn.innerHTML = `üì¢ ${t('notifyDriver')} (${Math.ceil(remaining)}s)`;
				}
				
				if (remaining <= 0 && !canExit) {
					canExit = true;
					notifyBtn.classList.add('hidden');
					confirmBtn.disabled = false;
					confirmBtn.innerText = t('confirmExit');
					confirmBtn.className = "w-full bg-green-500 text-black font-bold py-6 rounded-lg text-2xl shadow-[0_0_20px_#22c55e]";
					beep(800, 'square', 0.5);
				}
				
				updateStats(0);
			}, 100);
		}

        function closePitMenu() { 
            state.pendingPitEntry = false;
            document.getElementById('pitModal').classList.add('hidden'); 
        }
        
        function cancelPitStop() {
            clearInterval(pitInterval);
            
            const lastLog = drivers[state.currentDriverIdx].logs.pop();
            if (lastLog) {
                drivers[state.currentDriverIdx].totalMs -= lastLog.drive;
                drivers[state.currentDriverIdx].stints--;
                state.stintOffset = lastLog.drive;
                state.stintStart = Date.now() - state.stintOffset;
                state.stintOffset = 0;
            }
            
            state.isInPit = false;
            state.pendingPitEntry = false;
            
            document.getElementById('pitModal').classList.add('hidden');
            broadcast();
        }

        // ==================== CONTROLS ====================
		function copyHostCode() {
			const code = document.getElementById('dashboardHostId').innerText;
			if (!code || code === '---') return;
			
			navigator.clipboard.writeText(code).then(() => {
				const el = document.getElementById('dashboardHostId');
				el.classList.add('text-white');
				setTimeout(() => el.classList.remove('text-white'), 1000);
			});
		}
		
        function adjustStint(ms) { 
            state.stintOffset += ms; 
            broadcast(); 
            renderFrame(); 
        }
		
		function cycleNextDriver() {
			if (role !== 'host') return;
			
			// Find eligible drivers (not current driver, and if squads active - same squad)
			let eligible = [];
			drivers.forEach((d, i) => {
				if (i === state.currentDriverIdx) return; // Skip current driver
				if (state.squadsActive && d.squad !== state.activeSquad) return; // Skip other squad if night mode
				eligible.push(i);
			});
			
			if (eligible.length === 0) return;
			
			// Find current position in eligible list and move to next
			const currentPos = eligible.indexOf(state.nextDriverIdx);
			const nextPos = (currentPos + 1) % eligible.length;
			state.nextDriverIdx = eligible[nextPos];
			
			broadcast();
			renderFrame();
		}
        
        function toggleNightMode() { 
            if (role === 'host') { 
                state.squadsActive = !state.squadsActive; 
                broadcast(); 
                renderFrame(); 
				updateControlGrid();
            } 
        }
        
        function toggleRain() {
			if (role === 'host') {
				if (!state.trackCondition || state.trackCondition === 'dry') {
					state.trackCondition = 'wet';
				} else if (state.trackCondition === 'wet') {
					state.trackCondition = 'drying';
				} else {
					state.trackCondition = 'dry';
				}
				
				broadcast();
				renderFrame();
			}
		}
		
		function updateControlGrid() {
			const grid = document.getElementById('controlButtonsGrid');
			if (grid) {
				if (state.squadsActive) {
					grid.classList.remove('no-night');
				} else {
					grid.classList.add('no-night');
				}
			}
		}
        
        function setMode(m) { 
			state.mode = m; 
			document.getElementById('btnResetMode').classList.toggle('hidden', m === 'normal'); 
			
			// Smart recalculation based on mode
			if (m === 'bad') {
				// Problem mode - suggest minimum stint for quick pit
				state.targetStintMs = config.minStintMs + 30000; // min + 30 seconds buffer
				beep(400, 'sine', 0.3); // Alert sound
			} else {
				recalculateTargetStint();
			}
			
			broadcast(); 
			renderFrame();
		}

		function recalculateTargetStint() {
			const now = Date.now();
			const raceElapsed = now - state.startTime;
			const raceRemaining = config.raceMs - raceElapsed;
			const stopsRemaining = Math.max(0, config.reqStops - state.pitCount);
			
			// Estimate remaining pit time
			const remainingPitTimeMs = stopsRemaining * config.minPitSec * 1000;
			
			// Available driving time remaining
			const drivingTimeRemaining = raceRemaining - remainingPitTimeMs;
			
			if (state.mode === 'push') {
				state.targetStintMs = config.maxStintMs - 60000; // Max - 1 minute for safety
			} else if (state.mode === 'bad') {
				state.targetStintMs = config.minStintMs;
			} else {
				if (stopsRemaining > 0) {
					// Divide remaining driving time by remaining stints
					state.targetStintMs = Math.floor(drivingTimeRemaining / (stopsRemaining + 1));
				} else {
					state.targetStintMs = drivingTimeRemaining;
				}
				// Clamp to valid range
				state.targetStintMs = Math.min(state.targetStintMs, config.maxStintMs - 60000);
				state.targetStintMs = Math.max(state.targetStintMs, config.minStintMs);
			}
		}
        
        function toggleLog(idx) { 
            drivers[idx].isExpanded = !drivers[idx].isExpanded; 
            updateStats(state.isInPit ? 0 : (Date.now() - state.stintStart + state.stintOffset)); 
        }

        // ==================== UI INITIALIZATION ====================
        function startHostUI() { 
			document.getElementById('setupScreen').classList.add('hidden'); 
			document.getElementById('raceDashboard').classList.remove('hidden'); 
			document.getElementById('syncControls').classList.remove('hidden');
			document.getElementById('hostCodeDisplay').classList.remove('hidden');
			document.getElementById('dashboardHostId').innerText = myId || '---';
			document.getElementById('zoneForbidden').style.width = ((config.minStintMs / config.maxStintMs) * 100) + '%'; 
			
			if (liveTimingConfig.enabled) {
				document.getElementById('liveTimingPanel').classList.remove('hidden');
				document.getElementById('liveIndicator').classList.remove('hidden');
			}

			// Auto-save race state every 5 seconds
			if (!window.raceSaveInterval) {
				window.raceSaveInterval = setInterval(() => {
					if (role === 'host' && state.isRunning) {
						saveRaceState();
					}
				}, 5000);
			}

			keepScreenAwake();
			
			raceInterval = setInterval(() => { 
				tick(); 
				broadcast(); 
			}, 1000); 
			
			tick(); 
			updateStats(0);
			applyViewerMode();
		}
        
        function startClientUI() {
			if (!config || !drivers || !state) {
				console.error("Missing data for client UI", { config, drivers, state });
				return;
			}
			
			if (!state.isRunning) {
				console.log("Race not started yet");
				return;
			}
			
			document.getElementById('setupScreen').classList.add('hidden');
			document.getElementById('raceDashboard').classList.remove('hidden');
			document.getElementById('zoneForbidden').style.width = ((config.minStintMs / config.maxStintMs) * 100) + '%';
			
			if (liveTimingConfig && liveTimingConfig.enabled) {
				document.getElementById('liveTimingPanel').classList.remove('hidden');
				document.getElementById('liveIndicator').classList.remove('hidden');
			}
			
			keepScreenAwake();
			
			// ‚úÖ ◊î◊ï◊°◊£ auto-update ◊úviewer
			if (!window.viewerInterval) {
				window.viewerInterval = setInterval(() => {
					if (role === 'client') {
						renderFrame();
					}
				}, 1000);
			}
			
			renderFrame();
			updateStats(syncedTimes ? syncedTimes.stintElapsed : 0);
		}

    </script>
	<!-- Hide preview when dashboard is active -->
	<script>
	(function() {
		const dashboard = document.getElementById('raceDashboard');
		const preview = document.getElementById('previewScreen');
		
		if (dashboard && preview) {
			const observer = new MutationObserver(() => {
				if (!dashboard.classList.contains('hidden')) {
					preview.classList.add('hidden');
				}
			});
			observer.observe(dashboard, { attributes: true, attributeFilter: ['class'] });
		}
	})();
	</script>
</body>
</html>