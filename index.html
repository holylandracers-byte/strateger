<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Strateger - Race Strategy Manager</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2322d3ee' width='100' height='100' rx='15'/><text x='50' y='70' text-anchor='middle' font-size='60' fill='black' font-weight='bold'>S</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
	<style>
		/* Fallback icons if Font Awesome blocked */
		.fa-server:before { content: "ğŸ–¥ï¸"; }
		.fa-mobile-screen:before { content: "ğŸ“±"; }
		.fa-cloud-rain:before { content: "ğŸŒ§ï¸"; }
		.fa-cloud-showers-heavy:before { content: "ğŸŒ§ï¸"; }
	</style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
	<script src="/js/racefacer-scraper.js"></script>
	<script src="/js/live-timing-manager.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        navy: { 950: '#020617', 900: '#0f172a', 800: '#1e293b', 700: '#334155' },
                        ice: '#22d3ee',
                        neon: '#a3e635',
                        danger: '#ef4444',
                        fuel: '#f97316',
                        squadA: '#3b82f6',
                        squadB: '#06b6d4',
                        live: '#ef4444',
                        gold: '#fbbf24',
                        silver: '#9ca3af',
                        bronze: '#f97316'
                    },
                    animation: { 
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'flash': 'flash 0.5s ease-in-out'
                    }
                }
            }
        }
    </script>
    <style>
	/* Tailwind Fallback for Safari/Offline */
	.hidden { display: none !important; }
	.flex { display: flex; }
	.flex-col { flex-direction: column; }
	.flex-1 { flex: 1 1 0%; }
	.items-center { align-items: center; }
	.justify-center { justify-content: center; }
	.gap-2 { gap: 0.5rem; }
	.gap-3 { gap: 0.75rem; }
	.p-2 { padding: 0.5rem; }
	.p-3 { padding: 0.75rem; }
	.p-4 { padding: 1rem; }
	.rounded { border-radius: 0.25rem; }
	.rounded-lg { border-radius: 0.5rem; }
	.text-white { color: white; }
	.text-center { text-align: center; }
	.font-bold { font-weight: 700; }
	.w-full { width: 100%; }
	.border { border-width: 1px; }
	.bg-navy-950 { background-color: #020617; }
	.bg-navy-900 { background-color: #0f172a; }
	.text-ice { color: #22d3ee; }
	.text-neon { color: #a3e635; }
	
        :root {
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);
        }
        
        html, body {
			margin: 0;
			padding: 0;
			height: 100%;
			overflow: auto;  /* âœ… */
			overscroll-behavior: none;
			-webkit-overflow-scrolling: touch;
		}

		#setupScreen {
			overflow-y: auto !important;
			-webkit-overflow-scrolling: touch;
		}
        
        body { 
            background: #020617; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding-top: var(--safe-area-top);
            padding-bottom: var(--safe-area-bottom);
        }
        
        .sync-dot { width: 8px; height: 8px; border-radius: 50%; animation: pulse 2s infinite; }
        .live-dot { background: #ef4444; box-shadow: 0 0 8px #ef4444; }
        
        .big-digit { font-variant-numeric: tabular-nums; letter-spacing: 0.05em; }
        
        .btn-press { 
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-press:active { transform: scale(0.95); }
        
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .flash-alert { animation: flash 0.3s ease-in-out 3; }
        
        /* Progress bar zones */
        .zone-forbidden { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 5px, #991b1b 5px, #991b1b 10px); opacity: 0.3; }
        .zone-optimal { background: linear-gradient(90deg, #22c55e, #a3e635); }
        
        /* RTL support */
        [dir="rtl"] .grid { direction: rtl; }
        
        /* Live Timing styles */
        .position-up { color: #22c55e; }
        .position-down { color: #ef4444; }
        .position-same { color: #9ca3af; }
        .competitor-row { transition: background-color 0.3s; }
        .competitor-row.our-team { background: rgba(34, 211, 238, 0.2); border: 1px solid #22d3ee; }
        .competitor-row.danger-zone { background: rgba(239, 68, 68, 0.15); }
        
        /* Scrollable lists */
        .overflow-y-scroll { overflow-y: scroll !important; -webkit-overflow-scrolling: touch; }
		
		/* Radio button styling */
		input[type="radio"]:checked + span { color: #22d3ee; font-weight: bold; }
		.has-\[\:checked\]\:border-ice:has(:checked) { border-color: #22d3ee; }
		.has-\[\:checked\]\:bg-ice\/20:has(:checked) { background-color: rgba(34, 211, 238, 0.2); }
		
		/* Starter radio styling */
		.starter-radio:checked + div {
			border-color: #22d3ee !important;
			background-color: rgba(34, 211, 238, 0.3);
			box-shadow: 0 0 8px rgba(34, 211, 238, 0.5);
		}
		
		/* Responsive design for laptop/desktop */
		@media (min-width: 768px) {
			#raceDashboard {
				max-width: 900px;  /* âœ… ×©×•× ×” ×-600px ×œ-900px */
				margin: 0 auto;
				border-left: 1px solid #334155;
				border-right: 1px solid #334155;
			}
			
			#setupScreen .max-w-md {
				max-width: 500px;
			}
		}

		/* Extra large screens - ×—×“×©! */
		@media (min-width: 1200px) {
			#raceDashboard {
				max-width: 1000px;
			}
		}

		/* Viewer mode - disable interactions - ×—×“×©! */
		.viewer-mode button:not(.btn-view-only),
		.viewer-mode .editable {
			opacity: 0.5 !important;
			cursor: not-allowed !important;
			pointer-events: none !important;
		}

		.viewer-mode .btn-view-only {
			cursor: default !important;
			pointer-events: auto !important;
		}

		/* ×ª×™×§×•×Ÿ header overlap ×‘××¡×›×™× ×§×˜× ×™× */
		@media (max-width: 640px) {
			header {
				padding: 0.5rem;
			}
			
			header select {
				font-size: 0.7rem;
				padding: 0.25rem 0.5rem;
			}
			
			#langSelect option {
				font-size: 0.75rem;
			}
		}
		
		@media (min-width: 1024px) {
			#raceDashboard {
				max-width: 700px;
			}
			
			.text-4xl {
				font-size: 3rem;
			}
			
			.text-2xl {
				font-size: 1.75rem;
			}
		}
    </style>
</head>
<body class="bg-navy-950 text-gray-200 min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-navy-900 border-b border-gray-800 p-2 shrink-0">
		<div class="flex flex-wrap justify-between items-center gap-2">
			<!-- Left side -->
			<div class="flex items-center gap-2 min-w-0">
				<span id="liveIndicator" class="hidden sync-dot live-dot flex-shrink-0"></span>
				<span id="headerModeText" class="text-xs text-gray-500 whitespace-nowrap">LIVE</span>
			</div>
			
			<!-- Right side -->
			<div class="flex items-center gap-2 flex-wrap">
				<select id="langSelect" onchange="setLanguage(this.value)" 
						class="text-xs bg-navy-800 px-2 py-1 rounded border border-gray-700 hover:bg-navy-700 text-white cursor-pointer">
					<option value="en">EN</option>
					<option value="he">HE</option>
					<option value="fr">FR</option>
					<option value="pt">PT</option>
				</select>
				<span id="connStatus" class="hidden flex items-center gap-1 text-xs whitespace-nowrap">
					<span class="sync-dot bg-gray-500"></span>
					<span data-i18n="offline">Offline</span>
				</span>
			</div>
		</div>
	</header>

    <!-- Setup Screen -->
    <div id="setupScreen" class="flex-1 overflow-y-auto p-4">
        <div class="max-w-md mx-auto">
            <div class="text-center mb-4">
				<h1 class="text-2xl font-bold text-white tracking-widest">STRAT<span class="text-ice">EGER</span></h1>
                <p class="text-[10px] text-gray-500 mt-1" data-i18n="subtitle">Endurance Race Strategy Manager</p>
            </div>

            <!-- Role Selection -->
            <div class="grid grid-cols-2 gap-3 mb-4">
                <button onclick="selectRole('host')" id="hostBtn" class="bg-navy-800 border-2 border-navy-700 rounded-lg p-4 text-center hover:border-ice transition group">
                    <i class="fa-solid fa-server text-3xl text-gray-400 group-hover:text-ice mb-2"></i>
                    <p class="text-sm font-bold" data-i18n="host">Host</p>
                    <p class="text-[10px] text-gray-500" data-i18n="hostDesc">Manage the race</p>
                </button>
                <button onclick="selectRole('client')" id="clientBtn" class="bg-navy-800 border-2 border-navy-700 rounded-lg p-4 text-center hover:border-neon transition group">
                    <i class="fa-solid fa-mobile-screen text-3xl text-gray-400 group-hover:text-neon mb-2"></i>
                    <p class="text-sm font-bold" data-i18n="viewer">Viewer</p>
                    <p class="text-[10px] text-gray-500" data-i18n="viewerDesc">Watch live</p>
                </button>
            </div>

            <!-- Host Section -->
            <div id="hostSection" class="hidden">
                <div class="bg-gradient-to-r from-ice/20 to-navy-800 p-3 rounded-lg border border-ice/50 mb-4">
                    <p class="text-xs text-gray-400 mb-1" data-i18n="yourCode">Your Code:</p>
                    <div class="flex items-center gap-2">
                        <span id="myHostId" class="text-2xl font-mono font-bold text-ice tracking-widest">---</span>
                        <button onclick="copyCode('myHostId')" class="text-gray-400 hover:text-white">ğŸ“‹</button>
                    </div>
                    <p id="netStatusText" class="text-[10px] text-gray-500 mt-2"></p>
                    <button id="retryBtn" class="hidden text-xs bg-red-900 text-red-300 px-3 py-1 rounded mt-2" onclick="initHostPeer()" data-i18n="retry">Retry</button>
                </div>
                
                <button onclick="toggleConfigPanel()" class="w-full bg-navy-800 text-gray-300 text-sm py-2 rounded-lg mb-3 border border-gray-700 flex items-center justify-center gap-2">
                    <span data-i18n="raceSettings">âš™ï¸ Race Settings</span>
                    <span id="configArrow">â–¼</span>
                </button>
            </div>
            
            <!-- Config Panel -->
            <div id="configPanel" class="space-y-3 hidden transition-opacity duration-300">
                
                <!-- Live Timing Section -->
                <div class="bg-gradient-to-r from-red-900/30 to-navy-800 p-3 rounded-lg border border-red-500/50">
                    <div class="flex items-center gap-2 mb-2">
                        <span class="sync-dot live-dot"></span>
                        <span class="text-sm font-bold text-white" data-i18n="liveTiming">Live Timing (Optional)</span>
                    </div>
                    <div class="space-y-2">
                        <div>
                            <label class="text-[10px] text-gray-400" data-i18n="liveTimingUrl">Live Timing URL (APEX/RaceFacer)</label>
                            <input type="url" id="liveTimingUrl" placeholder="https://live.racefacer.com/race/..." class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
                        </div>
                        
                        <div>
                            <label class="text-[10px] text-gray-400 mb-1 block" data-i18n="searchBy">Search by:</label>
                            <div class="grid grid-cols-3 gap-1 mb-2">
                                <label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
                                    <input type="radio" name="searchType" value="team" checked class="hidden">
                                    <span class="text-[10px] text-gray-300">ğŸï¸ <span data-i18n="team">Team</span></span>
                                </label>
                                <label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
                                    <input type="radio" name="searchType" value="kart" class="hidden">
                                    <span class="text-[10px] text-gray-300">ğŸ”¢ <span data-i18n="kart">Kart</span></span>
                                </label>
                                <label class="flex items-center justify-center gap-1 bg-navy-950 p-2 rounded border border-gray-600 cursor-pointer has-[:checked]:border-ice has-[:checked]:bg-ice/20">
                                    <input type="radio" name="searchType" value="driver" class="hidden">
                                    <span class="text-[10px] text-gray-300">ğŸ‘¤ <span data-i18n="driver">Driver</span></span>
                                </label>
                            </div>
                            <input type="text" id="searchValue" placeholder="Enter team name..." class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
                        </div>
                        
                        <div class="flex gap-2">
                            <button onclick="testLiveTiming()" class="flex-1 bg-red-900/50 border border-red-500/50 text-red-300 text-xs py-2 rounded hover:bg-red-900">ğŸ”´ <span data-i18n="testConnection">Test</span></button>
                            <button onclick="startDemoMode()" class="flex-1 bg-neon/20 border border-neon/50 text-neon text-xs py-2 rounded hover:bg-neon/30">ğŸ® <span data-i18n="demo">Demo</span></button>
							<button onclick="openManualInput()" class="flex-1 bg-fuel/20 border border-fuel/50 text-fuel text-xs py-2 rounded hover:bg-fuel/30">âœï¸ <span data-i18n="manual">Manual</span></button>
                        </div>
                        <div id="liveTimingStatus" class="text-[10px] text-gray-500 text-center"></div>
                    </div>
                </div>

                <div id="simResult" class="bg-navy-950 p-2 rounded text-xs text-ice border border-navy-700 font-mono text-center whitespace-pre-line">...</div>

                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="duration">Duration (hours)</label>
                        <input type="number" id="raceDuration" value="12" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="reqStops">Required Stops</label>
                        <input type="number" id="reqPitStops" value="13" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-neon font-bold text-sm">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="minStint">Min Stint (min)</label>
                        <input type="number" id="minStint" value="10" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="maxStint">Max Stint (min)</label>
                        <input type="number" id="maxStint" value="60" oninput="runSim()" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                </div>
                
                <div class="bg-navy-800 p-2 rounded border border-gray-700">
                    <p class="text-[10px] text-gray-400 text-center mb-1 font-bold" data-i18n="driverLimits">Driver Limits (0 = no limit)</p>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="text-[10px] text-gray-400" data-i18n="minDrive">Min Drive</label>
                            <input type="number" id="minDriverTime" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
                        </div>
                        <div>
                            <label class="text-[10px] text-gray-400" data-i18n="maxDrive">Max Drive</label>
                            <input type="number" id="maxDriverTime" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="pitTime">Pit Time (sec)</label>
                        <input type="number" id="minPitTime" value="120" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400" data-i18n="releaseBuffer">Release Buffer (sec)</label>
                        <input type="number" id="releaseBuffer" value="0" class="w-full bg-navy-950 border border-gray-700 rounded p-2 text-fuel text-sm">
                    </div>
                </div>
                
                <div class="grid grid-cols-3 gap-2 border-t border-gray-700 pt-2 mt-2">
					<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
						<input type="checkbox" id="allowDouble" class="w-4 h-4 accent-ice">
						<span class="text-[10px] text-gray-300" data-i18n="doubleStint">Double</span>
					</label>
					<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
						<input type="checkbox" id="trackFuel" onchange="toggleFuelInput()" class="w-4 h-4 accent-fuel">
						<span class="text-[10px] text-gray-300" data-i18n="fuel">Fuel</span>
					</label>
					<label class="flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700 cursor-pointer">
						<input type="checkbox" id="useSquads" onchange="toggleSquadsInput()" class="w-4 h-4 accent-squadB">
						<span class="text-[10px] text-gray-300" data-i18n="squads">Squads</span>
					</label>
				</div>
                
                <div id="fuelInputDiv" class="hidden">
                    <label class="text-[10px] text-fuel" data-i18n="fuelTankTime">Fuel Tank Time (min)</label>
                    <input type="number" id="maxFuelTime" value="60" class="w-full bg-navy-950 border border-fuel/50 rounded p-2 text-white text-sm">
                </div>

                <div class="pt-2">
                    <div class="flex justify-between items-center mb-1">
                        <label class="text-xs text-gray-400 font-bold" data-i18n="driversSetup">Drivers (mark starter)</label>
                        <div class="space-x-1">
                            <button onclick="addDriverField()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600">+</button>
                            <button onclick="removeDriverField()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600">-</button>
                        </div>
                    </div>
                    <div id="driversList" class="space-y-2 overflow-y-scroll transition-all duration-300" style="max-height: 208px;"></div>
                </div>

                <button id="startRaceBtn" onclick="initRace()" class="w-full bg-ice hover:bg-cyan-300 text-navy-950 font-bold py-3 rounded-lg text-lg mt-4 shadow-[0_0_15px_rgba(34,211,238,0.3)] transition btn-press" data-i18n="startRace">
                    Start Race (Host)
                </button>
            </div>

            <!-- Client Section -->
            <div id="clientSection" class="hidden">
                <div class="bg-gradient-to-r from-neon/20 to-navy-800 p-3 rounded-lg border border-neon/50">
                    <label class="text-xs text-gray-400" data-i18n="enterCode">Enter Host Code:</label>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="remoteIdInput" placeholder="1234567" class="flex-1 bg-navy-950 border border-gray-600 rounded p-2 text-white text-center text-lg font-mono tracking-widest">
                        <button onclick="connectToHost()" class="bg-neon text-navy-950 font-bold px-4 rounded hover:bg-lime-400 transition" data-i18n="connect">Connect</button>
                    </div>
					<p id="clientConnMsg" class="text-xs text-gray-500 mt-2"></p>
					<button id="disconnectBtn" onclick="disconnectClient()" class="hidden text-xs text-red-400 mt-2" data-i18n="disconnect">Disconnect</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Race Dashboard -->
    <div id="raceDashboard" class="hidden flex flex-col h-full overflow-hidden">
        <!-- Top Bar -->
        <div class="bg-navy-900 border-b border-gray-800 p-2 flex justify-between items-center shrink-0">
			<div class="flex items-center gap-2">
				<div id="hostCodeDisplay" class="hidden flex items-center gap-1 bg-navy-800 px-2 py-1 rounded border border-ice/50 cursor-pointer" onclick="copyHostCode()">
					<span class="text-[10px] text-gray-400" data-i18n="code">Code:</span>
					<span id="dashboardHostId" class="text-xs font-mono font-bold text-ice">---</span>
					<span class="text-[10px]">ğŸ“‹</span>
				</div>
				<div id="syncControls" class="hidden flex items-center gap-1">
					<span id="syncDot" class="sync-dot bg-green-500"></span>
					<span id="syncText" class="text-[10px] text-gray-400" data-i18n="synced">Synced</span>
				</div>
			</div>
            <div class="text-right">
                <p class="text-[10px] text-gray-500" data-i18n="raceTime">Race Time</p>
                <p id="raceTimerDisplay" class="text-xl font-mono font-bold text-white big-digit">00:00:00</p>
            </div>
			<div class="flex items-center gap-2">
				<p class="text-[10px] text-gray-500" data-i18n="pitStops">Pit Stops</p>
				<p id="pitCountDisplay" class="text-lg font-bold text-neon">0 / 0</p>
			</div>
			<button id="btnRain" onclick="toggleRain()" class="btn-press bg-navy-800 border border-blue-500/50 rounded-lg p-2 group hover:bg-navy-700">
				<span id="rainIcon" class="text-lg">â˜€ï¸</span>
				<span id="rainText" class="text-xs font-bold text-yellow-400" data-i18n="dry">Dry</span>
			</button>
        </div>

        <!-- Live Timing Panel (collapsible) -->
        <div id="liveTimingPanel" class="hidden bg-navy-900/80 border-b border-red-500/50 overflow-hidden transition-all duration-300 shrink-0" style="max-height: 350px;">
            <div class="p-2">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <span class="sync-dot live-dot"></span>
                        <span class="text-sm font-bold text-white">LIVE</span>
                    </div>
					<div class="flex items-center gap-1">
						<button onclick="openManualInput()" class="text-xs bg-fuel/30 border border-fuel/50 text-fuel px-2 py-1 rounded hover:bg-fuel/50" title="Manual Input">âœï¸</button>
						<button onclick="refreshLiveTiming()" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600" title="Refresh">ğŸ”„</button>
						<button onclick="toggleLiveTimingEmbed()" class="text-xs bg-red-900/50 px-2 py-1 rounded hover:bg-red-900" title="Embed">ğŸ–¥ï¸</button>
						<button onclick="stopLiveTiming()" 
								class="btn-press bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-xs">
							<i class="fas fa-stop"></i> 
							<span data-i18n="stopLiveTiming">Stop</span>
						</button>
					</div>
                </div>
                
                <!-- Quick Stats -->
                <div class="grid grid-cols-3 gap-2 mb-2">
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Pos</p>
                        <p id="livePosition" class="text-xl font-bold text-ice">-</p>
                        <p id="livePositionChange" class="text-[10px] position-same">â€”</p>
                    </div>
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Last</p>
                        <p id="liveLastLap" class="text-lg font-mono text-white">--</p>
                    </div>
                    <div class="bg-navy-950 p-2 rounded text-center border border-gray-700">
                        <p class="text-[10px] text-gray-500">Best</p>
                        <p id="liveBestLap" class="text-lg font-mono text-neon">--</p>
                    </div>
                </div>
                
                <!-- Competitors Table -->
                <div id="competitorsTable" class="bg-navy-950 rounded border border-gray-700 p-1 max-h-[180px] overflow-y-auto text-[11px]">
                    <div class="text-gray-500 text-center py-2" data-i18n="waitingData">Waiting for data...</div>
                </div>
				
				<!-- Proxy Debug Info -->
				<div id="proxyDebug" class="hidden mt-2 p-2 bg-navy-950 rounded border border-gray-700 text-[10px] text-gray-500 max-h-20 overflow-y-auto">
					<p class="font-bold text-gray-400" data-i18n="proxyData">Proxy Data:</p>
					<pre id="proxyDataPreview" class="whitespace-pre-wrap break-all"></pre>
				</div>
            </div>
        </div>
		
		<!-- Live Timing Embed (iframe) -->
		<div id="liveTimingEmbed" class="hidden bg-navy-900 border-b border-gray-700">
			<div class="flex items-center justify-between p-1 bg-navy-800">
				<span class="text-[10px] text-gray-400" data-i18n="liveView">Live View</span>
				<button onclick="closeLiveTimingEmbed()" class="text-red-400 text-xs">âœ•</button>
			</div>
			<iframe id="liveTimingIframe" class="w-full h-64 border-0" src="about:blank"></iframe>
		</div>

        <!-- Strategy Box -->
        <div id="strategyBox" class="p-3 text-center border-b-2 border-neon flex flex-col items-center justify-center rounded-lg shadow-lg shrink-0 bg-navy-900">
            <p class="text-gray-400 text-xs mb-1" data-i18n="targetStint">Target Stint</p>
            <div class="flex items-baseline gap-2">
                <span id="strategyTargetStint" class="text-2xl font-bold text-white big-digit">--:--</span>
                <span id="strategyDelta" class="text-lg font-bold text-gray-400">--</span>
            </div>
            <p id="strategyAdvice" class="text-xs text-gray-400 mt-1" data-i18n="buildTime">Build Time</p>
        </div>

        <!-- Stint Timer -->
        <div class="p-3 bg-navy-950 border-b border-gray-800 shrink-0">
			<div class="grid grid-cols-2 gap-3 mb-2">
				<div class="flex flex-col items-center">
					<p class="text-gray-500 text-xs mb-1" data-i18n="stintTime">Stint Time</p>
					<p id="stintTimerDisplay" class="text-3xl font-mono font-bold text-white big-digit">00:00</p>
				</div>
				<div class="flex flex-col items-center">
					<p class="text-gray-500 text-xs mb-1" data-i18n="currentDriver">Current Driver</p>
					<p id="currentDriverName" class="text-xl font-bold text-ice">---</p>
				</div>
			</div>
			<div class="relative h-4 bg-navy-800 rounded-full overflow-hidden">
                <div id="zoneForbidden" class="absolute top-0 left-0 h-full zone-forbidden"></div>
                <div id="stintProgressBar" class="absolute top-0 left-0 h-full zone-optimal transition-all duration-500" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Squad & Night Display -->
        <div id="activeSquadDisplay" class="hidden bg-navy-800 border-b border-gray-600 p-2 text-center shrink-0">
			<span class="text-xs text-gray-400" data-i18n="activeSquad">Active Squad:</span>
			<span id="activeSquadText" class="text-lg font-bold text-squadA ml-2">A</span>
		</div>
        
        <div id="sleepWidget" class="hidden bg-navy-800 border-b border-gray-700 p-2 text-center shrink-0">
            <p class="text-[10px] text-gray-500" data-i18n="resting">Resting:</p>
            <p id="sleepersList" class="text-xs text-gray-400">---</p>
        </div>

        <!-- Control Buttons -->
        <div class="grid grid-cols-3 gap-2 p-2 bg-navy-900 border-b border-gray-800 shrink-0">
			<button id="btnPush" onclick="setMode('push')" data-viewer-disabled="true" class="btn-press bg-navy-800 border border-green-900/50 rounded-lg p-2 group hover:bg-navy-700">
				<span class="block text-lg">ğŸ”¥ <span data-i18n="push">Push</span></span>
			</button>
            <button id="btnBad" onclick="setMode('bad')" data-viewer-disabled="true" class="btn-press bg-navy-800 border border-red-900/50 rounded-lg p-2 group hover:bg-navy-700">
				<span class="block text-lg">ğŸ¢ <span data-i18n="problem">Problem</span></span>
			</button>
			<button id="btnNight" onclick="toggleNightMode()" data-viewer-disabled="true" class="hidden btn-press bg-navy-800 border border-purple-500/50 rounded-lg p-2 group hover:bg-navy-700 text-purple-300">
                <span class="block text-lg">ğŸŒ™ <span data-i18n="night">Night</span></span>
            </button>
			<button id="btnResetMode" onclick="setMode('normal')" data-viewer-disabled="true" class="hidden btn-press bg-navy-800 border border-gray-600 rounded-lg p-2 col-span-3">
                <span class="text-sm text-gray-400" data-i18n="resetMode">â†©ï¸ Reset Mode</span>
            </button>
        </div>

        <!-- Driver Stats -->
        <div class="flex-1 overflow-y-auto bg-navy-950 p-2">
            <table class="w-full text-sm">
                <thead class="text-gray-500 text-xs sticky top-0 bg-navy-950">
                    <tr>
                        <th class="p-1 w-8"></th>
                        <th class="text-right p-1" data-i18n="driverHeader">Driver</th>
                        <th class="text-center p-1" data-i18n="stintsHeader">St.</th>
                        <th class="text-left p-1" data-i18n="totalHeader">Total</th>
                    </tr>
                </thead>
                <tbody id="statsTable"></tbody>
            </table>
        </div>

        <!-- Pit Button & Next Driver -->
        <div class="bg-navy-900 border-t border-gray-800 p-2 shrink-0 space-y-2">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-2">
					<div>
						<p class="text-[10px] text-gray-500" data-i18n="nextDriver">Next Driver</p>
						<p id="nextDriverName" class="text-lg font-bold text-neon cursor-pointer hover:text-white" onclick="cycleNextDriver()" data-viewer-disabled="true">---</p>
					</div>
					<button onclick="cycleNextDriver()" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded hover:bg-navy-600" title="Change next driver">ğŸ”„</button>
                </div>
                <div class="flex gap-2">
                    <button onclick="adjustStint(-60000)" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded">-1m</button>
					<button onclick="adjustStint(60000)" data-viewer-disabled="true" class="text-xs bg-navy-700 px-2 py-1 rounded">+1m</button>
                </div>
            </div>
            <button id="pitEntryBtn" onclick="confirmPitEntry()" data-viewer-disabled="true" class="w-full bg-danger hover:bg-red-600 text-white font-bold py-4 rounded-lg text-xl shadow-[0_0_15px_rgba(239,68,68,0.3)] transition btn-press" data-i18n="enterPit">
                ğŸ Enter Pit
            </button>
        </div>
    </div>

    <!-- Pit Modal -->
    <div id="pitModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <h2 class="text-ice text-2xl font-bold mb-2 tracking-widest border-b border-ice pb-1" data-i18n="inPit">IN PIT</h2>
		<p class="text-gray-400 text-sm mb-4"><span data-i18n="nextDriverIn">Next Driver:</span> <span id="modalNextDriverName" class="text-white font-bold">---</span></p>

        <div id="pitPhase2" class="w-full max-w-sm flex flex-col items-center">
            <div id="fuelToggleContainer" class="hidden mb-4 bg-navy-800 p-3 rounded border border-fuel/50 w-full">
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm font-bold text-gray-300" data-i18n="refuel">Kart Change / Refuel?</span>
                    <input type="checkbox" id="isRefuelCheck" checked class="w-6 h-6 accent-fuel">
                </label>
            </div>
            
            <div class="relative w-48 h-48 flex items-center justify-center border-4 border-gray-700 rounded-full mb-4 bg-navy-900">
                <span id="pitTimerDisplay" class="text-5xl font-bold big-digit text-white font-mono">00</span>
            </div>
            
            <button id="notifyBtn" class="hidden w-full bg-fuel text-black font-bold py-3 rounded-lg text-lg mb-2">
                ğŸ“¢ <span data-i18n="notifyDriver">Notify Driver</span>
            </button>
            <div id="notifiedMsg" class="hidden text-fuel text-sm mb-2 font-bold">âœ“ <span data-i18n="notified">Notified - Waiting for line cross</span></div>
            
            <button id="confirmExitBtn" disabled class="w-full bg-gray-800 text-gray-600 font-bold py-4 rounded-lg text-xl border border-gray-700 mb-4" data-i18n="wait">
                Wait...
            </button>
            
            <button onclick="cancelPitStop()" class="text-red-400 py-2 text-sm">âŒ <span data-i18n="cancelPit">Cancel Pit Entry</span></button>
        </div>
    </div>
	
	<!-- Manual Input Modal -->
	<div id="manualInputModal" class="hidden fixed inset-0 bg-navy-950/95 z-50 flex flex-col items-center justify-center p-4 backdrop-blur-sm">
		<div class="bg-navy-900 p-4 rounded-lg border border-gray-700 w-full max-w-sm">
			<h3 class="text-ice text-lg font-bold mb-4 text-center" data-i18n="manualInput">Manual Input</h3>
			
			<div class="space-y-3">
				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="position">Position</label>
						<input type="number" id="manualPosition" placeholder="1" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="laps">Laps</label>
						<input type="number" id="manualLaps" placeholder="0" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm">
					</div>
				</div>
				
				<div class="grid grid-cols-2 gap-3">
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="lastLap">Last Lap</label>
						<input type="text" id="manualLastLap" placeholder="1:02.345" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
					</div>
					<div>
						<label class="text-[10px] text-gray-400" data-i18n="bestLap">Best Lap</label>
						<input type="text" id="manualBestLap" placeholder="1:01.234" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
					</div>
				</div>
				
				<div>
					<label class="text-[10px] text-gray-400" data-i18n="gap">Gap to Leader</label>
					<input type="text" id="manualGap" placeholder="+1:23.456 or +2 laps" class="w-full bg-navy-950 border border-gray-600 rounded p-2 text-white text-sm font-mono">
				</div>
				
				<div class="flex items-center gap-2 bg-navy-800 p-2 rounded">
					<input type="checkbox" id="manualInPit" class="w-4 h-4 accent-fuel">
					<label class="text-sm text-gray-300" data-i18n="inPitNow">Currently in Pit</label>
				</div>
			</div>
			
			<div class="flex gap-2 mt-4">
				<button onclick="applyManualInput()" class="flex-1 bg-ice text-navy-950 font-bold py-2 rounded-lg" data-i18n="apply">Apply</button>
				<button onclick="closeManualInput()" class="flex-1 bg-navy-700 text-gray-300 py-2 rounded-lg" data-i18n="cancel">Cancel</button>
			</div>
		</div>
	</div>

    <script>
        // ==================== GLOBALS ====================
        let peer = null, conn = null, connections = [], myId = null, role = null;
        let config = {}; 
        let state = { 
            isRunning: false, 
            mode: 'normal', 
			trackCondition: 'dry',
            isRain: false, 
            currentDriverIdx: 0, 
            pitCount: 0, 
            startTime: 0, 
            stintStart: 0, 
            pitStart: 0, 
            isInPit: false, 
            fuelStart: 0, 
            stintOffset: 0, 
            activeSquad: 'A', 
            nextDriverIdx: 0, 
            targetStintMs: 0, 
            squadsActive: false,
            pendingPitEntry: false
        };
        let drivers = []; 
		let savedHostConfig = null;
		let savedConfigPanelState = null;
        let raceInterval, pitInterval, liveTimingInterval;
        let connectionRetries = 0;
        const MAX_RETRIES = 3;
		const RACE_STATE_KEY = 'strateger_race_state';
		let liveTimingManager = null;
		let proxyFetchInterval = null;
		let syncedTimes = null;
        
        // Live Timing State
        let liveTimingConfig = {
            url: '',
            teamName: '',
            enabled: false,
            demoMode: false
        };
		
		// Search configuration
		let searchConfig = {
			teamName: '',
			driverName: '',
			kartNumber: ''
		};
        
        let liveData = {
            position: null,
            previousPosition: null,
            lastLap: null,
            bestLap: null,
            laps: null,
            gapToLeader: null,
            competitors: []
        };
        
        // Demo mode state
        let demoState = {
            competitors: [],
            updateInterval: null
        };
		
		// ==================== I18N ====================
		let currentLang = 'en';
		
		const translations = {
			en: {
				offline: 'Offline',
				subtitle: 'Endurance Race Strategy Manager',
				host: 'Host',
				hostDesc: 'Manage the race',
				viewer: 'Viewer',
				viewerDesc: 'Watch live',
				yourCode: 'Your Code:',
				retry: 'Retry',
				raceSettings: 'âš™ï¸ Race Settings',
				liveTiming: 'Live Timing (Optional)',
				liveTimingUrl: 'Live Timing URL (APEX/RaceFacer)',
				searchBy: 'Search by:',
				team: 'Team',
				kart: 'Kart',
				driver: 'Driver',
				testConnection: 'Test',
				demo: 'Demo',
				manual: 'Manual',
				duration: 'Duration (hours)',
				reqStops: 'Required Stops',
				minStint: 'Min Stint (min)',
				maxStint: 'Max Stint (min)',
				driverLimits: 'Driver Limits (0 = no limit)',
				minDrive: 'Min Drive',
				maxDrive: 'Max Drive',
				pitTime: 'Pit Time (sec)',
				releaseBuffer: 'Release Buffer (sec)',
				doubleStint: 'Double',
				fuel: 'Fuel',
				squads: 'Squads',
				fuelTankTime: 'Fuel Tank Time (min)',
				driversSetup: 'Drivers (mark starter)',
				startRace: 'Start Race (Host)',
				enterCode: 'Enter Host Code:',
				connect: 'Connect',
				disconnect: 'Disconnect',
				code: 'Code:',
				synced: 'Synced',
				raceTime: 'Race Time',
				pitStops: 'Pit Stops',
				dry: 'Dry',
				wet: 'Wet',
				drying: 'Drying',
				targetStint: 'Target Stint',
				buildTime: 'Build Time',
				stintTime: 'Stint Time',
				currentDriver: 'Current Driver',
				activeSquad: 'Active Squad:',
				resting: 'Resting:',
				push: 'Push',
				problem: 'Problem',
				night: 'Night',
				resetMode: 'â†©ï¸ Reset Mode',
				driverHeader: 'Driver',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Next Driver',
				enterPit: 'ğŸ Enter Pit',
				inPit: 'IN PIT',
				nextDriverIn: 'Next Driver:',
				refuel: 'Kart Change / Refuel?',
				notifyDriver: 'Notify Driver',
				notified: 'Notified - Waiting for line cross',
				wait: 'Wait...',
				cancelPit: 'Cancel Pit Entry',
				manualInput: 'Manual Input',
				position: 'Position',
				laps: 'Laps',
				lastLap: 'Last Lap',
				bestLap: 'Best Lap',
				gap: 'Gap to Leader',
				inPitNow: 'Currently in Pit',
				apply: 'Apply',
				cancel: 'Cancel',
				waitingData: 'Waiting for data...',
				proxyData: 'Proxy Data:',
				liveView: 'Live View',
				connecting: 'Connecting...',
				connected: 'Connected',
				waitingRace: 'Connected! Waiting for race...',
				disconnected: 'Disconnected',
				enterUrl: 'âŒ Enter URL',
				enterValue: 'âŒ Enter',
				testing: 'ğŸ”„ Testing...',
				found: 'âœ… Found! Position:',
				notFound: 'âš ï¸ Not found - check details or use iframe',
				error: 'âŒ Error:',
				confirmEarlyPit: 'Window closed! Enter anyway?',
				confirmExit: 'âœ… Confirm Line Cross',
				timeExceeded: 'ğŸš¨ Time Exceeded!',
				problemQuick: 'ğŸ¢ Problem - Quick Entry!',
				pushExtend: 'ğŸ”¥ Extending! Build time',
				nearLimit: 'âš ï¸ Near limit!',
				targetWindow: 'âœ… Target Window',
				overExtend: 'ğŸ“¥ Over Extended',
				nightActive: 'ğŸŒ™ Night Active',
				pushActive: 'ğŸ”¥ Push Active',
				problemActive: 'ğŸ¢ Problem Active',
				connecting: 'Connecting...',
				connected: 'Connected',
				teamNotFound: 'Team not found',
				connectionIssues: 'Connection issues',
				usingIframe: 'Using iframe',
				connectionFailed: 'Connection failed',
				stopped: 'Stopped',
			},
			he: {
				offline: '×œ× ××—×•×‘×¨',
				subtitle: '×× ×”×œ ××¡×˜×¨×˜×’×™×™×ª ××™×¨×•×¦×™ ×¡×™×‘×•×œ×ª',
				host: '×××¨×—',
				hostDesc: '× ×”×œ ××ª ×”××™×¨×•×¥',
				viewer: '×¦×•×¤×”',
				viewerDesc: '×¦×¤×” ×‘×©×™×“×•×¨ ×—×™',
				yourCode: '×”×§×•×“ ×©×œ×š:',
				retry: '× ×¡×” ×©×•×‘',
				raceSettings: 'âš™ï¸ ×”×’×“×¨×•×ª ××™×¨×•×¥',
				liveTiming: 'Live Timing (××•×¤×¦×™×•× ×œ×™)',
				liveTimingUrl: '×§×™×©×•×¨ Live Timing (APEX/RaceFacer)',
				searchBy: '×—×¤×© ×œ×¤×™:',
				team: '×§×‘×•×¦×”',
				kart: '×§××¨×˜',
				driver: '× ×”×’',
				testConnection: '×‘×“×•×§',
				demo: '×“××•',
				manual: '×™×“× ×™',
				duration: '××©×š (×©×¢×•×ª)',
				reqStops: '×¢×¦×™×¨×•×ª ×—×•×‘×”',
				minStint: '××™× \' ×¡×˜×™× ×˜ (×“×§\')',
				maxStint: '××§×¡\' ×¡×˜×™× ×˜ (×“×§\')',
				driverLimits: '×’×‘×•×œ×•×ª × ×”×’ (0 = ×œ×œ× ×”×’×‘×œ×”)',
				minDrive: '××™× ×™××•× × ×”×™×’×”',
				maxDrive: '××§×¡×™××•× × ×”×™×’×”',
				pitTime: '×–××Ÿ ×¤×™×˜×¡ (×©× ×™×•×ª)',
				releaseBuffer: '×”×§×“××ª ×”×ª×¨××” (×©× \')',
				doubleStint: '×“××‘×œ',
				fuel: '×“×œ×§',
				squads: '×—×•×œ×™×•×ª',
				fuelTankTime: '×–××Ÿ ××™×›×œ ×“×œ×§ (×“×§\')',
				driversSetup: '×”×’×“×¨×ª × ×”×’×™× (×¡××Ÿ ××–× ×§)',
				startRace: '×”×ª×—×œ ××¨×•×¥ (×× ×”×œ)',
				enterCode: '×”×›× ×¡ ×§×•×“ ×××¨×—:',
				connect: '×”×ª×—×‘×¨',
				disconnect: '×”×ª× ×ª×§',
				code: '×§×•×“:',
				synced: '××¡×•× ×›×¨×Ÿ',
				raceTime: '×–××Ÿ ××™×¨×•×¥',
				pitStops: '×¢×¦×™×¨×•×ª ×¤×™×˜×¡',
				dry: '×™×‘×©',
				wet: '×’×©×',
				drying: '××ª×™×™×‘×©',
				targetStint: '×™×¢×“ ×¡×˜×™× ×˜ × ×•×›×—×™',
				buildTime: '×¦×‘×•×¨ ×–××Ÿ',
				stintTime: '×–××Ÿ ×¡×˜×™× ×˜',
				currentDriver: '× ×”×’ × ×•×›×—×™',
				activeSquad: '×—×•×œ×™×” ×¤×¢×™×œ×”:',
				resting: '× ×—×™×:',
				push: '×§×¦×‘',
				problem: '×ª×§×œ×”',
				night: '×œ×™×œ×”',
				resetMode: 'â†©ï¸ ××™×¤×•×¡ ××¦×‘',
				driverHeader: '× ×”×’',
				stintsHeader: '×¡×˜\'',
				totalHeader: '×¡×”"×›',
				nextDriver: '× ×”×’ ×”×‘×',
				enterPit: 'ğŸ ×›× ×™×¡×” ×œ×¤×™×˜×¡',
				inPit: '×‘×¤×™×˜×¡',
				nextDriverIn: '× ×”×’ × ×›× ×¡:',
				refuel: '×”×•×—×œ×£ ×§××¨×˜ / ×ª×“×œ×•×§?',
				notifyDriver: '×”×•×“×¢ ×œ× ×”×’ ×œ×”×ª×›×•× ×Ÿ',
				notified: '×”×•×“×¢×” × ×©×œ×—×” - ×××ª×™×Ÿ ×œ×—×¦×™×™×ª ×§×•',
				wait: '×”××ª×Ÿ...',
				cancelPit: '×‘×˜×œ ×›× ×™×¡×” ×œ×¤×™×˜×¡',
				manualInput: '×”×–× ×” ×™×“× ×™×ª',
				position: '××™×§×•×',
				laps: '×”×§×¤×•×ª',
				lastLap: '×”×§×¤×” ××—×¨×•× ×”',
				bestLap: '×”×§×¤×” ×”×˜×•×‘×”',
				gap: '×¤×¢×¨ ×××•×‘×™×œ',
				inPitNow: '×›×¨×’×¢ ×‘×¤×™×˜×¡',
				apply: '×”×—×œ',
				cancel: '×‘×™×˜×•×œ',
				waitingData: '×××ª×™×Ÿ ×œ× ×ª×•× ×™×...',
				proxyData: '× ×ª×•× ×™ ×¤×¨×•×§×¡×™:',
				liveView: '×ª×¦×•×’×” ×—×™×”',
				connecting: '××ª×—×‘×¨...',
				connected: '××—×•×‘×¨',
				waitingRace: '××—×•×‘×¨! ×××ª×™×Ÿ ×œ×ª×—×™×œ×ª ××¨×•×¥...',
				disconnected: '× ×•×ª×§ ××”×××¨×—',
				enterUrl: 'âŒ ×”×›× ×¡ ×§×™×©×•×¨',
				enterValue: 'âŒ ×”×›× ×¡',
				testing: 'ğŸ”„ ×‘×•×“×§...',
				found: 'âœ… × ××¦×! ××™×§×•×:',
				notFound: 'âš ï¸ ×œ× × ××¦× - ×‘×“×•×§ ××ª ×”×¤×¨×˜×™× ××• ×”×©×ª××© ×‘-iframe',
				error: 'âŒ ×©×’×™××”:',
				confirmEarlyPit: '×—×œ×•×Ÿ ×¡×’×•×¨! ×œ×”×™×›× ×¡?',
				confirmExit: 'âœ… ××©×¨ ×—×¦×™×™×ª ×§×•',
				timeExceeded: 'ğŸš¨ ×—×¨×™×’×ª ×–××Ÿ!',
				problemQuick: 'ğŸ¢ ×ª×§×œ×” - ×›× ×™×¡×” ××”×™×¨×”!',
				pushExtend: 'ğŸ”¥ ×××¨×™×›×™×! ×¦×‘×•×¨ ×–××Ÿ',
				nearLimit: 'âš ï¸ ×§×¨×•×‘ ×œ×’×‘×•×œ!',
				targetWindow: 'âœ… ×—×œ×•×Ÿ ×™×¢×“',
				overExtend: 'ğŸ“¥ ×”××¨×›×ª ×™×ª×¨',
				nightActive: 'ğŸŒ™ ×œ×™×œ×” ×¤×¢×™×œ',
				pushActive: 'ğŸ”¥ ×§×¦×‘ ×¤×¢×™×œ',
				problemActive: 'ğŸ¢ ×ª×§×œ×” ×¤×¢×™×œ',
				connecting: '××ª×—×‘×¨...',
				connected: '××—×•×‘×¨',
				teamNotFound: '×§×‘×•×¦×” ×œ× × ××¦××”',
				connectionIssues: '×‘×¢×™×•×ª ×—×™×‘×•×¨',
				usingIframe: '××©×ª××© ×‘-iframe',
				connectionFailed: '×”×—×™×‘×•×¨ × ×›×©×œ',
				stopped: '× ×¢×¦×¨',
			},
			fr: {
				offline: 'Hors ligne',
				subtitle: 'Gestionnaire de StratÃ©gie de Course d\'Endurance',
				host: 'HÃ´te',
				hostDesc: 'GÃ©rer la course',
				viewer: 'Spectateur',
				viewerDesc: 'Regarder en direct',
				yourCode: 'Votre Code:',
				retry: 'RÃ©essayer',
				raceSettings: 'âš™ï¸ ParamÃ¨tres de Course',
				liveTiming: 'ChronomÃ©trage en Direct (Optionnel)',
				liveTimingUrl: 'URL ChronomÃ©trage (APEX/RaceFacer)',
				searchBy: 'Rechercher par:',
				team: 'Ã‰quipe',
				kart: 'Kart',
				driver: 'Pilote',
				testConnection: 'Tester',
				demo: 'DÃ©mo',
				manual: 'Manuel',
				duration: 'DurÃ©e (heures)',
				reqStops: 'ArrÃªts Requis',
				minStint: 'Stint Min (min)',
				maxStint: 'Stint Max (min)',
				driverLimits: 'Limites Pilote (0 = illimitÃ©)',
				minDrive: 'Min Conduite',
				maxDrive: 'Max Conduite',
				pitTime: 'Temps Pit (sec)',
				releaseBuffer: 'Alerte Avance (sec)',
				doubleStint: 'Double',
				fuel: 'Carburant',
				squads: 'Ã‰quipes',
				fuelTankTime: 'Autonomie RÃ©servoir (min)',
				driversSetup: 'Pilotes (marquer le dÃ©part)',
				startRace: 'DÃ©marrer Course (HÃ´te)',
				enterCode: 'Entrer Code HÃ´te:',
				connect: 'Connecter',
				disconnect: 'DÃ©connecter',
				code: 'Code:',
				synced: 'SynchronisÃ©',
				raceTime: 'Temps Course',
				pitStops: 'ArrÃªts Pit',
				dry: 'Sec',
				wet: 'MouillÃ©',
				drying: 'SÃ©chage',
				targetStint: 'Stint Cible',
				buildTime: 'Accumuler Temps',
				stintTime: 'Temps Stint',
				currentDriver: 'Pilote Actuel',
				activeSquad: 'Ã‰quipe Active:',
				resting: 'Au Repos:',
				push: 'Pousser',
				problem: 'ProblÃ¨me',
				night: 'Nuit',
				resetMode: 'â†©ï¸ RÃ©initialiser',
				driverHeader: 'Pilote',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'Prochain Pilote',
				enterPit: 'ğŸ Entrer Pit',
				inPit: 'AU PIT',
				nextDriverIn: 'Prochain Pilote:',
				refuel: 'Changement Kart / Ravitaillement?',
				notifyDriver: 'Alerter Pilote',
				notified: 'AlertÃ© - Attente passage ligne',
				wait: 'Attendre...',
				cancelPit: 'Annuler EntrÃ©e Pit',
				manualInput: 'Saisie Manuelle',
				position: 'Position',
				laps: 'Tours',
				lastLap: 'Dernier Tour',
				bestLap: 'Meilleur Tour',
				gap: 'Ã‰cart au Leader',
				inPitNow: 'Actuellement au Pit',
				apply: 'Appliquer',
				cancel: 'Annuler',
				waitingData: 'En attente de donnÃ©es...',
				proxyData: 'DonnÃ©es Proxy:',
				liveView: 'Vue en Direct',
				connecting: 'Connexion...',
				connected: 'ConnectÃ©',
				waitingRace: 'ConnectÃ©! En attente de la course...',
				disconnected: 'DÃ©connectÃ©',
				enterUrl: 'âŒ Entrer URL',
				enterValue: 'âŒ Entrer',
				testing: 'ğŸ”„ Test...',
				found: 'âœ… TrouvÃ©! Position:',
				notFound: 'âš ï¸ Non trouvÃ© - vÃ©rifier ou utiliser iframe',
				error: 'âŒ Erreur:',
				confirmEarlyPit: 'FenÃªtre fermÃ©e! Entrer quand mÃªme?',
				confirmExit: 'âœ… Confirmer Passage Ligne',
				timeExceeded: 'ğŸš¨ Temps DÃ©passÃ©!',
				problemQuick: 'ğŸ¢ ProblÃ¨me - EntrÃ©e Rapide!',
				pushExtend: 'ğŸ”¥ On prolonge! Accumuler temps',
				nearLimit: 'âš ï¸ Proche limite!',
				targetWindow: 'âœ… FenÃªtre Cible',
				overExtend: 'ğŸ“¥ Prolongation Excessive',
				nightActive: 'ğŸŒ™ Nuit Active',
				pushActive: 'ğŸ”¥ Pousser Actif',
				problemActive: 'ğŸ¢ ProblÃ¨me Actif',
				stopped: 'ArrÃªtÃ©',
			},
			pt: {
				offline: 'Offline',
				subtitle: 'Gestor de EstratÃ©gia de Corrida de Endurance',
				host: 'AnfitriÃ£o',
				hostDesc: 'Gerir a corrida',
				viewer: 'Espectador',
				viewerDesc: 'Ver ao vivo',
				yourCode: 'Seu CÃ³digo:',
				retry: 'Tentar Novamente',
				raceSettings: 'âš™ï¸ ConfiguraÃ§Ãµes da Corrida',
				liveTiming: 'Cronometragem ao Vivo (Opcional)',
				liveTimingUrl: 'URL Cronometragem (APEX/RaceFacer)',
				searchBy: 'Pesquisar por:',
				team: 'Equipa',
				kart: 'Kart',
				driver: 'Piloto',
				testConnection: 'Testar',
				demo: 'Demo',
				manual: 'Manual',
				duration: 'DuraÃ§Ã£o (horas)',
				reqStops: 'Paragens ObrigatÃ³rias',
				minStint: 'Stint MÃ­n (min)',
				maxStint: 'Stint MÃ¡x (min)',
				driverLimits: 'Limites Piloto (0 = ilimitado)',
				minDrive: 'MÃ­n ConduÃ§Ã£o',
				maxDrive: 'MÃ¡x ConduÃ§Ã£o',
				pitTime: 'Tempo Pit (seg)',
				releaseBuffer: 'Alerta Antecipado (seg)',
				doubleStint: 'Duplo',
				fuel: 'CombustÃ­vel',
				squads: 'Equipas',
				fuelTankTime: 'Autonomia Tanque (min)',
				driversSetup: 'Pilotos (marcar partida)',
				startRace: 'Iniciar Corrida (AnfitriÃ£o)',
				enterCode: 'Inserir CÃ³digo AnfitriÃ£o:',
				connect: 'Conectar',
				disconnect: 'Desconectar',
				code: 'CÃ³digo:',
				synced: 'Sincronizado',
				raceTime: 'Tempo Corrida',
				pitStops: 'Paragens Pit',
				dry: 'Seco',
				wet: 'Molhado',
				drying: 'Secando',
				targetStint: 'Stint Alvo',
				buildTime: 'Acumular Tempo',
				stintTime: 'Tempo Stint',
				currentDriver: 'Piloto Atual',
				activeSquad: 'Equipa Ativa:',
				resting: 'Descansando:',
				push: 'Atacar',
				problem: 'Problema',
				night: 'Noite',
				resetMode: 'â†©ï¸ Reiniciar',
				driverHeader: 'Piloto',
				stintsHeader: 'St.',
				totalHeader: 'Total',
				nextDriver: 'PrÃ³ximo Piloto',
				enterPit: 'ğŸ Entrar Pit',
				inPit: 'NO PIT',
				nextDriverIn: 'PrÃ³ximo Piloto:',
				refuel: 'Troca Kart / Reabastecimento?',
				notifyDriver: 'Alertar Piloto',
				notified: 'Alertado - Aguardando passagem linha',
				wait: 'Aguardar...',
				cancelPit: 'Cancelar Entrada Pit',
				manualInput: 'Entrada Manual',
				position: 'PosiÃ§Ã£o',
				laps: 'Voltas',
				lastLap: 'Ãšltima Volta',
				bestLap: 'Melhor Volta',
				gap: 'DiferenÃ§a ao LÃ­der',
				inPitNow: 'Atualmente no Pit',
				apply: 'Aplicar',
				cancel: 'Cancelar',
				waitingData: 'Aguardando dados...',
				proxyData: 'Dados Proxy:',
				liveView: 'Vista ao Vivo',
				connecting: 'Conectando...',
				connected: 'Conectado',
				waitingRace: 'Conectado! Aguardando corrida...',
				disconnected: 'Desconectado',
				enterUrl: 'âŒ Inserir URL',
				enterValue: 'âŒ Inserir',
				testing: 'ğŸ”„ Testando...',
				found: 'âœ… Encontrado! PosiÃ§Ã£o:',
				notFound: 'âš ï¸ NÃ£o encontrado - verificar ou usar iframe',
				error: 'âŒ Erro:',
				confirmEarlyPit: 'Janela fechada! Entrar mesmo assim?',
				confirmExit: 'âœ… Confirmar Passagem Linha',
				timeExceeded: 'ğŸš¨ Tempo Excedido!',
				problemQuick: 'ğŸ¢ Problema - Entrada RÃ¡pida!',
				pushExtend: 'ğŸ”¥ Prolongando! Acumular tempo',
				nearLimit: 'âš ï¸ Perto do limite!',
				targetWindow: 'âœ… Janela Alvo',
				overExtend: 'ğŸ“¥ Prolongamento Excessivo',
				nightActive: 'ğŸŒ™ Noite Ativa',
				pushActive: 'ğŸ”¥ Atacar Ativo',
				problemActive: 'ğŸ¢ Problema Ativo',
				stopped: 'Parado'
			}
		};
		
		function t(key) {
			return translations[currentLang][key] || translations['en'][key] || key;
		}
		
		function setLanguage(lang) {
			if (!['en', 'he', 'fr', 'pt'].includes(lang)) return;
			
			currentLang = lang;
			document.documentElement.lang = currentLang;
			document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
			
			document.getElementById('langSelect').value = currentLang;
			
			applyTranslations();
			localStorage.setItem('strateger_lang', currentLang);
		}

		function applyTranslations() {
			document.querySelectorAll('[data-i18n]').forEach(el => {
				const key = el.getAttribute('data-i18n');
				if (translations[currentLang][key]) {
					el.innerText = translations[currentLang][key];
				}
			});
			updateSearchPlaceholder();
		}
		
		function updateSearchPlaceholder() {
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			const input = document.getElementById('searchValue');
			if (!input) return;
			
			const placeholders = {
				en: {
					team: 'Enter team name (e.g. RACING TEAM)',
					kart: 'Enter kart number (e.g. 07)',
					driver: 'Enter driver name (e.g. John)'
				},
				he: {
					team: '×”×›× ×¡ ×©× ×§×‘×•×¦×” (×œ××©×œ: RACING)',
					kart: '×”×›× ×¡ ××¡×¤×¨ ×§××¨×˜ (×œ××©×œ: 07)',
					driver: '×”×›× ×¡ ×©× × ×”×’ (×œ××©×œ: ×™× ×™×‘)'
				},
				fr: {
					team: 'Nom d\'Ã©quipe (ex: RACING TEAM)',
					kart: 'NumÃ©ro de kart (ex: 07)',
					driver: 'Nom du pilote (ex: Jean)'
				},
				pt: {
					team: 'Nome da equipa (ex: RACING TEAM)',
					kart: 'NÃºmero do kart (ex: 07)',
					driver: 'Nome do piloto (ex: JoÃ£o)'
				}
			};
			
			input.placeholder = placeholders[currentLang]?.[searchType] || placeholders.en[searchType];
		}
		
		// ==================== INIT ====================
		document.addEventListener('DOMContentLoaded', () => {
			// Load saved language
			const savedLang = localStorage.getItem('strateger_lang');
			if (savedLang && ['en', 'he', 'fr', 'pt'].includes(savedLang)) {
				currentLang = savedLang;
				document.documentElement.lang = currentLang;
				document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
			}
			document.getElementById('langSelect').value = currentLang;
			applyTranslations();
			
			// Setup search type change handler
			document.querySelectorAll('input[name="searchType"]').forEach(radio => {
				radio.addEventListener('change', updateSearchPlaceholder);
			});
			
			generateDrivers();
			runSim();
            restoreHostState();
            console.log("Strateger loaded");
            
            // Check for saved race after a short delay
            setTimeout(checkForSavedRace, 500);
		});

        // PeerJS configuration
        const peerConfig = {
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ]
            }
        };

        // ==================== ROLE SELECTION ====================
        function selectRole(r) {
			// Destroy existing peer if switching roles
			if (peer) {
				peer.destroy();
				peer = null;
			}
			conn = null;
			connections = [];
			
            role = r;
            document.getElementById('hostBtn').classList.toggle('border-ice', r === 'host');
            document.getElementById('clientBtn').classList.toggle('border-neon', r === 'client');
            document.getElementById('hostSection').classList.toggle('hidden', r !== 'host');
            document.getElementById('clientSection').classList.toggle('hidden', r !== 'client');
            document.getElementById('configPanel').classList.add('hidden');

            if (r === 'host') {
                initHostPeer();
            } else {
                initClientPeer();
            }
        }

		function applyViewerMode() {
			const dashboard = document.getElementById('raceDashboard');
			
			if (role === 'client') {
				dashboard.classList.add('viewer-mode');
				
				// âœ… ×”×¡×ª×¨ ×›×¤×ª×•×¨×™× (×œ× disable)
				const hideInViewer = [
					'btnPush',
					'btnBad', 
					'btnNight',
					'btnResetMode',
					'pitEntryBtn'
				];
				
				hideInViewer.forEach(id => {
					const el = document.getElementById(id);
					if (el) {
						el.classList.add('hidden');
					}
				});
				
				// ×’× ×”×¡×ª×¨ ×›×¤×ª×•×¨×™ ×”×ª×××”
				document.querySelectorAll('[data-viewer-disabled="true"]').forEach(el => {
					if (el.tagName === 'BUTTON' || el.onclick) {
						el.classList.add('hidden');
					}
				});
				
				const headerText = document.getElementById('headerModeText');
				if (headerText) {
					headerText.textContent = 'VIEWER MODE';
					headerText.classList.remove('text-gray-500');
					headerText.classList.add('text-neon');
				}
				
				console.log('âœ… Viewer mode - Buttons hidden');
				
			} else if (role === 'host') {
				dashboard.classList.remove('viewer-mode');
				
				const showInHost = ['btnPush', 'btnBad', 'btnResetMode', 'pitEntryBtn'];
				showInHost.forEach(id => {
					const el = document.getElementById(id);
					if (el && id !== 'btnResetMode') {  // resetMode ××•×¦×’ ×¨×§ ×›×©×™×© mode
						el.classList.remove('hidden');
					}
				});
				
				// btnNight ×ª×œ×•×™ ×‘-squads
				const btnNight = document.getElementById('btnNight');
				if (btnNight && config.useSquads) {
					btnNight.classList.remove('hidden');
				}
				
				document.querySelectorAll('[data-viewer-disabled="true"]').forEach(el => {
					el.classList.remove('hidden');
				});
				
				const headerText = document.getElementById('headerModeText');
				if (headerText) {
					headerText.textContent = 'LIVE';
					headerText.classList.add('text-gray-500');
					headerText.classList.remove('text-neon');
				}
				
				console.log('âœ… Host mode - Full control');
			}
		}

        // ==================== SIMULATION ====================
        function runSim() {
			const dur = parseFloat(document.getElementById('raceDuration').value) || 12;
			const stops = parseInt(document.getElementById('reqPitStops').value) || 0;
			const minS = parseFloat(document.getElementById('minStint').value) || 10;
			const maxS = parseFloat(document.getElementById('maxStint').value) || 60;
			const pitTime = parseInt(document.getElementById('minPitTime').value) || 120;
			
			// Total race time in minutes
			const totalRaceMin = dur * 60;
			
			// Total pit time in minutes
			const totalPitMin = (stops * pitTime) / 60;
			
			// Available driving time
			const drivingTimeMin = totalRaceMin - totalPitMin;
			
			// Average stint considering pit stops
			const avgStint = drivingTimeMin / (stops + 1);
			
			const valid = avgStint >= minS && avgStint <= maxS;
			
			const labels = {
				en: { avg: 'Avg Stint', drive: 'Drive Time', pit: 'Pit Time', ok: 'âœ… Valid', bad: 'âš ï¸ Out of range' },
				he: { avg: '×¡×˜×™× ×˜ ×××•×¦×¢', drive: '×–××Ÿ × ×”×™×’×”', pit: '×–××Ÿ ×¤×™×˜×¡×™×', ok: 'âœ… ×ª×§×™×Ÿ', bad: 'âš ï¸ ××—×•×¥ ×œ×˜×•×•×—' },
				fr: { avg: 'Stint Moy', drive: 'Temps Conduite', pit: 'Temps Pits', ok: 'âœ… Valide', bad: 'âš ï¸ Hors limites' },
				pt: { avg: 'Stint MÃ©dio', drive: 'Tempo ConduÃ§Ã£o', pit: 'Tempo Pits', ok: 'âœ… VÃ¡lido', bad: 'âš ï¸ Fora do intervalo' }
			};
			const l = labels[currentLang] || labels.en;
			
			document.getElementById('simResult').innerText = 
				`${l.avg}: ${avgStint.toFixed(1)} min\n${l.drive}: ${drivingTimeMin.toFixed(0)} min | ${l.pit}: ${totalPitMin.toFixed(0)} min\n${valid ? l.ok : l.bad}`;
			document.getElementById('simResult').className = `bg-navy-950 p-2 rounded text-xs border font-mono text-center whitespace-pre-line ${valid ? 'text-neon border-neon/50' : 'text-danger border-danger/50'}`;
		}

        function toggleConfigPanel() {
            const panel = document.getElementById('configPanel');
            const arrow = document.getElementById('configArrow');
            panel.classList.toggle('hidden');
            arrow.innerText = panel.classList.contains('hidden') ? 'â–¼' : 'â–²';
        }
		
		// ==================== LIVE TIMING ====================
		function updateSearchConfig() {
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			const searchValue = document.getElementById('searchValue')?.value || '';
			
			searchConfig.teamName = '';
			searchConfig.driverName = '';
			searchConfig.kartNumber = '';
			
			if (searchType === 'team') {
				searchConfig.teamName = searchValue;
			} else if (searchType === 'kart') {
				searchConfig.kartNumber = searchValue;
			} else if (searchType === 'driver') {
				searchConfig.driverName = searchValue;
			}
		}
		
		function testLiveTiming() {
			const url = document.getElementById('liveTimingUrl').value;
			const searchValue = document.getElementById('searchValue')?.value || '';
			const searchType = document.querySelector('input[name="searchType"]:checked')?.value || 'team';
			
			const statusEl = document.getElementById('liveTimingStatus');
			
			if (!url) {
				statusEl.innerText = t('enterUrl');
				statusEl.className = "text-[10px] text-red-500 text-center";
				return;
			}
			
			if (!searchValue) {
				const typeNames = { team: t('team'), kart: t('kart'), driver: t('driver') };
				statusEl.innerText = `${t('enterValue')} ${typeNames[searchType]}`;
				statusEl.className = "text-[10px] text-red-500 text-center";
				return;
			}
			
			liveTimingConfig.url = url;
			liveTimingConfig.enabled = true;
			updateSearchConfig();
			
			statusEl.innerText = t('testing');
			statusEl.className = "text-[10px] text-yellow-500 text-center";
			
			fetchLiveTimingFromProxy().then(() => {
				if (liveData.position) {
					statusEl.innerText = `${t('found')} ${liveData.position}`;
					statusEl.className = "text-[10px] text-green-500 text-center font-bold";
				} else {
					statusEl.innerText = t('notFound');
					statusEl.className = "text-[10px] text-yellow-500 text-center";
				}
			}).catch(e => {
				statusEl.innerText = `${t('error')} ${e.message}`;
				statusEl.className = "text-[10px] text-red-500 text-center";
			});
		}
		
		async function fetchLiveTimingFromProxy() {
			if (!liveTimingConfig.url) {
				console.log('No live timing URL configured');
				return;
			}
			
			// ×¢×“×›×Ÿ ××ª ×”-search config
			updateSearchConfig();
			
			// ×¢×“×›×Ÿ ×¡×˜×˜×•×¡
			updateProxyStatus("ğŸ”„ " + t('connecting'));
			
			const url = liveTimingConfig.url;
			const searchTerm = searchConfig.driverName || searchConfig.teamName || searchConfig.kartNumber || '';
			
			console.log(`[Strateger] Starting live timing with URL: ${url}`);
			console.log(`[Strateger] Search term: "${searchTerm}"`);
			
			// ×¦×•×¨ ×× ×”×œ ×—×“×© ×× ×œ× ×§×™×™×
			if (!liveTimingManager) {
				liveTimingManager = new LiveTimingManager();
			}
			
			// ×”×ª×—×œ ××ª ×”-scraper
			liveTimingManager.start(url, searchTerm, {
				updateInterval: 5000, // 5 ×©× ×™×•×ª ×‘×™×Ÿ ×¢×“×›×•× ×™×
				
				/**
				 * × ×§×¨× ×‘×›×œ ×¤×¢× ×©×™×© ×¢×“×›×•×Ÿ ××”×¡×§×¨×™×™×¤×¨
				 */
				onUpdate: (data) => {
					console.log(`[Strateger] Live timing update #${data.updateNumber} received`);
					
					// ×¢×“×›×Ÿ ××ª ×”××¦×‘ ×”×’×œ×•×‘×œ×™ ×©×œ Strateger
					if (data.ourTeam) {
						// ×©××•×¨ ××™×§×•× ×§×•×“×
						liveData.previousPosition = liveData.position;
						
						// ×¢×“×›×Ÿ × ×ª×•× ×™×
						liveData.position = data.ourTeam.position;
						liveData.lastLap = data.ourTeam.lastLap;
						liveData.bestLap = data.ourTeam.bestLap;
						liveData.laps = data.ourTeam.totalLaps;
						liveData.gapToLeader = data.ourTeam.gap;
						
						console.log(`[Strateger] Our team: P${data.ourTeam.position}, ${data.ourTeam.totalLaps} laps, Gap: ${data.ourTeam.gap}s`);
					} else {
						console.warn('[Strateger] Our team not found in results');
					}
					
					// ×¢×“×›×Ÿ ×¨×©×™××ª ××ª×—×¨×™×
					liveData.competitors = data.competitors;
					
					// ×¢×“×›×Ÿ UI
					updateLiveTimingUI();
					
					// ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¢× ×©× ×”×¡×¤×§
					const statusText = data.found 
						? `âœ… ${t('connected')} - ${data.provider}` 
						: `âš ï¸ ${t('connected')} - ${t('teamNotFound')}`;
					updateProxyStatus(statusText);
					
					// ×¡× ×›×¨×Ÿ ×¢× WebRTC ×× ×™×© peer
					if (typeof syncDataToPeer === 'function') {
						syncDataToPeer();
					}
				},
				
				/**
				 * × ×§×¨× ×›×©×™×© ×©×’×™××”
				 */
				onError: (error, consecutiveErrors) => {
					console.error(`[Strateger] Live timing error (${consecutiveErrors || 0} consecutive):`, error.message);
					
					// ×”×¦×’ ×©×’×™××” ×œ××©×ª××©
					const errorMsg = consecutiveErrors >= 3 
						? `âš ï¸ ${t('connectionIssues')}` 
						: `âš ï¸ ${error.message}`;
					updateProxyStatus(errorMsg);
					
					// ×× ×™×© ×”×¨×‘×” ×©×’×™××•×ª ×‘×¨×¦×™×¤×•×ª, × ×¡×” iframe ×›×’×™×‘×•×™
					if (consecutiveErrors >= 3 && !liveData.position) {
						console.log('[Strateger] Too many errors, falling back to iframe');
						setTimeout(() => {
							if (!liveData.position) {
								updateProxyStatus("âš ï¸ " + t('usingIframe'));
								openLiveTimingEmbed();
							}
						}, 3000);
					}
				},
				
				/**
				 * × ×§×¨× ×›×©×™×© ×©×’×™××” ×—××•×¨×” (5 ×©×’×™××•×ª ×‘×¨×¦×™×¤×•×ª)
				 */
				onFatalError: (error) => {
					console.error('[Strateger] Fatal error, scraper stopped:', error.message);
					updateProxyStatus("âŒ " + t('connectionFailed'));
					
					// ××•×¤×¦×™×•× ×œ×™: ×¤×ª×— iframe ××•×˜×•××˜×™×ª
					setTimeout(() => {
						openLiveTimingEmbed();
					}, 2000);
				}
			});
		}
		
		function parseTimeToMs(timeStr) {
			if (!timeStr) return null;
			if (typeof timeStr === 'number') return timeStr;
			
			const match = String(timeStr).match(/(?:(\d{1,2}):)?(\d{1,2}):?(\d{2})\.(\d{2,3})/);
			if (match) {
				const hours = match[1] ? parseInt(match[1]) : 0;
				const mins = parseInt(match[2]) || 0;
				const secs = parseInt(match[3]) || 0;
				let ms = parseInt(match[4]) || 0;
				if (match[4].length === 2) ms *= 10;
				return (hours * 3600 + mins * 60 + secs) * 1000 + ms;
			}
			
			const secMatch = String(timeStr).match(/(\d+)\.(\d{2,3})/);
			if (secMatch) {
				let ms = parseInt(secMatch[2]);
				if (secMatch[2].length === 2) ms *= 10;
				return parseInt(secMatch[1]) * 1000 + ms;
			}
			
			return null;
		}
		
		function updateProxyStatus(msg) {
			const el = document.getElementById('liveTimingStatus');
			if (el) el.innerText = msg;
		}
		
		function startProxyLiveTiming() {
			if (proxyFetchInterval) clearInterval(proxyFetchInterval);
			
			fetchLiveTimingFromProxy();
			proxyFetchInterval = setInterval(fetchLiveTimingFromProxy, 5000);
		}
		
		function stopProxyLiveTiming() {
			if (proxyFetchInterval) {
				clearInterval(proxyFetchInterval);
				proxyFetchInterval = null;
			}
		}
		
		// ==================== MANUAL INPUT ====================
		function openManualInput() {
			document.getElementById('manualInputModal').classList.remove('hidden');
			
			// Pre-fill with current values
			if (liveData.position) document.getElementById('manualPosition').value = liveData.position;
			if (liveData.laps) document.getElementById('manualLaps').value = liveData.laps;
			if (liveData.lastLap) document.getElementById('manualLastLap').value = formatLapTime(liveData.lastLap);
			if (liveData.bestLap) document.getElementById('manualBestLap').value = formatLapTime(liveData.bestLap);
		}
		
		function closeManualInput() {
			document.getElementById('manualInputModal').classList.add('hidden');
		}
		
		function applyManualInput() {
			const pos = parseInt(document.getElementById('manualPosition').value);
			const laps = parseInt(document.getElementById('manualLaps').value);
			const lastLap = parseTimeToMs(document.getElementById('manualLastLap').value);
			const bestLap = parseTimeToMs(document.getElementById('manualBestLap').value);
			const gap = document.getElementById('manualGap').value;
			const inPit = document.getElementById('manualInPit').checked;
			
			if (pos) {
				liveData.previousPosition = liveData.position;
				liveData.position = pos;
			}
			if (laps) liveData.laps = laps;
			if (lastLap) liveData.lastLap = lastLap;
			if (bestLap) liveData.bestLap = bestLap;
			if (gap) liveData.gapToLeader = parseTimeToMs(gap);
			
			// Enable live timing display
			liveTimingConfig.enabled = true;
			document.getElementById('liveTimingPanel').classList.remove('hidden');
			document.getElementById('liveIndicator').classList.remove('hidden');
			
			updateLiveTimingUI();
			closeManualInput();
			broadcast();
		}
		
		// ==================== LIVE TIMING EMBED ====================
		function openLiveTimingEmbed() {
			const url = liveTimingConfig.url;
			if (!url) return;
			
			document.getElementById('liveTimingEmbed').classList.remove('hidden');
			document.getElementById('liveTimingIframe').src = url;
		}
		
		function closeLiveTimingEmbed() {
			document.getElementById('liveTimingEmbed').classList.add('hidden');
			document.getElementById('liveTimingIframe').src = 'about:blank';
		}
		
		function toggleLiveTimingEmbed() {
			const embed = document.getElementById('liveTimingEmbed');
			if (embed.classList.contains('hidden')) {
				openLiveTimingEmbed();
			} else {
				closeLiveTimingEmbed();
			}
		}
		
		function refreshLiveTiming() {
			fetchLiveTimingFromProxy();
		}
		
		// ==================== DEMO MODE ====================
		function startDemoMode() {
			liveTimingConfig.demoMode = true;
			liveTimingConfig.enabled = true;
			
			initializeDemoCompetitors();
			
			document.getElementById('liveTimingStatus').innerText = "ğŸ® Demo Mode Active";
			document.getElementById('liveTimingStatus').className = "text-[10px] text-neon text-center font-bold";
		}
		
		function initializeDemoCompetitors() {
			const teamNames = [
				'Your Team', 'Racing Stars', 'Speed Demons', 'Track Masters', 
				'Nitro Force', 'Apex Racing', 'Thunder Karts', 'Pro Racers',
				'Fast Lane', 'Grid Warriors'
			];
			
			demoState.competitors = teamNames.map((name, idx) => ({
				name: name,
				position: idx + 1,
				previousPosition: idx + 1,
				laps: 0,
				lastLap: null,
				bestLap: null,
				baseLapTime: null,
				totalRaceTime: 0,
				pitStops: 0,
				inPit: false,
				isOurTeam: idx === 0
			}));
			
			demoState.competitors.sort(() => Math.random() - 0.5);
			demoState.competitors.forEach((c, i) => {
				c.position = i + 1;
				c.previousPosition = i + 1;
			});
		}
		
		function updateDemoData() {
			if (!liveTimingConfig.demoMode || !state.isRunning) return;
			
			const raceElapsed = Date.now() - state.startTime;
			
			demoState.competitors.forEach((comp, idx) => {
				if (!comp.baseLapTime) {
					comp.baseLapTime = 61000 + (idx * 400) + (Math.random() * 500);
				}
				
				const expectedLaps = Math.floor(raceElapsed / comp.baseLapTime);
				
				if (expectedLaps > comp.laps) {
					comp.laps = expectedLaps;
					comp.lastLap = comp.baseLapTime + (Math.random() - 0.5) * 1000;
					
					if (!comp.bestLap || comp.lastLap < comp.bestLap) {
						comp.bestLap = comp.lastLap;
					}
				}
				
				const pitInterval = 50 * 60 * 1000 + (idx * 2 * 60 * 1000);
				const expectedPits = Math.floor(raceElapsed / pitInterval);
				if (expectedPits > comp.pitStops) {
					comp.pitStops = expectedPits;
				}
				
				const pitTimePenalty = 120000;
				const timeSinceLastPit = raceElapsed - (comp.pitStops * pitInterval);
				comp.inPit = timeSinceLastPit >= 0 && timeSinceLastPit < pitTimePenalty && comp.pitStops > 0;
				
				let currentPitPenalty = comp.pitStops * pitTimePenalty;
				if (comp.inPit) {
					currentPitPenalty = ((comp.pitStops - 1) * pitTimePenalty) + timeSinceLastPit;
				}
				
				comp.totalRaceTime = (comp.laps * comp.baseLapTime) + currentPitPenalty;
			});
			
			demoState.competitors.sort((a, b) => {
				if (b.laps !== a.laps) return b.laps - a.laps;
				return a.totalRaceTime - b.totalRaceTime;
			});
			
			const leader = demoState.competitors[0];
			demoState.competitors.forEach((c, i) => {
				c.previousPosition = c.position;
				c.position = i + 1;
				
				if (i === 0) {
					c.gapToLeader = 0;
				} else {
					c.gapToLeader = c.totalRaceTime - leader.totalRaceTime;
				}
			});
			
			// Update liveData with our team
			const ourTeam = demoState.competitors.find(c => c.isOurTeam);
			if (ourTeam) {
				liveData.previousPosition = liveData.position;
				liveData.position = ourTeam.position;
				liveData.lastLap = ourTeam.lastLap;
				liveData.bestLap = ourTeam.bestLap;
				liveData.laps = ourTeam.laps;
				liveData.gapToLeader = ourTeam.gapToLeader;
			}
			
			liveData.competitors = demoState.competitors;
			updateLiveTimingUI();
		}
		
		function formatLapTime(ms) {
			if (!ms) return '--';
			const totalSec = ms / 1000;
			const min = Math.floor(totalSec / 60);
			const sec = (totalSec % 60).toFixed(3);
			return `${min}:${sec.padStart(6, '0')}`;
		}
		
        function updateLiveTimingUI() {
			if (!liveTimingConfig.enabled) return;
			
			const panel = document.getElementById('liveTimingPanel');
			const indicator = document.getElementById('liveIndicator');
			if (panel) panel.classList.remove('hidden');
			if (indicator) indicator.classList.remove('hidden');
			
			const posEl = document.getElementById('livePosition');
			if (posEl) posEl.innerText = liveData.position || '-';
			
			const changeEl = document.getElementById('livePositionChange');
			if (changeEl && liveData.previousPosition && liveData.position) {
				const diff = liveData.previousPosition - liveData.position;
				if (diff > 0) {
					changeEl.innerText = `â–² ${diff}`;
					changeEl.className = 'text-[10px] position-up';
				} else if (diff < 0) {
					changeEl.innerText = `â–¼ ${Math.abs(diff)}`;
					changeEl.className = 'text-[10px] position-down';
				} else {
					changeEl.innerText = 'â€”';
					changeEl.className = 'text-[10px] position-same';
				}
			}
			
			const lastLapEl = document.getElementById('liveLastLap');
			if (lastLapEl && liveData.lastLap) lastLapEl.innerText = formatLapTime(liveData.lastLap);
			
			const bestLapEl = document.getElementById('liveBestLap');
			if (bestLapEl && liveData.bestLap) bestLapEl.innerText = formatLapTime(liveData.bestLap);
			
			updateCompetitorsTable();
		}
		
		function updateCompetitorsTable() {
			const tableEl = document.getElementById('competitorsTable');
			if (!tableEl) return;
			
			if (!liveData.competitors || liveData.competitors.length === 0) {
				tableEl.innerHTML = `<div class="text-gray-500 text-center py-2">${t('waitingData')}</div>`;
				return;
			}
			
			// Find our team for gap calculations
			const ourTeam = liveData.competitors.find(c => c.isOurTeam);
			
			let html = '';
			liveData.competitors.slice(0, 10).forEach((comp, idx) => {
				const isUs = comp.isOurTeam;
				const isDanger = !isUs && liveData.position && Math.abs(comp.position - liveData.position) <= 2;
				
				let posClass = 'text-gray-400';
				if (comp.position === 1) posClass = 'text-gold';
				else if (comp.position === 2) posClass = 'text-silver';
				else if (comp.position === 3) posClass = 'text-bronze';
				
				let rowClass = 'competitor-row py-1 px-2 rounded flex justify-between items-center mb-1';
				if (isUs) rowClass += ' our-team';
				else if (isDanger) rowClass += ' danger-zone';
				
				const pitIndicator = comp.inPit ? '<span class="text-fuel animate-pulse">ğŸ”§</span>' : '';
				
				// Calculate gap display
				let gapDisplay = '';
				if (comp.position === 1) {
					gapDisplay = '<span class="text-gold">Leader</span>';
				} else if (comp.gapToLeader) {
					// If gap is more than a lap worth (~65 sec), show laps + seconds
					if (ourTeam && !isUs) {
						const gapToUs = comp.totalRaceTime - ourTeam.totalRaceTime;
						if (Math.abs(gapToUs) < 120000) {
							const gapSec = (gapToUs / 1000).toFixed(1);
							gapDisplay = gapToUs > 0 
								? `<span class="text-green-400">+${gapSec}s</span>` 
								: `<span class="text-red-400">${gapSec}s</span>`;
						} else {
							const lapDiff = ourTeam.laps - comp.laps;
							if (lapDiff !== 0) {
								gapDisplay = lapDiff > 0 
									? `<span class="text-green-400">+${lapDiff} lap${lapDiff > 1 ? 's' : ''}</span>`
									: `<span class="text-red-400">${lapDiff} lap${Math.abs(lapDiff) > 1 ? 's' : ''}</span>`;
							}
						}
					} else if (!isUs) {
						const gapSec = (comp.gapToLeader / 1000).toFixed(1);
						gapDisplay = `<span class="text-gray-500">+${gapSec}s</span>`;
					}
				}
				
				// Last lap time
				const lastLapDisplay = comp.lastLap ? `<span class="text-gray-400">${formatLapTime(comp.lastLap)}</span>` : '';
				
				html += `
					<div class="${rowClass}">
						<div class="flex items-center gap-2">
							<span class="${posClass} font-bold w-5">${comp.position}</span>
							<span class="text-white text-[11px]">${comp.name}</span>
							${pitIndicator}
						</div>
						<div class="flex items-center gap-2 text-[10px]">
							${lastLapDisplay}
							<span class="w-16 text-right">${gapDisplay}</span>
						</div>
					</div>
				`;
			});
			
			tableEl.innerHTML = html;

			// âœ… ×’×œ×•×œ ×œ×§×‘×•×¦×” ×©×œ× ×•
			if (liveData.competitors.some(c => c.isOurTeam)) {
				setTimeout(scrollToOurTeam, 500);
			}
		}

		function scrollToOurTeam() {
			const rows = document.querySelectorAll('.competitor-row');
			let ourRow = null;
			
			rows.forEach(row => {
				if (row.classList.contains('our-team')) {
					ourRow = row;
				}
			});
			
			if (ourRow) {
				ourRow.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'nearest'
				});
				
				ourRow.classList.add('flash-alert');
				setTimeout(() => {
					ourRow.classList.remove('flash-alert');
				}, 2000);
				
				console.log('âœ… Auto-scrolled to our team');
			}
		}
		
		function startLiveTimingUpdates() {
			if (liveTimingConfig.demoMode) {
				liveTimingInterval = setInterval(updateDemoData, 1000);
			} else if (liveTimingConfig.url) {
				startProxyLiveTiming();
			}
		}
		
		function stopLiveTiming() {
			// ×¢×¦×•×¨ scraper
			if (liveTimingManager) {
				console.log('[Strateger] Stopping live timing scraper');
				liveTimingManager.stop();
				liveTimingManager = null;
			}
			
			// × ×§×” × ×ª×•× ×™×
			liveData.position = null;
			liveData.lastLap = null;
			liveData.bestLap = null;
			liveData.laps = 0;
			liveData.gapToLeader = 0;
			liveData.competitors = [];
			liveData.previousPosition = null;
			
			// âœ… ×”×¡×ª×¨ ×¤×× ×œ
			const panel = document.getElementById('liveTimingPanel');
			if (panel) {
				panel.classList.add('hidden');
			}
			
			// âœ… ×”×¡×ª×¨ live indicator
			const liveIndicator = document.getElementById('liveIndicator');
			if (liveIndicator) {
				liveIndicator.classList.add('hidden');
			}
			
			// × ×§×” UI
			updateLiveTimingUI();
			updateCompetitorsTable();
			updateProxyStatus("â¹ï¸ " + t('stopped'));
			
			// ××¤×¡ config
			liveTimingConfig.enabled = false;
			
			console.log('âœ… Live Timing fully stopped');
		}
		
		/**
		 * ×§×‘×œ×ª ×¡×˜×˜×™×¡×˜×™×§×•×ª ×©×œ ×”-scraper
		 * ×©×™××•×©×™ ×œ×“×™×‘×•×’
		 */
		function getLiveTimingStats() {
			if (liveTimingManager) {
				const stats = liveTimingManager.getStats();
				console.log('[Strateger] Live timing stats:', stats);
				return stats;
			}
			return null;
		}

		
		function stopLiveTimingUpdates() {
			if (liveTimingInterval) {
				clearInterval(liveTimingInterval);
				liveTimingInterval = null;
			}
			stopProxyLiveTiming();
		}
		
		// ==================== RACE STATE PERSISTENCE ====================
		function saveRaceState() {
			if (role !== 'host' || !state.isRunning) return;
			
			const raceState = {
				config,
				state,
				drivers,
				liveTimingConfig,
				myId,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem(RACE_STATE_KEY, JSON.stringify(raceState));
			} catch (e) {
				console.error("Failed to save race state:", e);
			}
		}

		async function saveRaceToDatabase() {
			if (role !== 'host') return;
			
			console.log('ğŸ’¾ Saving race to Neon DB...');
			
			try {
				// ×”×›×Ÿ × ×ª×•× ×™×
				const raceData = {
					raceDuration: config.raceMs,
					totalStints: state.pitCount + 1,
					totalPitStops: state.pitCount,
					drivers: drivers.map(d => ({
						name: d.name,
						totalTime: d.totalMs,
						stints: d.stints,
						avgStint: d.totalMs / d.stints,
						squad: d.squad
					})),
					strategyData: {
						targetStintMs: config.maxStintMs,
						actualAvgStint: drivers.reduce((sum, d) => sum + (d.totalMs / d.stints), 0) / drivers.length,
						fuelTracking: config.trackFuel,
						squadsUsed: config.useSquads
					},
					config: {
						raceMs: config.raceMs,
						reqStops: config.reqStops,
						minStintMs: config.minStintMs,
						maxStintMs: config.maxStintMs,
						minDriverMs: config.minDriverMs,
						maxDriverMs: config.maxDriverMs,
						useSquads: config.useSquads,
						trackFuel: config.trackFuel
					}
				};
				
				// ×©×œ×— ×œ-Netlify Function
				const response = await fetch('/.netlify/functions/save-race', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify(raceData)
				});
				
				const result = await response.json();
				
				if (result.success) {
					console.log('âœ… Race saved! ID:', result.raceId);
					alert(`ğŸ Race Finished!\nâœ… Strategy saved to database (ID: ${result.raceId})`);
				} else {
					console.error('âŒ Failed to save:', result.error);
				}
				
			} catch (error) {
				console.error('âŒ Error saving to Neon:', error);
			}
		}

		function checkForSavedRace() {
			try {
				const saved = localStorage.getItem(RACE_STATE_KEY);
				if (!saved) return;
				
				const raceState = JSON.parse(saved);
				
				if (Date.now() - raceState.timestamp > 24 * 60 * 60 * 1000) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				if (!raceState.state || !raceState.state.isRunning) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				const elapsed = Date.now() - raceState.timestamp;
				const raceRemaining = raceState.config.raceMs - (raceState.timestamp - raceState.state.startTime);
				
				if (raceRemaining <= 0) {
					localStorage.removeItem(RACE_STATE_KEY);
					return;
				}
				
				const msgs = {
					en: `Active race found!\nDriver: ${raceState.drivers[raceState.state.currentDriverIdx].name}\nRemaining: ${fmtHMS(raceRemaining - elapsed)}\n\nContinue?`,
					he: `× ××¦× ××™×¨×•×¥ ×¤×¢×™×œ!\n× ×”×’: ${raceState.drivers[raceState.state.currentDriverIdx].name}\n× ×•×ª×¨: ${fmtHMS(raceRemaining - elapsed)}\n\n×œ×”××©×™×š?`,
					fr: `Course active trouvÃ©e!\nPilote: ${raceState.drivers[raceState.state.currentDriverIdx].name}\nRestant: ${fmtHMS(raceRemaining - elapsed)}\n\nContinuer?`,
					pt: `Corrida ativa encontrada!\nPiloto: ${raceState.drivers[raceState.state.currentDriverIdx].name}\nRestante: ${fmtHMS(raceRemaining - elapsed)}\n\nContinuar?`
				};
				
				if (confirm(msgs[currentLang] || msgs.en)) {
					restoreRaceState(raceState, elapsed);
				} else {
					localStorage.removeItem(RACE_STATE_KEY);
				}
			} catch (e) {
				console.error("Failed to check saved race:", e);
				localStorage.removeItem(RACE_STATE_KEY);
			}
		}

		function restoreRaceState(raceState, elapsed) {
			config = raceState.config;
			state = raceState.state;
			drivers = raceState.drivers;
			liveTimingConfig = raceState.liveTimingConfig || {};
			
			if (!state.isInPit) {
				state.stintOffset += elapsed;
			}
			
			role = 'host';
			selectRole('host');
			
			const checkPeer = setInterval(() => {
				if (peer && peer.open) {
					clearInterval(checkPeer);
					startHostUI();
					startLiveTimingUpdates();
				}
			}, 100);
		}

		function clearSavedRace() {
			localStorage.removeItem(RACE_STATE_KEY);
		}

        // ==================== AUDIO ====================
        function beep(freq = 800, type = 'sine', dur = 0.2) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.value = 0.3;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                o.stop(ctx.currentTime + dur);
            } catch (e) {}
        }

        function keepScreenAwake() {
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => {});
            }
        }

        // ==================== FORMAT HELPERS ====================
        function fmtHMS(ms) {
            const s = Math.floor(ms / 1000);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            return h > 0 
                ? `${h}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`
                : `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        }
		
		function copyCode(elementId) {
			const code = document.getElementById(elementId).innerText;
			if (!code || code === '---') return;
			navigator.clipboard.writeText(code);
		}
		
		function copyHostCode() {
			copyCode('dashboardHostId');
		}

        // ==================== STATE PERSISTENCE ====================
		const SESSION_KEY = 'strateger_session';
		const HOST_ID_KEY = 'strateger_host_id';
		
		function saveHostState() {
			if (role !== 'host') return;
			
			const inputs = document.querySelectorAll('.driver-input');
			const radios = document.querySelectorAll('.starter-radio');
			const squads = document.querySelectorAll('.squad-toggle');
			
			let starterIdx = 0;
			radios.forEach((r, i) => { if (r.checked) starterIdx = i; });
			
			const driversData = Array.from(inputs).map((input, i) => ({
				name: input.value,
				isStarter: i === starterIdx,
				squad: squads[i]?.checked ? 'B' : 'A'
			}));
			
			const cfg = {
				raceDuration: document.getElementById('raceDuration').value,
				reqPitStops: document.getElementById('reqPitStops').value,
				minStint: document.getElementById('minStint').value,
				maxStint: document.getElementById('maxStint').value,
				minDriverTime: document.getElementById('minDriverTime').value,
				maxDriverTime: document.getElementById('maxDriverTime').value,
				minPitTime: document.getElementById('minPitTime').value,
				releaseBuffer: document.getElementById('releaseBuffer').value,
				allowDouble: document.getElementById('allowDouble').checked,
				trackFuel: document.getElementById('trackFuel').checked,
				maxFuelTime: document.getElementById('maxFuelTime').value,
				useSquads: document.getElementById('useSquads').checked,
				liveTimingUrl: document.getElementById('liveTimingUrl').value,
				searchType: document.querySelector('input[name="searchType"]:checked')?.value || 'team',
				searchValue: document.getElementById('searchValue')?.value || '',
				drivers: driversData,
				simResult: document.getElementById('simResult').innerText,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem('strateger_host_config', JSON.stringify(cfg));
			} catch (e) {
				console.error("Failed to save config:", e);
			}
		}
		
		function restoreHostState() {
			try {
				const saved = localStorage.getItem('strateger_host_config');
				if (!saved) return;
				
				const cfg = JSON.parse(saved);
				
				// Only restore if less than 24 hours old
				if (Date.now() - cfg.timestamp > 24 * 60 * 60 * 1000) {
					localStorage.removeItem('strateger_host_config');
					return;
				}
				
				// Restore values
				if (cfg.raceDuration) document.getElementById('raceDuration').value = cfg.raceDuration;
				if (cfg.reqPitStops) document.getElementById('reqPitStops').value = cfg.reqPitStops;
				if (cfg.minStint) document.getElementById('minStint').value = cfg.minStint;
				if (cfg.maxStint) document.getElementById('maxStint').value = cfg.maxStint;
				if (cfg.minDriverTime) document.getElementById('minDriverTime').value = cfg.minDriverTime;
				if (cfg.maxDriverTime) document.getElementById('maxDriverTime').value = cfg.maxDriverTime;
				if (cfg.minPitTime) document.getElementById('minPitTime').value = cfg.minPitTime;
				if (cfg.releaseBuffer) document.getElementById('releaseBuffer').value = cfg.releaseBuffer;
				document.getElementById('allowDouble').checked = cfg.allowDouble || false;
				document.getElementById('trackFuel').checked = cfg.trackFuel || false;
				if (cfg.maxFuelTime) document.getElementById('maxFuelTime').value = cfg.maxFuelTime;
				document.getElementById('useSquads').checked = cfg.useSquads || false;
				document.getElementById('liveTimingUrl').value = cfg.liveTimingUrl || '';
				document.getElementById('searchValue').value = cfg.searchValue || '';
				
				if (cfg.searchType) {
					const radio = document.querySelector(`input[name="searchType"][value="${cfg.searchType}"]`);
					if (radio) radio.checked = true;
				}
				
				// Restore drivers
				const list = document.getElementById('driversList');
				list.innerHTML = '';
				
				if (cfg.drivers && cfg.drivers.length > 0) {
					cfg.drivers.forEach((driver) => {
						createDriverInput(driver.name, driver.isStarter, driver.squad);
					});
				} else {
					generateDrivers();
				}
				
				toggleFuelInput();
				toggleSquadsInput();
				updateSearchPlaceholder();
				
				if (cfg.simResult) {
					document.getElementById('simResult').innerText = cfg.simResult;
				}
				
				runSim();
			} catch (e) {
				console.error("Failed to restore config:", e);
			}
		}

        // ==================== HOST PEER ====================
        function initHostPeer() {
            const statusText = document.getElementById('netStatusText');
            const retryBtn = document.getElementById('retryBtn');
            
            statusText.innerText = t('connecting');
            statusText.className = "text-[10px] text-yellow-500 mt-2";
            retryBtn.classList.add('hidden');
            
            try {
                myId = String(Math.floor(1000000 + Math.random() * 9000000));
                
                if (peer) {
                    peer.destroy();
					peer = null;
                }
                
                console.log("Creating peer with ID:", myId);
                peer = new Peer(myId, peerConfig);
                
                peer.on('open', (id) => {
                    console.log("Peer connected with ID:", id);
                    document.getElementById('myHostId').innerText = id;
                    statusText.innerText = "âœ… " + t('connected');
                    statusText.className = "text-[10px] text-green-500 font-bold mt-2";
                    connectionRetries = 0;
                });
                
                peer.on('connection', (c) => {
                    console.log("New client connected:", c.peer);
                    connections.push(c);
                    updateClientCount();
                    
                    c.on('open', () => {
						console.log("Connection opened with:", c.peer);
						if (state.isRunning) {
							c.send({ type: 'INIT', config, state, drivers, liveData, liveTimingConfig });
						}
					});
                    
                    c.on('data', (d) => {
                        if (d === 'REQUEST_INIT' && state.isRunning) {
                            c.send({ type: 'INIT', config, state, drivers, liveData, liveTimingConfig });
                        }
                    });
                    
                    c.on('close', () => {
                        connections = connections.filter(x => x !== c);
                        updateClientCount();
                    });
                });
                
                peer.on('error', (err) => {
                    console.error("Peer error:", err);
                    statusText.innerText = `âŒ ${t('error')} ${err.type}`;
                    statusText.className = "text-[10px] text-red-500 mt-2";
                    retryBtn.classList.remove('hidden');
                });
                
                peer.on('disconnected', () => {
                    if (connectionRetries < MAX_RETRIES) {
                        connectionRetries++;
                        setTimeout(() => peer.reconnect(), 2000);
                    }
                });
            } catch (e) {
                statusText.innerText = `âŒ ${t('error')} ${e.message}`;
                retryBtn.classList.remove('hidden');
            }
        }
        
        function updateClientCount() {
            const count = connections.filter(c => c.open).length;
            const syncText = document.getElementById('syncText');
            if (syncText) {
                syncText.innerText = count > 0 ? `${count} ${t('viewer')}${count > 1 ? 's' : ''}` : t('synced');
            }
        }

        // ==================== CLIENT PEER ====================
		function initClientPeer() {
			return new Promise((resolve, reject) => {
				if (peer && !peer.destroyed) {
					if (peer.open) {
						resolve(peer.id);
						return;
					}
					peer.destroy();
				}
				
				const clientId = 'viewer_' + Math.random().toString(36).substr(2, 9);
				peer = new Peer(clientId, peerConfig);
				
				peer.on('open', (id) => {
					console.log("Client peer ready:", id);
					resolve(id);
				});
				
				peer.on('error', (err) => {
					console.error("Client peer error:", err);
					const msg = document.getElementById('clientConnMsg');
					if (msg) {
						msg.innerText = `${t('error')} ${err.type}`;
						msg.className = "text-xs text-red-500 mt-2";
					}
				});
				
				peer.on('disconnected', () => {
					if (peer && !peer.destroyed) {
						peer.reconnect();
					}
				});
			});
		}
		
		function disconnectClient() {
			if (conn) {
				conn.close();
				conn = null;
			}
			
			const msg = document.getElementById('clientConnMsg');
			msg.innerText = t('disconnected');
			msg.className = "text-xs text-gray-500 mt-2";
			
			document.getElementById('disconnectBtn').classList.add('hidden');
			
			const dashboardVisible = !document.getElementById('raceDashboard').classList.contains('hidden');
			if (dashboardVisible) {
				document.getElementById('raceDashboard').classList.add('hidden');
				document.getElementById('setupScreen').classList.remove('hidden');
			}
		}

        function connectToHost() {
			const hostId = document.getElementById('remoteIdInput').value.trim();
			if (!hostId) return;
			
			const msg = document.getElementById('clientConnMsg');
			msg.innerText = t('connecting');
			msg.className = "text-xs text-yellow-500 mt-2";
			
			if (conn) {
				conn.close();
				conn = null;
			}
			
			if (!peer || peer.destroyed) {
				initClientPeer().then(() => {
					doConnect(hostId, msg);
				});
				return;
			}
			
			if (peer.disconnected) {
				peer.reconnect();
				peer.once('open', () => {
					doConnect(hostId, msg);
				});
				return;
			}
			
			doConnect(hostId, msg);
		}

		function doConnect(hostId, msg) {
			console.log("Connecting to host:", hostId);
			
			conn = peer.connect(hostId, { reliable: true });
			
			if (!conn) {
				msg.innerText = `${t('error')} Connection failed`;
				msg.className = "text-xs text-red-500 mt-2";
				return;
			}
			
			conn.on('open', () => {
				console.log("Connected to host:", hostId);
				msg.innerText = t('waitingRace');
				msg.className = "text-xs text-green-500 mt-2";
				document.getElementById('disconnectBtn').classList.remove('hidden');
				conn.send('REQUEST_INIT');
			});

			conn.on('data', (d) => {
				console.log("Received data:", d.type);
				
				if (d.type === 'INIT' || d.type === 'UPDATE') { 
					if (d.config) config = d.config; 
					if (d.drivers) drivers = d.drivers; 
					if (d.state) state = d.state;
					if (d.liveTimingConfig) liveTimingConfig = d.liveTimingConfig;
					if (d.liveData) liveData = d.liveData;
					if (d.calculatedTimes) syncedTimes = d.calculatedTimes;
					
					const dashboardHidden = document.getElementById('raceDashboard').classList.contains('hidden');
					
					if (state && state.isRunning && dashboardHidden) {
						startClientUI();
					} else if (state && state.isRunning && !dashboardHidden) {
						renderFrame(); 
						updateStats(syncedTimes ? syncedTimes.stintElapsed : 0); 
						if (liveData) updateLiveTimingUI();
					} else if (!state || !state.isRunning) {
						msg.innerText = t('waitingRace');
						msg.className = "text-xs text-yellow-500 mt-2";
					}
				}
			});
			
			conn.on('close', () => {
				console.log("Disconnected from host");
				msg.innerText = t('disconnected');
				msg.className = "text-xs text-red-500 mt-2";
				
				document.getElementById('disconnectBtn').classList.add('hidden');
				
				const dashboardVisible = !document.getElementById('raceDashboard').classList.contains('hidden');
				if (dashboardVisible) {
					document.getElementById('raceDashboard').classList.add('hidden');
					document.getElementById('setupScreen').classList.remove('hidden');
				}
				
				conn = null;
			});
			
			conn.on('error', (err) => {
				console.error("Connection error:", err);
				msg.innerText = `${t('error')} ${err.type || err}`;
				msg.className = "text-xs text-red-500 mt-2";
			});
		}

        // ==================== BROADCAST ====================
        function broadcast() {
			if (role !== 'host' || !peer || connections.length === 0) return;
			const now = Date.now();
			const msg = {
				config: config,
				drivers: drivers,
				state: state,
				liveTimingConfig: liveTimingConfig,
				syncedTimes: {  // âœ… ×”×•×¡×£
					raceElapsed: now - state.startTime,
					stintElapsed: state.isInPit ? 0 : (now - state.stintStart + state.stintOffset),
					timestamp: now
				}
			};
			connections.forEach(c => {
				if (c.open) c.send(msg);
			});
			updateClientCount();
		}

        // ==================== UI TOGGLES ====================
        function toggleFuelInput() { 
            document.getElementById('fuelInputDiv').classList.toggle('hidden', !document.getElementById('trackFuel').checked); 
        }
        
        function toggleSquadsInput() { 
            document.querySelectorAll('.squad-toggle-container').forEach(el => 
                el.classList.toggle('hidden', !document.getElementById('useSquads').checked)
            ); 
        }

        // ==================== DRIVER MANAGEMENT ====================
        function generateDrivers() {
			const list = document.getElementById('driversList'); 
			list.innerHTML = '';
			["Driver 1", "Driver 2", "Driver 3", "Driver 4"].forEach((n, i) => createDriverInput(n, i === 0, i < 2 ? 'A' : 'B'));
			toggleSquadsInput();
			updateDriversListHeight();
		}
        
        function createDriverInput(val, checked, squad) {
			const div = document.createElement('div');
			div.className = "flex items-center gap-2 bg-navy-950 p-2 rounded border border-gray-700";
			const radioId = 'starter_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
			
			// âœ… ×™×¦×™×¨×ª ××œ×× ×˜×™× ×™×©×™×¨×•×ª
			const label = document.createElement('label');
			label.className = "flex items-center cursor-pointer";
			
			const radio = document.createElement('input');
			radio.type = 'radio';
			radio.name = 'starter';
			radio.id = radioId;
			radio.className = 'starter-radio sr-only';
			radio.checked = checked;
			
			const indicator = document.createElement('div');
			indicator.className = checked 
				? 'starter-indicator w-8 h-8 rounded-full border-2 border-ice bg-ice/30 shadow-[0_0_8px_rgba(34,211,238,0.5)] flex items-center justify-center text-sm'
				: 'starter-indicator w-8 h-8 rounded-full border-2 border-gray-500 flex items-center justify-center text-sm hover:border-ice transition';
			indicator.textContent = 'ğŸ';
			
			// âœ… Event handler ×××™×ª×™ ×¢× stopPropagation
			label.addEventListener('click', function(e) {
				e.stopPropagation();
				radio.checked = true;
				updateStarterVisuals();
			});
			
			label.appendChild(radio);
			label.appendChild(indicator);
			
			// Driver input
			const driverInput = document.createElement('input');
			driverInput.type = 'text';
			driverInput.value = val;
			driverInput.className = 'driver-input bg-transparent text-white w-full outline-none font-bold';
			
			// Squad toggle
			const squadLabel = document.createElement('label');
			squadLabel.className = 'squad-toggle-container flex items-center cursor-pointer ml-auto bg-navy-800 rounded px-2 py-1 border border-gray-600 hidden';
			squadLabel.innerHTML = `
				<span class="text-[10px] mr-1 text-gray-400">${t('squads')}</span>
				<input type="checkbox" class="squad-toggle hidden" ${squad === 'B' ? 'checked' : ''} onchange="this.nextElementSibling.innerText = this.checked ? 'B' : 'A'; this.nextElementSibling.className = this.checked ? 'w-6 h-4 rounded bg-squadB text-[8px] flex items-center justify-center font-bold text-white' : 'w-6 h-4 rounded bg-squadA text-[8px] flex items-center justify-center font-bold text-white'">
				<div class="w-6 h-4 rounded ${squad === 'B' ? 'bg-squadB' : 'bg-squadA'} text-[8px] flex items-center justify-center font-bold text-white">${squad}</div>
			`;
			
			div.appendChild(label);
			div.appendChild(driverInput);
			div.appendChild(squadLabel);
			document.getElementById('driversList').appendChild(div);
		}
		
		function updateStarterVisuals(event) {
			if (event) event.stopPropagation();  // âœ… ×”×•×¡×£
			
			document.querySelectorAll('.starter-indicator').forEach(ind => {
				const radio = ind.previousElementSibling;
				if (radio && radio.checked) {
					ind.className = 'starter-indicator w-8 h-8 rounded-full border-2 border-ice bg-ice/30 shadow-[0_0_8px_rgba(34,211,238,0.5)] flex items-center justify-center text-sm';
				} else {
					ind.className = 'starter-indicator w-8 h-8 rounded-full border-2 border-gray-500 flex items-center justify-center text-sm hover:border-ice transition';
				}
			});
		}
        
        function updateDriversListHeight() {
			const list = document.getElementById('driversList');
			const count = list.children.length;
			const rowHeight = 52;
			const maxVisible = 10;
			const newHeight = Math.min(count, maxVisible) * rowHeight;
			list.style.maxHeight = newHeight + 'px';
		}

		function addDriverField() { 
			createDriverInput(`Driver ${document.getElementById('driversList').children.length + 1}`, false, 'A'); 
			toggleSquadsInput();
			updateDriversListHeight();
		}

		function removeDriverField() { 
			const l = document.getElementById('driversList'); 
			if (l.children.length > 2) {
				l.removeChild(l.lastChild);
				updateDriversListHeight();
			}
		}

        // ==================== RACE INITIALIZATION ====================
        function initRace() {
            if (role === 'client') return;
            
            const inputs = document.querySelectorAll('.driver-input');
            const radios = document.querySelectorAll('.starter-radio');
            const squads = document.querySelectorAll('.squad-toggle');
            let startIdx = 0; 
            radios.forEach((r, i) => { if (r.checked) startIdx = i; });
            
            if (inputs.length < 2) return alert("Minimum 2 drivers required");
            
			config = {
                raceMs: parseFloat(document.getElementById('raceDuration').value) * 3600000,
                reqStops: parseInt(document.getElementById('reqPitStops').value) || 0,
                minPitSec: parseInt(document.getElementById('minPitTime').value) || 0,
                releaseBufferSec: parseInt(document.getElementById('releaseBuffer').value) || 0,
                minStintMs: parseFloat(document.getElementById('minStint').value) * 60000,
                maxStintMs: parseFloat(document.getElementById('maxStint').value) * 60000,
                minDriverMs: parseFloat(document.getElementById('minDriverTime').value) * 60000,
                maxDriverMs: parseFloat(document.getElementById('maxDriverTime').value) * 60000,
                allowDouble: document.getElementById('allowDouble').checked,
                trackFuel: document.getElementById('trackFuel').checked,
                maxFuelMs: parseFloat(document.getElementById('maxFuelTime').value) * 60000,
                useSquads: document.getElementById('useSquads').checked
            };
            
            liveTimingConfig.url = document.getElementById('liveTimingUrl').value;
            updateSearchConfig();
            
            drivers = Array.from(inputs).map((d, i) => ({ 
                name: d.value, 
                totalMs: 0, 
                stints: 0, 
                squad: squads[i].checked ? 'B' : 'A', 
                logs: [], 
                isExpanded: false 
            }));
            
            state = { 
				isRunning: true, 
				startTime: Date.now(), 
				stintStart: Date.now(), 
				fuelStart: Date.now(), 
				currentDriverIdx: startIdx, 
				pitCount: 0, 
				isInPit: false, 
				mode: 'normal', 
				trackCondition: 'dry',
				stintOffset: 0, 
				activeSquad: 'A', 
				nextDriverIdx: (startIdx + 1) % drivers.length, 
				targetStintMs: config.raceMs / (config.reqStops + 1), 
				squadsActive: false,
				pendingPitEntry: false,
				globalStintNumber: 1
			};
			
			recalculateTargetStint();
			saveHostState();
            broadcast(); 
            startHostUI();
            startLiveTimingUpdates();
        }

        // ==================== TICK ====================
        function tick() { 
            if (!state.isRunning) return;
            renderFrame();
			
			if (liveTimingConfig.demoMode) {
				updateDemoData();
			}
        }

        // ==================== RENDERING ====================
        function renderFrame() {
			try {
				const now = Date.now();
				
				let raceRemaining, stintTime;
				
				if (role === 'host') {
					raceRemaining = config.raceMs - (now - state.startTime);
					stintTime = state.isInPit ? 0 : (now - state.stintStart + state.stintOffset);
				} else if (syncedTimes) {
					// âœ… Viewer mode - ×—×©×‘ ×‘×¢×¦××š
					const timeSinceLastSync = now - (syncedTimes.timestamp || now);
					raceRemaining = config.raceMs - (syncedTimes.raceElapsed + timeSinceLastSync);
					
					if (!state.isInPit) {
						stintTime = syncedTimes.stintElapsed + timeSinceLastSync;
					} else {
						stintTime = 0;
					}
				} else {
					raceRemaining = config.raceMs - (now - state.startTime);
					stintTime = state.isInPit ? 0 : (now - state.stintStart + state.stintOffset);
				}
				
				if (raceRemaining <= 0) { 
					document.getElementById('raceTimerDisplay').innerText = "Finish"; 
					stopLiveTimingUpdates();
					
					// âœ… ×©××•×¨ ×œ-DB (×¨×§ ×¤×¢× ××—×ª)
					if (role === 'host' && !state.raceSaved) {
						state.raceSaved = true;
						saveRaceToDatabase();
					}
					
					return; 
				}
				document.getElementById('raceTimerDisplay').innerText = fmtHMS(raceRemaining);

				if (!state.isInPit && !state.pendingPitEntry) {
					document.getElementById('stintTimerDisplay').innerText = fmtHMS(Math.max(0, stintTime));
					document.getElementById('stintProgressBar').style.width = Math.min(100, (stintTime / config.maxStintMs) * 100) + '%';
					updateStrategy(stintTime);
				}

                document.getElementById('currentDriverName').innerText = drivers[state.currentDriverIdx].name;
                document.getElementById('nextDriverName').innerText = drivers[state.nextDriverIdx].name;
                document.getElementById('modalNextDriverName').innerText = drivers[state.nextDriverIdx].name;
                document.getElementById('pitCountDisplay').innerText = `${state.pitCount} / ${config.reqStops}`;
                
                if (config.useSquads) {
					document.getElementById('btnNight').classList.remove('hidden');
					
					const nightBtn = document.getElementById('btnNight');
					if (state.squadsActive) {
						// Night mode active - Squad A starts, Squad B finishes
						document.getElementById('activeSquadDisplay').classList.remove('hidden');
						document.getElementById('sleepWidget').classList.remove('hidden');
						
						const activeSquadText = document.getElementById('activeSquadText');
						const sleepersLabel = document.getElementById('sleepWidget').querySelector('p:first-child');
						
						activeSquadText.innerText = state.activeSquad;
						activeSquadText.className = state.activeSquad === 'A' 
							? 'text-lg font-bold text-squadA ml-2' 
							: 'text-lg font-bold text-squadB ml-2';
						
						const sleepers = drivers.filter(d => d.squad !== state.activeSquad);
						document.getElementById('sleepersList').innerText = sleepers.map(d => d.name).join(', ') || "---";
						
						// Show info about squad rotation
						if (sleepersLabel) {
							const restingText = { en: 'Resting', he: '× ×—×™×', fr: 'Au repos', pt: 'Descansando' };
							const nextText = { en: '(up next)', he: '(×”×‘××™×)', fr: '(suivants)', pt: '(prÃ³ximos)' };
							sleepersLabel.innerHTML = `${restingText[currentLang] || restingText.en} <span class="text-gray-500">${state.activeSquad === 'A' ? nextText[currentLang] || nextText.en : ''}</span>:`;
						}
						nightBtn.className = "btn-press bg-cyan-900 border-2 border-cyan-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(6,182,212,0.5)]";
						nightBtn.innerHTML = `<span class="block text-lg">ğŸŒ™ ${t('nightActive')}</span>`;
					} else {
						// Night mode not active - everyone is awake
						document.getElementById('activeSquadDisplay').classList.add('hidden');
						document.getElementById('sleepWidget').classList.add('hidden');
						
						nightBtn.className = "btn-press bg-navy-800 border border-cyan-500/50 rounded-lg p-2 group hover:bg-navy-700 text-cyan-300";
						nightBtn.innerHTML = `<span class="block text-lg">ğŸŒ™ ${t('night')}</span>`;
					}
				} else {
					document.getElementById('btnNight').classList.add('hidden');
					document.getElementById('activeSquadDisplay').classList.add('hidden');
					document.getElementById('sleepWidget').classList.add('hidden');
				}
				
				// Push/Problem button styling
				const btnPush = document.getElementById('btnPush');
				const btnBad = document.getElementById('btnBad');

				if (btnPush) {
					if (state.mode === 'push') {
						btnPush.className = "btn-press bg-green-900 border-2 border-green-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(34,197,94,0.5)]";
						btnPush.innerHTML = `<span class="block text-lg">ğŸ”¥ ${t('pushActive')}</span>`;
					} else {
						btnPush.className = "btn-press bg-navy-800 border border-green-900/50 rounded-lg p-2 group hover:bg-navy-700";
						btnPush.innerHTML = `<span class="block text-lg">ğŸ”¥ ${t('push')}</span>`;
					}
				}

				if (btnBad) {
					if (state.mode === 'bad') {
						btnBad.className = "btn-press bg-red-900 border-2 border-red-400 rounded-lg p-2 group text-white shadow-[0_0_15px_rgba(239,68,68,0.5)]";
						btnBad.innerHTML = `<span class="block text-lg">ğŸ¢ ${t('problemActive')}</span>`;
					} else {
						btnBad.className = "btn-press bg-navy-800 border border-red-900/50 rounded-lg p-2 group hover:bg-navy-700";
						btnBad.innerHTML = `<span class="block text-lg">ğŸ¢ ${t('problem')}</span>`;
					}
				}

				// Weather display
				const rIcon = document.getElementById('rainIcon');
				const rText = document.getElementById('rainText');
				const stratBox = document.getElementById('strategyBox');

				stratBox.className = "p-3 text-center border-b-2 flex flex-col items-center justify-center rounded-lg shadow-lg shrink-0 transition-colors duration-500";

				if (state.trackCondition === 'wet') {
					rIcon.className = "fa-solid fa-cloud-showers-heavy text-ice animate-pulse";
					rText.innerText = t('wet');
					rText.className = "text-xs font-bold text-ice";
					stratBox.classList.add("bg-blue-900/90", "border-ice");
				} else if (state.trackCondition === 'drying') {
					rIcon.className = "fa-solid fa-cloud-rain text-yellow-400";
					rText.innerText = t('drying');
					rText.className = "text-xs font-bold text-yellow-400";
					stratBox.classList.add("bg-yellow-900/50", "border-yellow-500");
				} else {
					rIcon.innerHTML = "â˜€ï¸";
					rIcon.className = "text-lg";
					rText.innerText = t('dry');
					rText.className = "text-xs font-bold text-yellow-400";
					stratBox.classList.add("bg-navy-900", "border-neon");
				}

                // Sync status
                if (role === 'host') {
                    const syncDot = document.getElementById('syncDot');
                    const syncText = document.getElementById('syncText');
                    const activeConns = connections.filter(c => c.open).length;
                    
                    if (activeConns > 0) {
                        syncDot.className = "sync-dot bg-green-500 mr-1";
                        syncText.innerText = `${activeConns} viewer${activeConns > 1 ? 's' : ''}`;
                    } else {
                        syncDot.className = "sync-dot bg-yellow-500 mr-1";
                        syncText.innerText = t('synced');
                    }
                }
            } catch (e) { 
                console.error("Render Error", e); 
            }
        }

		function checkTimerSync() {
			if (role !== 'host') return;
			
			const now = Date.now();
			const raceElapsed = now - state.startTime;
			
			// ×¡×›×•× stints
			let totalStintTime = 0;
			drivers.forEach(d => {
				totalStintTime += d.totalMs;
			});
			
			// ×”×•×¡×£ stint × ×•×›×—×™
			if (!state.isInPit) {
				const currentStintTime = now - state.stintStart + state.stintOffset;
				totalStintTime += currentStintTime;
			}
			
			// ×—×©×‘ ×”×¤×¨×©
			const diff = Math.abs(raceElapsed - totalStintTime);
			const diffSeconds = (diff / 1000).toFixed(1);
			
			console.log('â±ï¸ Timer Sync:');
			console.log(`  Race: ${fmtHMS(raceElapsed)}`);
			console.log(`  Stints: ${fmtHMS(totalStintTime)}`);
			console.log(`  Diff: ${diffSeconds}s`);
			
			if (diff > 5000) {
				console.warn(`âš ï¸ Timer sync issue! ${diffSeconds}s`);
				return { synced: false, difference: diff };
			} else {
				console.log('âœ… Synced!');
				return { synced: true, difference: diff };
			}
		}

		// ×‘×“×™×§×” ××•×˜×•××˜×™×ª ×›×œ 30 ×©× ×™×•×ª
		if (typeof window !== 'undefined' && !window.timerSyncInterval) {
			window.timerSyncInterval = setInterval(() => {
				if (role === 'host' && state.isRunning) {
					checkTimerSync();
				}
			}, 30000);
		}

        function updateStrategy(sTime) {
			if (state.mode === 'normal') {
				recalculateTargetStint();
			}
			
			document.getElementById('strategyTargetStint').innerText = fmtHMS(state.targetStintMs);

			const diff = state.targetStintMs - sTime;
			const dEl = document.getElementById('strategyDelta');
			dEl.innerText = diff > 0 ? `-${Math.ceil(diff / 60000)}m` : `+${Math.floor(Math.abs(diff) / 60000)}m`;
			dEl.className = diff > 0 ? "text-lg font-bold text-gray-400" : "text-lg font-bold text-neon";
			
			const advice = document.getElementById('strategyAdvice');
			const timeToMax = config.maxStintMs - sTime;
			
			if (timeToMax < 0) { 
				advice.innerText = t('timeExceeded');
				advice.className = "text-xs text-red-500 animate-pulse font-bold"; 
			} 
			else if (state.mode === 'bad') {
				advice.innerText = t('problemQuick');
				advice.className = "text-xs text-red-400 font-bold";
			}
			else if (state.mode === 'push') {
				if (timeToMax < 120000) {
					advice.innerText = t('nearLimit');
					advice.className = "text-xs text-yellow-400 font-bold";
				} else {
					advice.innerText = t('pushExtend');
					advice.className = "text-xs text-green-400 font-bold";
				}
			}
			else if (diff < 300000 && diff > -300000) {
				advice.innerText = t('targetWindow');
				advice.className = "text-xs text-ice font-bold";
			} else if (diff > 0) {
				advice.innerText = t('buildTime');
				advice.className = "text-xs text-gray-400";
			} else {
				advice.innerText = t('overExtend');
				advice.className = "text-xs text-yellow-400 font-bold";
			}
		}

        function updateStats(stintMs) {
			const tb = document.getElementById('statsTable'); 
			tb.innerHTML = '';
			
			drivers.forEach((d, i) => {
				let tot = d.totalMs; 
				if (i === state.currentDriverIdx && !state.isInPit) tot += stintMs;
				
				let rowClass = "border-b border-gray-700";
				if (i === state.currentDriverIdx && !state.isInPit) {
					rowClass = "bg-white/10 font-bold text-white border-b border-gray-600";
				}
				
				let timeClass = "text-gray-300"; 
				let symbol = "";
				if (config.minDriverMs > 0 && tot < config.minDriverMs) { 
					timeClass = "text-yellow-500 font-bold"; 
					symbol = "âš ï¸"; 
				} else if (config.maxDriverMs > 0 && tot > config.maxDriverMs) { 
					timeClass = "text-red-500 font-bold animate-pulse"; 
					symbol = "ğŸ›‘"; 
				} else if (config.minDriverMs > 0) { 
					timeClass = "text-green-500 font-bold"; 
					symbol = "âœ…"; 
				}

				const mainRow = document.createElement('tr');
				mainRow.className = rowClass;
				mainRow.innerHTML = `
					<td class="text-center cursor-pointer p-2 hover:text-ice" onclick="toggleLog(${i})">${d.isExpanded ? 'â–²' : 'â–¼'}</td>
					<td class="py-2 pr-2">${d.name} ${symbol}</td>
					<td class="py-2 text-center">${d.stints}${i === state.currentDriverIdx && !state.isInPit ? '+1' : ''}</td>
					<td class="py-2 ${timeClass}">${fmtHMS(tot)}</td>
				`;
				tb.appendChild(mainRow);

				let logContent = '';
				
				// Show past stints
				d.logs.forEach((l, idx) => {
					logContent += `
						<div class="flex justify-between items-center text-[10px] py-1 border-b border-gray-800">
							<span class="text-gray-500">#${l.globalStintNum || idx + 1}</span>
							<span class="text-ice">${fmtHMS(l.drive)}</span>
							<span class="text-fuel">${l.pit ? fmtHMS(l.pit) : '--'}</span>
						</div>
					`;
				});
				
				// Show current running stint for active driver
				if (i === state.currentDriverIdx && !state.isInPit && stintMs > 0) {
					logContent += `
						<div class="flex justify-between items-center text-[10px] py-1 border-b border-gray-800 bg-ice/10 animate-pulse">
							<span class="text-ice font-bold">#${state.globalStintNumber} ğŸï¸</span>
							<span class="text-ice font-bold">${fmtHMS(stintMs)}</span>
							<span class="text-gray-500">--</span>
						</div>
					`;
				}

				const logRow = document.createElement('tr');
				logRow.className = d.isExpanded ? '' : 'hidden';
				logRow.innerHTML = `
					<td colspan="4" class="bg-navy-950 p-2">
						<div class="flex justify-between text-[10px] text-gray-500 border-b border-gray-700 pb-1 mb-1">
							<span>Stint</span>
							<span>Drive</span>
							<span>Pit</span>
						</div>
						${logContent || '<div class="text-gray-600 text-[10px]">No stints yet</div>'}
					</td>
				`;
				tb.appendChild(logRow);
			});
		}

        // ==================== PIT STOP ====================
        function confirmPitEntry() {
			const now = Date.now();
			const sTime = (now - state.stintStart) + state.stintOffset;
			
			if (state.mode !== 'bad' && sTime < config.minStintMs) {
				if (!confirm(t('confirmEarlyPit'))) return;
			}

			state.isInPit = true;
			state.pendingPitEntry = false;
			state.pitStart = Date.now();
			
			const driveTime = (now - state.stintStart) + state.stintOffset;
			drivers[state.currentDriverIdx].totalMs += driveTime;
			drivers[state.currentDriverIdx].stints++;
			drivers[state.currentDriverIdx].logs.push({ 
				drive: driveTime, 
				pit: null,
				globalStintNum: state.globalStintNumber
			});
			state.globalStintNumber++;

			state.stintOffset = 0;
			if (state.squadsActive && drivers[state.nextDriverIdx].squad !== state.activeSquad) {
				state.activeSquad = drivers[state.nextDriverIdx].squad;
			}
			broadcast();

			document.getElementById('pitModal').classList.remove('hidden');
			document.getElementById('pitPhase2').classList.remove('hidden');
			document.getElementById('modalNextDriverName').innerText = drivers[state.nextDriverIdx].name;

			if (config.trackFuel) document.getElementById('fuelToggleContainer').classList.remove('hidden');
			else document.getElementById('fuelToggleContainer').classList.add('hidden');

			const notifyBtn = document.getElementById('notifyBtn');
			const notifiedMsg = document.getElementById('notifiedMsg');
			const confirmBtn = document.getElementById('confirmExitBtn');
			
			notifyBtn.classList.add('hidden');
			notifiedMsg.classList.add('hidden');
			confirmBtn.disabled = true;
			confirmBtn.innerText = t('wait');
			confirmBtn.className = "w-full bg-gray-800 text-gray-600 font-bold py-4 rounded-lg text-xl border border-gray-700 mb-4";
			
			let notified = false;
			let canExit = false;
			const releaseBuffer = config.releaseBufferSec || 0;

			notifyBtn.onclick = () => {
				notified = true;
				notifyBtn.classList.add('hidden');
				notifiedMsg.classList.remove('hidden');
				beep(800, 'sine', 0.3);
				setTimeout(() => beep(1000, 'sine', 0.2), 150);
			};

			confirmBtn.onclick = () => {
				if (!canExit) return;
				
				clearInterval(pitInterval);
				
				const pitTime = Date.now() - state.pitStart;
				const lastLog = drivers[state.currentDriverIdx].logs[drivers[state.currentDriverIdx].logs.length - 1];
				if (lastLog) lastLog.pit = pitTime;

				state.pitCount++; 
				state.currentDriverIdx = state.nextDriverIdx; 
				
				let nextCand = (state.currentDriverIdx + 1) % drivers.length;
				if (state.squadsActive) {
					let found = drivers.findIndex((d, i) => i !== state.currentDriverIdx && d.squad === state.activeSquad);
					if (found !== -1) nextCand = found;
				}
				state.nextDriverIdx = nextCand;

				state.stintStart = Date.now(); 
				state.isInPit = false; 
				state.mode = 'normal';
				
				const isRefuel = document.getElementById('isRefuelCheck')?.checked ?? true;
				if (!config.trackFuel || isRefuel) state.fuelStart = Date.now();

				document.getElementById('pitModal').classList.add('hidden');
				document.getElementById('pitPhase2').classList.add('hidden');
				document.getElementById('btnResetMode').classList.add('hidden');
				broadcast();
			};

			if (pitInterval) clearInterval(pitInterval);
			
			pitInterval = setInterval(() => {
				const elapsed = (Date.now() - state.pitStart) / 1000;
				const remaining = config.minPitSec - elapsed;
				const timeToNotify = remaining - releaseBuffer;
				
				if (remaining > 0) {
					document.getElementById('pitTimerDisplay').innerText = Math.ceil(remaining);
					document.getElementById('pitTimerDisplay').className = "text-5xl font-bold big-digit text-red-500 font-mono";
				} else {
					document.getElementById('pitTimerDisplay').innerText = "0";
					document.getElementById('pitTimerDisplay').className = "text-5xl font-bold big-digit text-green-500 font-mono";
				}
				
				if (releaseBuffer > 0 && timeToNotify <= 0 && !notified && remaining > 0) {
					notifyBtn.classList.remove('hidden');
					notifyBtn.innerHTML = `ğŸ“¢ ${t('notifyDriver')} (${Math.ceil(remaining)}s)`;
					beep(600, 'sine', 0.2);
				}
				
				if (!notified && remaining > 0 && timeToNotify <= 0) {
					notifyBtn.innerHTML = `ğŸ“¢ ${t('notifyDriver')} (${Math.ceil(remaining)}s)`;
				}
				
				if (remaining <= 0 && !canExit) {
					canExit = true;
					notifyBtn.classList.add('hidden');
					confirmBtn.disabled = false;
					confirmBtn.innerText = t('confirmExit');
					confirmBtn.className = "w-full bg-green-500 text-black font-bold py-6 rounded-lg text-2xl shadow-[0_0_20px_#22c55e]";
					beep(800, 'square', 0.5);
				}
				
				updateStats(0);
			}, 100);
		}

        function closePitMenu() { 
            state.pendingPitEntry = false;
            document.getElementById('pitModal').classList.add('hidden'); 
        }
        
        function cancelPitStop() {
            clearInterval(pitInterval);
            
            const lastLog = drivers[state.currentDriverIdx].logs.pop();
            if (lastLog) {
                drivers[state.currentDriverIdx].totalMs -= lastLog.drive;
                drivers[state.currentDriverIdx].stints--;
                state.stintOffset = lastLog.drive;
                state.stintStart = Date.now() - state.stintOffset;
                state.stintOffset = 0;
            }
            
            state.isInPit = false;
            state.pendingPitEntry = false;
            
            document.getElementById('pitModal').classList.add('hidden');
            broadcast();
        }

        // ==================== CONTROLS ====================
		function copyHostCode() {
			const code = document.getElementById('dashboardHostId').innerText;
			if (!code || code === '---') return;
			
			navigator.clipboard.writeText(code).then(() => {
				const el = document.getElementById('dashboardHostId');
				el.classList.add('text-white');
				setTimeout(() => el.classList.remove('text-white'), 1000);
			});
		}
		
        function adjustStint(ms) { 
            state.stintOffset += ms; 
            broadcast(); 
            renderFrame(); 
        }
		
		function cycleNextDriver() {
			if (role !== 'host') return;
			
			// Find eligible drivers (not current driver, and if squads active - same squad)
			let eligible = [];
			drivers.forEach((d, i) => {
				if (i === state.currentDriverIdx) return; // Skip current driver
				if (state.squadsActive && d.squad !== state.activeSquad) return; // Skip other squad if night mode
				eligible.push(i);
			});
			
			if (eligible.length === 0) return;
			
			// Find current position in eligible list and move to next
			const currentPos = eligible.indexOf(state.nextDriverIdx);
			const nextPos = (currentPos + 1) % eligible.length;
			state.nextDriverIdx = eligible[nextPos];
			
			broadcast();
			renderFrame();
		}
        
        function toggleNightMode() { 
            if (role === 'host') { 
                state.squadsActive = !state.squadsActive; 
                broadcast(); 
                renderFrame(); 
            } 
        }
        
        function toggleRain() {
			if (role === 'host') {
				if (!state.trackCondition || state.trackCondition === 'dry') {
					state.trackCondition = 'wet';
				} else if (state.trackCondition === 'wet') {
					state.trackCondition = 'drying';
				} else {
					state.trackCondition = 'dry';
				}
				
				broadcast();
				renderFrame();
			}
		}
        
        function setMode(m) { 
			state.mode = m; 
			document.getElementById('btnResetMode').classList.toggle('hidden', m === 'normal'); 
			recalculateTargetStint();
			broadcast(); 
			renderFrame();
		}

		function recalculateTargetStint() {
			const now = Date.now();
			const raceElapsed = now - state.startTime;
			const raceRemaining = config.raceMs - raceElapsed;
			const stopsRemaining = Math.max(0, config.reqStops - state.pitCount);
			
			// Estimate remaining pit time
			const remainingPitTimeMs = stopsRemaining * config.minPitSec * 1000;
			
			// Available driving time remaining
			const drivingTimeRemaining = raceRemaining - remainingPitTimeMs;
			
			if (state.mode === 'push') {
				state.targetStintMs = config.maxStintMs - 60000;
			} else if (state.mode === 'bad') {
				state.targetStintMs = config.minStintMs;
			} else {
				if (stopsRemaining > 0) {
					// Divide remaining driving time by remaining stints
					state.targetStintMs = Math.floor(drivingTimeRemaining / (stopsRemaining + 1));
				} else {
					state.targetStintMs = drivingTimeRemaining;
				}
				// Clamp to valid range
				state.targetStintMs = Math.min(state.targetStintMs, config.maxStintMs - 60000);
				state.targetStintMs = Math.max(state.targetStintMs, config.minStintMs);
			}
		}
        
        function toggleLog(idx) { 
            drivers[idx].isExpanded = !drivers[idx].isExpanded; 
            updateStats(state.isInPit ? 0 : (Date.now() - state.stintStart + state.stintOffset)); 
        }

        // ==================== UI INITIALIZATION ====================
        function startHostUI() { 
			document.getElementById('setupScreen').classList.add('hidden'); 
			document.getElementById('raceDashboard').classList.remove('hidden'); 
			document.getElementById('syncControls').classList.remove('hidden');
			document.getElementById('hostCodeDisplay').classList.remove('hidden');
			document.getElementById('dashboardHostId').innerText = myId || '---';
			document.getElementById('zoneForbidden').style.width = ((config.minStintMs / config.maxStintMs) * 100) + '%'; 
			
			if (liveTimingConfig.enabled) {
				document.getElementById('liveTimingPanel').classList.remove('hidden');
				document.getElementById('liveIndicator').classList.remove('hidden');
			}
			
			keepScreenAwake();
			
			raceInterval = setInterval(() => { 
				tick(); 
				broadcast(); 
			}, 1000); 
			
			tick(); 
			updateStats(0);
			applyViewerMode();
		}
        
        function startClientUI() {
			if (!config || !drivers || !state) {
				console.error("Missing data for client UI", { config, drivers, state });
				return;
			}
			
			if (!state.isRunning) {
				console.log("Race not started yet");
				return;
			}
			
			document.getElementById('setupScreen').classList.add('hidden');
			document.getElementById('raceDashboard').classList.remove('hidden');
			document.getElementById('zoneForbidden').style.width = ((config.minStintMs / config.maxStintMs) * 100) + '%';
			
			if (liveTimingConfig && liveTimingConfig.enabled) {
				document.getElementById('liveTimingPanel').classList.remove('hidden');
				document.getElementById('liveIndicator').classList.remove('hidden');
			}
			
			keepScreenAwake();
			
			// âœ… ×”×•×¡×£ auto-update ×œviewer
			if (!window.viewerInterval) {
				window.viewerInterval = setInterval(() => {
					if (role === 'client') {
						renderFrame();
					}
				}, 1000);
			}
			
			renderFrame();
			updateStats(syncedTimes ? syncedTimes.stintElapsed : 0);
		}

    </script>
</body>
</html>
